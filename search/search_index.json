{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview This site is the new upcoming central documentation for IoT products of Lobaro GmbH . Hardware Lobaro IoT Sensoren Sensor Name RF-Technology Target Measurement / Purpose wMBus NB-IoT Gateway NB-IoT / LTE-M wMBus enabled meter reading wMBus LoRaWAN Bridge LoRaWAN wMBus enabled meter reading Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Tools Configuration / Setup Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices Background Knowledge Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Documentation Start"},{"location":"index.html#overview","text":"This site is the new upcoming central documentation for IoT products of Lobaro GmbH .","title":"Overview"},{"location":"index.html#hardware","text":"","title":"Hardware"},{"location":"index.html#lobaro-iot-sensoren","text":"Sensor Name RF-Technology Target Measurement / Purpose wMBus NB-IoT Gateway NB-IoT / LTE-M wMBus enabled meter reading wMBus LoRaWAN Bridge LoRaWAN wMBus enabled meter reading Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Lobaro IoT Sensoren"},{"location":"index.html#tools","text":"","title":"Tools"},{"location":"index.html#configuration-setup","text":"Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices","title":"Configuration / Setup"},{"location":"index.html#background-knowledge","text":"Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Background Knowledge"},{"location":"hardware.html","text":"Lobaro Hardware Variations Beside our standard products we may offer you a custom product variant matching your specific application. Most of our products are compatible with the following variations, for details about a specific product and pricing please contact us at sales@lobaro.de Housing Options Compact Lobaro Box Housing Product Dimensions (pdf) Size: 114,30mm (w) x 59,30mm (l) x 26,80mm (h) Waterproof: IP65 Spelsberg TG PC 1208-6-o Product Specifications (external link) Size: 122mm (w) x 82mm (l) x 55mm (h) Waterproof: IP67 DIN-Rail Housing All DIN-Rail housings that fit our hardware are possible. The DIN-Rail mount can also be used without any housing. We offer to deliver our hardware in the following housings: 130x130 (RK 4/12-L) Product Specifications (external link) Size: 130mm (w) x 130mm (l) x 75mm (h) Oder number: 3000005 110x110 (RK 4/07-L) Product Specifications (external link) Size: 110mm (w) x 110mm (l) x 90mm (h) Oder number: 3000092 Power Supply Options AA-Batteries (3Ah) Only for LoRaWAN products Only our LoRaWAN hardware supports two AA-Batteries inside the Lobaro Box Housing. We recommend to use Energizer Ultimate Lithium for our products. Size: AA-Cell Voltage: 1.5V Capacity: up to 3Ah Operating temperature: -40\u00b0C...+60\u00b0C ER34615 3.6V Battery (D-Cell, 19Ah) Size: D-Cell (34mm x 61.5mm) Connector: JST XH series Voltage: 3.6V Continuous Discharge Current: 200mA (max.) Capacity: up to 19Ah Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable) 230V External Supply (5VDC) Can be used standalone on an existing DIN-Rail or inside the DIN-Rail Housing (see above) Antennas By default all our products are shipped with an internal pcb-antenna. An external SMA antenna connector can be mounted on request to the housing. External antennas can be connected with a standard SMA RF-connector:","title":"Hardware Variations"},{"location":"hardware.html#lobaro-hardware-variations","text":"Beside our standard products we may offer you a custom product variant matching your specific application. Most of our products are compatible with the following variations, for details about a specific product and pricing please contact us at sales@lobaro.de","title":"Lobaro Hardware Variations"},{"location":"hardware.html#housing-options","text":"","title":"Housing Options"},{"location":"hardware.html#compact-lobaro-box-housing","text":"Product Dimensions (pdf) Size: 114,30mm (w) x 59,30mm (l) x 26,80mm (h) Waterproof: IP65","title":"Compact Lobaro Box Housing"},{"location":"hardware.html#spelsberg-tg-pc-1208-6-o","text":"Product Specifications (external link) Size: 122mm (w) x 82mm (l) x 55mm (h) Waterproof: IP67","title":"Spelsberg TG PC 1208-6-o"},{"location":"hardware.html#din-rail-housing","text":"All DIN-Rail housings that fit our hardware are possible. The DIN-Rail mount can also be used without any housing. We offer to deliver our hardware in the following housings: 130x130 (RK 4/12-L) Product Specifications (external link) Size: 130mm (w) x 130mm (l) x 75mm (h) Oder number: 3000005 110x110 (RK 4/07-L) Product Specifications (external link) Size: 110mm (w) x 110mm (l) x 90mm (h) Oder number: 3000092","title":"DIN-Rail Housing"},{"location":"hardware.html#power-supply-options","text":"","title":"Power Supply Options"},{"location":"hardware.html#aa-batteries-3ah","text":"Only for LoRaWAN products Only our LoRaWAN hardware supports two AA-Batteries inside the Lobaro Box Housing. We recommend to use Energizer Ultimate Lithium for our products. Size: AA-Cell Voltage: 1.5V Capacity: up to 3Ah Operating temperature: -40\u00b0C...+60\u00b0C","title":"AA-Batteries (3Ah)"},{"location":"hardware.html#er34615-36v-battery-d-cell-19ah","text":"Size: D-Cell (34mm x 61.5mm) Connector: JST XH series Voltage: 3.6V Continuous Discharge Current: 200mA (max.) Capacity: up to 19Ah Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable)","title":"ER34615 3.6V Battery (D-Cell, 19Ah)"},{"location":"hardware.html#230v-external-supply-5vdc","text":"Can be used standalone on an existing DIN-Rail or inside the DIN-Rail Housing (see above)","title":"230V External Supply (5VDC)"},{"location":"hardware.html#antennas","text":"By default all our products are shipped with an internal pcb-antenna. An external SMA antenna connector can be mounted on request to the housing. External antennas can be connected with a standard SMA RF-connector:","title":"Antennas"},{"location":"background/cron-expressions.html","text":"Cron Expressions We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0/15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed. Meaning of the six fields: 0 0/15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range (0-59) (0-59) (0-23) (1-31) (1-12) (1-7) Alternative JAN-DEC SUN-SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * / Examples Cron definition Description Trigger time point(s) (hh:mm:ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1/10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1,15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1-5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist. Special Characters: star, asterisk ( * ) Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\". question mark ( ? ) Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification. dash, minus ( - ) Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d. comma ( , ) Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d. slash ( / ) Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u201c\u2153\u201d in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d. Online CRON Generators and Tester: https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html Further Reading All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"CRON Expressions"},{"location":"background/cron-expressions.html#cron-expressions","text":"We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0/15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed.","title":"Cron Expressions"},{"location":"background/cron-expressions.html#meaning-of-the-six-fields","text":"0 0/15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range (0-59) (0-59) (0-23) (1-31) (1-12) (1-7) Alternative JAN-DEC SUN-SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * /","title":"Meaning of the six fields:"},{"location":"background/cron-expressions.html#examples","text":"Cron definition Description Trigger time point(s) (hh:mm:ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1/10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1,15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1-5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist.","title":"Examples"},{"location":"background/cron-expressions.html#special-characters","text":"","title":"Special Characters:"},{"location":"background/cron-expressions.html#star-asterisk","text":"Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\".","title":"star, asterisk (*)"},{"location":"background/cron-expressions.html#question-mark","text":"Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification.","title":"question mark (?)"},{"location":"background/cron-expressions.html#dash-minus-","text":"Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d.","title":"dash, minus (-)"},{"location":"background/cron-expressions.html#comma","text":"Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d.","title":"comma (,)"},{"location":"background/cron-expressions.html#slash","text":"Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u201c\u2153\u201d in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d.","title":"slash (/)"},{"location":"background/cron-expressions.html#online-cron-generators-and-tester","text":"https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html","title":"Online CRON Generators and Tester:"},{"location":"background/cron-expressions.html#further-reading","text":"All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"Further Reading"},{"location":"background/lorawan.html","text":"LoRaWAN Introduction to LoRaWAN LoRaWAN stands for Lo ng Ra nge W ide A rea N etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented, LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. Transmissions using LoRaWAN can travel distances of several kilometers and are very good at penetrating obstacles like walls. Communication using LoRaWAN does also require very little power, so you can achieve long lifetimes for battery powered devices. The trade off is a very limited data rate which makes it unusable for some use cases. For many IoT applications this is not really a limitation. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network . They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN) LoRa LoRa is the modulation used in LoRaWAN. It's patented by Semtech. To calculate LoRa specific parameters like transmit time you can use the SX1272 LoRa Calculator from Semtech. Gateways All LoRaWAN devices connect to a LoRaWAN Network via Gateways. Those are stationary devices that collect LoRaWAN messages from the air and forward them over the Internet to the LoRaWAN Network. You need at least one Gateway to operate a LoRaWAN device; you can either set it up yourself or use infrastructure provided by others. Lobaro does not manufacture Gateways, but we can advice you and help you acquire them, if you need support. Network Server The Network Server is the part of a LoRaWAN Network that coordinates Sensors and Gateways and lets you access the data your devices are uploading. There exists a free to use Network Server named The Things Network (TTN), which is a good place to start using LoRaWAN. There are even a lot of publicly available Gateways in the world that connect to TTN which you can use with your devices. Depending on your location their might also be commercial LoRaWAN Networks available that you can use. Lobaro does not develop its own Network Server, but we can connect LoRaWAN devices to our backend via a Network Server we are operating, via TTN, or via any other LoRaWAN provider that supplies an API that we can connect to. Uplinks and Downlinks Messages sent by a LoRaWAN device to the Network are called Uplink , messages sent from the Network to the device are called Downlinks . For normal LoRaWAN use cases Uplinks are sent much more often then Downlinks. A Gateways is limited in the number of Downlinks it may send over time, so Network Providers tend to charge fees for Downlinks. The situation on which Downlinks can be sent to a device are very limited. LoRaWAN has three different Operation Modes: Class A, Class B, and Class C. Devices running in the most common Operation Mode, Class A, can only receive a Downlink Message directly after they send an Uplink. This makes it possible for LoRaWAN devices to operate on very little power, because they spend most of their time in a sleeping state. As a consequence every Downlink you send to your devices will be buffered until it sends an Uplink and only then the Downlink will be transmitted. Depending on the device and it's configuration, this can take hours or days. Operation Mode Class C gives a solution to this problem. A device operating in Class C is listening for Downlinks whenever possible, thus it is (almost) always reachable by the network. This permanent receiving prevents the device from going into a sleep mode, so devices running in Class C will consume much more power. It is not advisable to run battery powered devices in Class C. All LoRaWAN devices support Class A. Some Lobaro devices can be changed to run in Class C by configuration. Class B is not supported by Lobaro devices at the moment. Further Information TTN provide a good LoRaWAN Documentation The Official LoRaWAN Specification is developed and provided by the LoRa Alliance. Lobaro LoRaWAN stack Lobaro's LoRaWAN devices use a LoRaWAN stack we develop ourselves. It supports a wide spectrum of features: LoRaWAN version 1.1 and 1.0 supported Over The Air Activation (OTAA) and Activation By Personalisation (ABP) Adaptive Data Rate (ADR) Device integrated DevEUI (alternatively DevEUI can be freely configured) AES encryption LoRaWAN operation modes Class A and Class C Time synchronisation over LoRaWAN Remote configuration over LoRaWAN Remote device rebooting Automated reconnection on network loss Random delays to avoid collisions with other devices Some devices implement only a subset of those features. LoRaWAN versions The most recent version of LoRaWAN is 1.1. Some Network Servers support only version 1.0. The configuration for the two versions is slightly different: Version 1.1 has two Keys: The Network Key NwkKey and the Application Key AppKey . Version 1.0 only uses the Application Key. Lobaro's LoRaWAN devices support both versions. If both keys, NwkKey and AppKey are set, the device uses version 1.1. If NwkKey is set to all zeros, the device uses version 1.0 instead. If both keys are set to the same value, the device tries to use version 1.1 but falls back to 1.0 if the Network Server does not support 1.1. The initial configuration for Lobaro's LoRaWAN devices has both keys set to the same value, so that they can be used with both LoRaWAN versions out of the box. Each device has an individual key, but the value is known to Lobaro. For security reasons the keys should be changed to a random value generated from a strong random source. LoRaWAN Configuration The configuration of the LoRaWAN parameters is basically the same for all LoRaWAN devices (some of our products might differ in some details, especially devices using older firmware that do not yet support LoRaWAN 1.1). Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot OTAA A LoRaWAN device needs to be activated to communicate with a network. The activation generates a session that is used by the device and most importantly sets the encryption keys used for communication during the session's lifetime. There are two ways to handle the activation. One is Activation Over The Air (OTAA), which uses shared secrets to create new session keys when the device connects to the Network (join). The other is Activation By Personalisation (ABP), where the session keys have to be communicated between the device and the Network Server previously on a channel outside of the LoRaWAN spec. We recommend to use OTAA whenever possible, as it creates new keys on each join procedure, making it harder to break the encryption. If you need to use ABP despite this, please referre to using ABP for an explanation of how to get the keys needed. DevEUI The DevEUI is an 8 byte value that identifies the device globally. Lobaro LoRaWAN devices contain a unique DevEUI officially purchased from a distributor. If you need to use a different DevEUI for some reason you can change it to any value you like. The original DevEUI will remain in the device and can be restored by resetting the configuration to default. It is also displayed as a log message when booting the device. The DevEUI identifies a device in the Network Server when you are using OTAA. JoinEUI The JoinEui is an 8 byte value that is needed during OTAA join. It often provided as a random value by the Network server. In LoRaWAN 1.0 this was called AppEUI and had a slightly different function. The AppEui for LoRaWAN 1.0 is often provided by the Network Server. If you are using 1.0 set the AppEui here. AppKey , NwkKey The Application Key and the Network Key are used as shared secrets during OTAA to generate the session keys. They need to be synchronised between the device and the Network Server. LoRaWAN 1.0 only uses the AppKey and not the NwkKey. Setting the NwkKey to 00000000000000000000000000000000 will set the device to use LoRaWAN 1.0. If you set NwkKey and AppKey to the same value, the device will try to run LoRaWAN 1.1 but fall back to 1.0 if the Network Server does not support 1.1. SF The Spreading Factor is a LoRa parameter that defines how much time is used to transmit a single byte. A higher Spreading Factor results in a better reception of the transmission, but it has a severe impact on the amount of data a device can send and on battery consumption. See Spreading Factor for more details. This Parameter sets the Spreading Factor the device starts with after Activation. If the device uses ADR, the Spreading Factor can change over time, but it will never be higher than the value configured here. ADR Adaptive Data Rate (ADR) allows the Network Server to adjust the Spreading Factor and TxPower of this device. This feature helps the Network to organise itself when multiple devices and multiple gateways are in one area. It also helps the device to reduce power consumption, as the Network Server can reduce the power used by the device for transmission. ADR works best with devices that are stationary or move only rarely. A highly mobile device will often experience sudden reductions in connectivity. This can lead to packet loss when the Data Rate is configured to be as low as possible. OpMode LoRaWAN devices can operate in different modes. The most common Operation Mode is Class A . In this Mode the device only listens for downlink messages for a short period after it sent an uplink message to the network. Those devices can only be reached when they contact the network. This is the preferred Operation Mode for battery powered device, because it allows the device to spend most of its time in a deep sleep state that consumes only minimal power. The other Operation Mode supported by Lobaro is Class C . Devices in this modus listen for downlink messages whenever possible. This allows the Network to contact the device at almost any time without waiting for an incoming uplink. This Operation Mode consumes much more power and is not recommended for battery powered devices! TimeSync When the device is connected to power it does not know what the time and sets its internal clock to 2010-01-01T00:00:00. For many use cases it is necessary that the device's clock is set to the correct time (for example if the device needs to activate at a specific point in time). LoRaWAN supports synchronising time over the air. When TimeSync is set to a number > 0 the device synchronises time on activation and then again and again after that number of days have passed. A regular synchronisation is useful, because the devices clock has a limited precision and might drift several seconds per month. Not all Network Servers support time synchronisation. Some Network Servers will silently drop any message that requests a time synchronisation. This can result in packet loss. If your Network Server has this limitation, make sure you deactivate this feature. When using multiple time synchronised devices around the same Gateway you should use RndDelay to avoid collisions. RndDelay When multiple devices try to transmit at the same time they interfere with each other leading to packet loss. Because the devices wake up on a specific time those collisions can repeat for each operation cycle. An effective feature to avoid repeating collisions is adding a random delay before transmission. RndDelay specifies a maximal number of seconds that is randomly waited before the device starts uploading its data. The delay is performed after taking measurements but before uploading, so that the measurements take place at a well defined time. RemoteConf Our devices support changing the configuration over the air via LoRaWAN downlinks. This can be a very convenient feature for devices that are difficult to get physical access to. For security reasons this feature can be deactivated using this configuration parameter. See Remote Configuration for more information. LostReboot This feature allows the device to detect a disconnection from the Network and to reboot in that case. If the device does not receive any downlinks for the specified number of days it reboots itself in order to rejoin the network. This only makes sense for devices using OTAA, as ABP devices do not start a new session on boot. In combination with TimeSync you can ensure downlinks on a regular basis to test connection. This feature makes it possible to move an OTAA using device from one Network to another without the need to restart it manually through physical access. Using ABP We recommend using OTAA for the activation of your devices, as it is more flexible and more secure. Still there are cases were you need to use ABP. Our devices support ABP (Activation By Personalisation). To use it, you need to set the configuration parameter OTAA to false . The required parameters for ABP will be created by the device. You can see them in the log after boot. The amount of keys used for ABP differ between LoRaWAN Versions 1.0 and 1.1, so, depending on which version you set the device to use, the output will differ: Example for LoRaWAN v1.0: LoRa| LoRaWAN config LoRa| using LoRaWAN v1.0, ABP LoRa| configuration derived from DevAddr, AppKey LoRa| DevAddr: 0014331e (last 4 bytes of DevEUI) LoRa| NetSKey: 02ce3eb181b2eea2cb02e8a6d237b07b LoRa| AppSKey: e8566e3fb69d65067bf51846eff1271a Example for LoRaWAN v1.1: LoRa| LoRaWAN config LoRa| using LoRaWAN v1.1, ABP LoRa| configuration derived from DevAddr, NwkKey, AppKey LoRa| DevAddr: 0014331e (last 4 bytes of DevEUI) LoRa| change AppKey and NwkKey to generate different Keys LoRa| NwkSEncKey: 12bf6aac2faba7b74160d1223eb44fd1 LoRa| SNwkSIntKey: 0f4edac1f38b2a52389c4dd42fa65330 LoRa| FNwkSIntKey: db264cf386c242caba4f842cb014947b LoRa| AppSKey: 3256663fb79d65067bf51646eff0271a You can copy the device address and session keys from the log and put them into your Network Server's configuration. The device address is generated using the last 4 bytes of the DevEUI, so if you want to change the Address you will have to change the DevEUI in the configuration. The Session Keys are derived from the OTAA keys in the configuration, so if you want to generate different session keys, you should set the AppKey (for v1.0) or the AppKey and NwkKey (for v1.1) to a randomly generated value. Duty Cycle Because LoRaWAN uses public frequencies, there are some regulations LoRaWAN device must comply to. Radio transmissions are subject to local legislation; the information in this chapter are referring to EU regulations. Other areas have similar regulations but they will differ in detail. Devices that use public frequencies must respect a duty cycle for transmissions: a device must not transmit more than 1% of the time on a certain band. So after 1 second of transmission the device must not use that band for at least 99 seconds. So if a device has a lot of data to upload, it will be forced into waiting after the first few uploads. Our devices will go to a very power effective sleep mode when they are forced to wait. When using LoRa modulation, the Spreading Factor used has a severe impact how much data can be uploaded in a fixed amount of time. See next chapter Spreading Factor for more details. Spreading Factor The Spreading Factor (SF) is a parameter of LoRa ranging from 7 to 12, that defines how much transmission time is used to transmit a single byte. Using a higher spreading factor results in a higher possibility to get a message transmitted successfully. The trade off is, that it takes a longer time to transmit, which leads to a higher power consumption, more collisions between devices, and much smaller data throughput for the device because of the duty cycle . Increasing the spreading factor by one doubles the amount of time it takes to transmit data and therefore halves the amount of data that can be transmitted. A higher spreading factor also leads to a stricter size limitation for messages. On SF 7 a single message can carry a payload of up to 222 bytes, on SF 12 only 51 bytes are allowed. It is therefore advisable to use the lowest possible spreading factor for your devises. Tuning this by hand is a difficult task, but there is a mechanism called Adaptive Data Rate (ADR) that does this for you. Enabling ADR in your device allows the Network Server to change the Spreading Factor of your device according to the reception quality. The SF will never be set higher than the starting value you configure in your device. Most of our devices are configured to use ADR and to start at a SF of 12. This gives the Network Server full flexibility in organising all attached devices and should result in the optimal configuration. It gives the network the ability to adapt to changes, like an increase of the number of deployed devices, or to the installation of additional gateways (or a gateway stopping to work). Timestamp Many of our devices include timestamps somewhere in their payloads. The encoding of timestamps in our payload is the same in all our LoRaWAN devices except some of our oldest. There are some details you should be aware of. Format: Points in time are represented as UNIX-timestamps within our products. That is a integer value indicating the number of seconds that have passed since 0:00h on January 1 1970 in UTC. Encoding: We encode the UNIX-timestamp in a signed 40 bit big endian integer ( int40 , 5 bytes long). The 40 bit integer is unconventional but used with good reasoning. UNIX-timestamps have traditionally been stored as signed 32 bit integers ( int32 ). This poses the problem that points in time later than January 2038 cannot be expressed . A simple solution to this is switching to store timestamps in singed 64 bit integers. This is a suitable solution for modern computers and our devices do that internally for calculations. The problem is that 64 bit integers take 8 bytes of space, and with LoRaWAN every byte is precious. 3 of those 8 bytes will be zeros for thousands of years to come, so we chose to increase the size of our timestamps by only a single byte to 40 bit. This lets us store timestamps up unto the year 19391, which we dare say is enough. Storing numerical values with a number of bits that is not a power of 2 might be unusual, but there is nothing wrong with it. If you have problems decoding 40 bit values you can find an example implementation in JavaScript below in our example TTN parser. Device's internal clock: The timestamp uploaded by the devices is always referring to the device's internal clock. That clock is not always in sync with actual time. In fact when you power up the device it has no way to know what time it is. It sets the internal clock to 2010-01-01T00:00:00 . For many applications this is not a problem! If you set the device's cron to execute at 0h, 6h, 12h, and 18h it will activate every 6 hours at the same times every day. But when exactly the device is activated depends on the the time it was first powered on. If you require your device to run in sync with actual time you can set its clock using the configuration adapter and the Lobaro Tool. LoRaWAN 1.1 also introduced time synchronization over the air which is supported by some of our devices. You will need to use a LoRaWAN Network Server that also supports this feature. Remote Configuration IoT devices are often installed at places that are difficult to reach. If you need to change the settings of such a device it is often not easily possible to get physical access to attach a config adapter. Many of our devices support Remote Configuration that allows you to change the configuration of the device by sending Downlink messages via LoRaWAN. The Remote Configuration must be enabled in the device by setting the parameter RemoteConf to true . If this is set to false , none of the remote commands described here will work, and you can only activate it with physical access to the device. This is meant as a security feature if you want to make sure that your device will not be controlled over the network. If you are using Remote Configuration, please be aware that LoRaWAN devices can only be reached by the network under certain conditions. See Uplinks and Downlinks . Lobaro LoRaWAN devices receive remote configuration commands as Downlinks on port 128. Responses to those commands will be sent as Uplinks on port 128 (and 129-131 for long responses). The remote commands and their responses are all encoded in ASCII, to make it easier for humans to use them. The first byte of a Downlink message on port 128 contains a single character that identifies the command you want to send. Some commands take a parameter following the command char. The responses to a command start with the same character as the command followed by an optional parameter. If a command is unknown or it fails for some reason, an error response is sent via Uplink that contains with a ! followed by a readable error message. Changing configuration does nothing until you save the changes and reboot the device. The device has a safety feature that prevents configurations that make the device unusable. A new configuration is tested in the first run after rebooting. Only after the device reaches a stable state will the configuration be adopted and used permanently. If a problem occurs the device will restore its last stable connection and reboot. If the device uses OTAA (which we recommend) the device will only adopt the new configuration only after a join request is accepted, to make sure the LoRaWAN parameters are correct. After a few failed attempts it will restore the previous configuration. This can take up to about 10 minutes. Char Command Parameter Hex ? Request firmware and version None 3F g Get config parameter value Name of parameter 67 r Reset config parameter value Name of parameter 72 s Set config parameter value <name>=<value> 73 a Append to config parameter value <name>=<value> 61 b Reboot device without saving None 62 w Save config and reboot device None 77 ? Request firmware and version. This command triggers the device to send what firmware it is running and in which version. This can be used to test if the remote configuration is working. g<name> Get the value of the config parameter <name> . This command makes the device sent a response containing <name>=<value> as parameter giving you the current value of a configuration parameter. r<name> / r* Reset config parameter <name> to its default value. As a confirmation the device sends a response containing <name>=<value> , reporting the new value of the parameter. Sending the special value * will reset all config parameters. s<name>=<value> Set config parameter <name> to <value> . Sets the parameter to the value given in the parameter. As a confirmation it sends a response containing <name>=<value> , reporting the new value of the parameter. a<name>=<value> Append <value> to the config parameter <name> . This command appends the value given to the current value of the parameter. This is intended to allow setting values that are too long for a single Downlink message. As a confirmation it sends the length of the config parameter's value after the appending. Append works for config paramters of type string . b Reboot device without saving. This command restarts the device. Any changes too the config that have been committed before will be lost! This command does not send a Response. w / wFORCE Save config and reboot device. This command saves all configuration changes to a temporarily configuration and restarts the device. Only if the device boots successfully and reaches normal operation mode is the new configuration made permanent. If any fatal configuration error occurs or if the LoRaWAN OTAA Join does not succeed, the previous configuration will be restored and the device restarted again. This command does not send a Response. If you add the special argument FORCE to the command, the configuration will be made permanent without testing the configuration. Using wFORCE can leave your device useless and unreachable! Do not use wFORCE unless you have a very good reason. If the device is set to an invalid configuration it will no longer be reachable by the Network Server. From such a state it can only be recovered with physical access and a config adapter. It will also most likely drain the battery quickly. Example: changing configuration The following is a short example of how you can update two configuration values remotely (that includes rebooting the device). Most LoRaWAN devices (all that are running in Class A, which are by fast the most) can only be reached when they contact the network. Network Servers (like The Things Network) provide a mechanism to enqueue messages for a specific device. The messages will be sent as downlink the next time that device contacts the network. Normally, multiple messages can be enqueued and will all be transmitted as soon as possible. Please be advised that the gateways communicating with your device must respect their duty cycle, so there is a very limited amount of downlinks that can be sent for a given time (downlinks are expensive). For this example we want to set Time Synchronisation to sync the internal clock every 10 days, and we want to deactivate Adaptive Date Rate (ADR). These are both LoRaWAN configuration parameters that are present on most devices (find details under LoRaWAN Configuration ), but you can of course also change parameters specific to your device, e.g. Modbus configuration or wMBus configuration, with this feature. We will need to send three commands: sTimeSync=10 \u2013 set time synchronisation to 10 day interval sADR=false \u2013 disable adaptive data rate w \u2013 write changes to device configuration and reboot The s -commands will of course differ for your case, but the w command at the end will be the same. After sending the final command, the device will reboot and try the new configuration. If the boot process and the connection to the network are successful, the device will make the changes permanent. If there is a problem (if you accidentally set an invalid value, e.g. sADR=flase or if you changed your AppKey to wrong value and your OTAA fails), the device will revert to the previous configuration. Downlinks on TTN How you sent your downlinks depends on the LoRaWAN Network Server you use to connect your devices. You will most likely need to convert the commands (that are all ASCII) to some different representation, e.g. Hex or Base64. In The Things Network you find the downlink panel on the \"Device Overview\" page for each device, directly below the panel that shows you OTAA/ABP information (DevEUI, AppKey, ...). It is shown in the following screenshot: You will have to encode the commands in hex. In the screenshot you see 73 54 69 6d 65 53 79 6e 63 3d 31 30 as the message to send; that is the hex representation of sTimeSync=10 . The Port used for remote configuration for our devices is 128. When you enter multiple messages to send, be sure to set the correct scheduling ( last ). The preselected replace will overwrite your previously enqueued messages. Parser LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 , 40 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } // float32([62, 132, 168, 155]) = 0.305068 function float32 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); bytes = int32_BE ( bytes , 0 ) var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ // Decoder function for TTN function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io // Uncomment only when used in niota! /* module.exports = function (payload, meta) { const port = meta.lora.fport; const buf = Buffer.from(payload, 'hex'); return Decoder(buf, port); }*/","title":"LoRaWAN"},{"location":"background/lorawan.html#lorawan","text":"","title":"LoRaWAN"},{"location":"background/lorawan.html#introduction-to-lorawan","text":"LoRaWAN stands for Lo ng Ra nge W ide A rea N etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented, LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. Transmissions using LoRaWAN can travel distances of several kilometers and are very good at penetrating obstacles like walls. Communication using LoRaWAN does also require very little power, so you can achieve long lifetimes for battery powered devices. The trade off is a very limited data rate which makes it unusable for some use cases. For many IoT applications this is not really a limitation. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network . They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN)","title":"Introduction to LoRaWAN"},{"location":"background/lorawan.html#lora","text":"LoRa is the modulation used in LoRaWAN. It's patented by Semtech. To calculate LoRa specific parameters like transmit time you can use the SX1272 LoRa Calculator from Semtech.","title":"LoRa"},{"location":"background/lorawan.html#gateways","text":"All LoRaWAN devices connect to a LoRaWAN Network via Gateways. Those are stationary devices that collect LoRaWAN messages from the air and forward them over the Internet to the LoRaWAN Network. You need at least one Gateway to operate a LoRaWAN device; you can either set it up yourself or use infrastructure provided by others. Lobaro does not manufacture Gateways, but we can advice you and help you acquire them, if you need support.","title":"Gateways"},{"location":"background/lorawan.html#network-server","text":"The Network Server is the part of a LoRaWAN Network that coordinates Sensors and Gateways and lets you access the data your devices are uploading. There exists a free to use Network Server named The Things Network (TTN), which is a good place to start using LoRaWAN. There are even a lot of publicly available Gateways in the world that connect to TTN which you can use with your devices. Depending on your location their might also be commercial LoRaWAN Networks available that you can use. Lobaro does not develop its own Network Server, but we can connect LoRaWAN devices to our backend via a Network Server we are operating, via TTN, or via any other LoRaWAN provider that supplies an API that we can connect to.","title":"Network Server"},{"location":"background/lorawan.html#uplinks-and-downlinks","text":"Messages sent by a LoRaWAN device to the Network are called Uplink , messages sent from the Network to the device are called Downlinks . For normal LoRaWAN use cases Uplinks are sent much more often then Downlinks. A Gateways is limited in the number of Downlinks it may send over time, so Network Providers tend to charge fees for Downlinks. The situation on which Downlinks can be sent to a device are very limited. LoRaWAN has three different Operation Modes: Class A, Class B, and Class C. Devices running in the most common Operation Mode, Class A, can only receive a Downlink Message directly after they send an Uplink. This makes it possible for LoRaWAN devices to operate on very little power, because they spend most of their time in a sleeping state. As a consequence every Downlink you send to your devices will be buffered until it sends an Uplink and only then the Downlink will be transmitted. Depending on the device and it's configuration, this can take hours or days. Operation Mode Class C gives a solution to this problem. A device operating in Class C is listening for Downlinks whenever possible, thus it is (almost) always reachable by the network. This permanent receiving prevents the device from going into a sleep mode, so devices running in Class C will consume much more power. It is not advisable to run battery powered devices in Class C. All LoRaWAN devices support Class A. Some Lobaro devices can be changed to run in Class C by configuration. Class B is not supported by Lobaro devices at the moment.","title":"Uplinks and Downlinks"},{"location":"background/lorawan.html#further-information","text":"TTN provide a good LoRaWAN Documentation The Official LoRaWAN Specification is developed and provided by the LoRa Alliance.","title":"Further Information"},{"location":"background/lorawan.html#lobaro-lorawan-stack","text":"Lobaro's LoRaWAN devices use a LoRaWAN stack we develop ourselves. It supports a wide spectrum of features: LoRaWAN version 1.1 and 1.0 supported Over The Air Activation (OTAA) and Activation By Personalisation (ABP) Adaptive Data Rate (ADR) Device integrated DevEUI (alternatively DevEUI can be freely configured) AES encryption LoRaWAN operation modes Class A and Class C Time synchronisation over LoRaWAN Remote configuration over LoRaWAN Remote device rebooting Automated reconnection on network loss Random delays to avoid collisions with other devices Some devices implement only a subset of those features.","title":"Lobaro LoRaWAN stack"},{"location":"background/lorawan.html#lorawan-versions","text":"The most recent version of LoRaWAN is 1.1. Some Network Servers support only version 1.0. The configuration for the two versions is slightly different: Version 1.1 has two Keys: The Network Key NwkKey and the Application Key AppKey . Version 1.0 only uses the Application Key. Lobaro's LoRaWAN devices support both versions. If both keys, NwkKey and AppKey are set, the device uses version 1.1. If NwkKey is set to all zeros, the device uses version 1.0 instead. If both keys are set to the same value, the device tries to use version 1.1 but falls back to 1.0 if the Network Server does not support 1.1. The initial configuration for Lobaro's LoRaWAN devices has both keys set to the same value, so that they can be used with both LoRaWAN versions out of the box. Each device has an individual key, but the value is known to Lobaro. For security reasons the keys should be changed to a random value generated from a strong random source.","title":"LoRaWAN versions"},{"location":"background/lorawan.html#lorawan-configuration","text":"The configuration of the LoRaWAN parameters is basically the same for all LoRaWAN devices (some of our products might differ in some details, especially devices using older firmware that do not yet support LoRaWAN 1.1). Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot OTAA A LoRaWAN device needs to be activated to communicate with a network. The activation generates a session that is used by the device and most importantly sets the encryption keys used for communication during the session's lifetime. There are two ways to handle the activation. One is Activation Over The Air (OTAA), which uses shared secrets to create new session keys when the device connects to the Network (join). The other is Activation By Personalisation (ABP), where the session keys have to be communicated between the device and the Network Server previously on a channel outside of the LoRaWAN spec. We recommend to use OTAA whenever possible, as it creates new keys on each join procedure, making it harder to break the encryption. If you need to use ABP despite this, please referre to using ABP for an explanation of how to get the keys needed. DevEUI The DevEUI is an 8 byte value that identifies the device globally. Lobaro LoRaWAN devices contain a unique DevEUI officially purchased from a distributor. If you need to use a different DevEUI for some reason you can change it to any value you like. The original DevEUI will remain in the device and can be restored by resetting the configuration to default. It is also displayed as a log message when booting the device. The DevEUI identifies a device in the Network Server when you are using OTAA. JoinEUI The JoinEui is an 8 byte value that is needed during OTAA join. It often provided as a random value by the Network server. In LoRaWAN 1.0 this was called AppEUI and had a slightly different function. The AppEui for LoRaWAN 1.0 is often provided by the Network Server. If you are using 1.0 set the AppEui here. AppKey , NwkKey The Application Key and the Network Key are used as shared secrets during OTAA to generate the session keys. They need to be synchronised between the device and the Network Server. LoRaWAN 1.0 only uses the AppKey and not the NwkKey. Setting the NwkKey to 00000000000000000000000000000000 will set the device to use LoRaWAN 1.0. If you set NwkKey and AppKey to the same value, the device will try to run LoRaWAN 1.1 but fall back to 1.0 if the Network Server does not support 1.1. SF The Spreading Factor is a LoRa parameter that defines how much time is used to transmit a single byte. A higher Spreading Factor results in a better reception of the transmission, but it has a severe impact on the amount of data a device can send and on battery consumption. See Spreading Factor for more details. This Parameter sets the Spreading Factor the device starts with after Activation. If the device uses ADR, the Spreading Factor can change over time, but it will never be higher than the value configured here. ADR Adaptive Data Rate (ADR) allows the Network Server to adjust the Spreading Factor and TxPower of this device. This feature helps the Network to organise itself when multiple devices and multiple gateways are in one area. It also helps the device to reduce power consumption, as the Network Server can reduce the power used by the device for transmission. ADR works best with devices that are stationary or move only rarely. A highly mobile device will often experience sudden reductions in connectivity. This can lead to packet loss when the Data Rate is configured to be as low as possible. OpMode LoRaWAN devices can operate in different modes. The most common Operation Mode is Class A . In this Mode the device only listens for downlink messages for a short period after it sent an uplink message to the network. Those devices can only be reached when they contact the network. This is the preferred Operation Mode for battery powered device, because it allows the device to spend most of its time in a deep sleep state that consumes only minimal power. The other Operation Mode supported by Lobaro is Class C . Devices in this modus listen for downlink messages whenever possible. This allows the Network to contact the device at almost any time without waiting for an incoming uplink. This Operation Mode consumes much more power and is not recommended for battery powered devices! TimeSync When the device is connected to power it does not know what the time and sets its internal clock to 2010-01-01T00:00:00. For many use cases it is necessary that the device's clock is set to the correct time (for example if the device needs to activate at a specific point in time). LoRaWAN supports synchronising time over the air. When TimeSync is set to a number > 0 the device synchronises time on activation and then again and again after that number of days have passed. A regular synchronisation is useful, because the devices clock has a limited precision and might drift several seconds per month. Not all Network Servers support time synchronisation. Some Network Servers will silently drop any message that requests a time synchronisation. This can result in packet loss. If your Network Server has this limitation, make sure you deactivate this feature. When using multiple time synchronised devices around the same Gateway you should use RndDelay to avoid collisions. RndDelay When multiple devices try to transmit at the same time they interfere with each other leading to packet loss. Because the devices wake up on a specific time those collisions can repeat for each operation cycle. An effective feature to avoid repeating collisions is adding a random delay before transmission. RndDelay specifies a maximal number of seconds that is randomly waited before the device starts uploading its data. The delay is performed after taking measurements but before uploading, so that the measurements take place at a well defined time. RemoteConf Our devices support changing the configuration over the air via LoRaWAN downlinks. This can be a very convenient feature for devices that are difficult to get physical access to. For security reasons this feature can be deactivated using this configuration parameter. See Remote Configuration for more information. LostReboot This feature allows the device to detect a disconnection from the Network and to reboot in that case. If the device does not receive any downlinks for the specified number of days it reboots itself in order to rejoin the network. This only makes sense for devices using OTAA, as ABP devices do not start a new session on boot. In combination with TimeSync you can ensure downlinks on a regular basis to test connection. This feature makes it possible to move an OTAA using device from one Network to another without the need to restart it manually through physical access.","title":"LoRaWAN Configuration"},{"location":"background/lorawan.html#using-abp","text":"We recommend using OTAA for the activation of your devices, as it is more flexible and more secure. Still there are cases were you need to use ABP. Our devices support ABP (Activation By Personalisation). To use it, you need to set the configuration parameter OTAA to false . The required parameters for ABP will be created by the device. You can see them in the log after boot. The amount of keys used for ABP differ between LoRaWAN Versions 1.0 and 1.1, so, depending on which version you set the device to use, the output will differ: Example for LoRaWAN v1.0: LoRa| LoRaWAN config LoRa| using LoRaWAN v1.0, ABP LoRa| configuration derived from DevAddr, AppKey LoRa| DevAddr: 0014331e (last 4 bytes of DevEUI) LoRa| NetSKey: 02ce3eb181b2eea2cb02e8a6d237b07b LoRa| AppSKey: e8566e3fb69d65067bf51846eff1271a Example for LoRaWAN v1.1: LoRa| LoRaWAN config LoRa| using LoRaWAN v1.1, ABP LoRa| configuration derived from DevAddr, NwkKey, AppKey LoRa| DevAddr: 0014331e (last 4 bytes of DevEUI) LoRa| change AppKey and NwkKey to generate different Keys LoRa| NwkSEncKey: 12bf6aac2faba7b74160d1223eb44fd1 LoRa| SNwkSIntKey: 0f4edac1f38b2a52389c4dd42fa65330 LoRa| FNwkSIntKey: db264cf386c242caba4f842cb014947b LoRa| AppSKey: 3256663fb79d65067bf51646eff0271a You can copy the device address and session keys from the log and put them into your Network Server's configuration. The device address is generated using the last 4 bytes of the DevEUI, so if you want to change the Address you will have to change the DevEUI in the configuration. The Session Keys are derived from the OTAA keys in the configuration, so if you want to generate different session keys, you should set the AppKey (for v1.0) or the AppKey and NwkKey (for v1.1) to a randomly generated value.","title":"Using ABP"},{"location":"background/lorawan.html#duty-cycle","text":"Because LoRaWAN uses public frequencies, there are some regulations LoRaWAN device must comply to. Radio transmissions are subject to local legislation; the information in this chapter are referring to EU regulations. Other areas have similar regulations but they will differ in detail. Devices that use public frequencies must respect a duty cycle for transmissions: a device must not transmit more than 1% of the time on a certain band. So after 1 second of transmission the device must not use that band for at least 99 seconds. So if a device has a lot of data to upload, it will be forced into waiting after the first few uploads. Our devices will go to a very power effective sleep mode when they are forced to wait. When using LoRa modulation, the Spreading Factor used has a severe impact how much data can be uploaded in a fixed amount of time. See next chapter Spreading Factor for more details.","title":"Duty Cycle"},{"location":"background/lorawan.html#spreading-factor","text":"The Spreading Factor (SF) is a parameter of LoRa ranging from 7 to 12, that defines how much transmission time is used to transmit a single byte. Using a higher spreading factor results in a higher possibility to get a message transmitted successfully. The trade off is, that it takes a longer time to transmit, which leads to a higher power consumption, more collisions between devices, and much smaller data throughput for the device because of the duty cycle . Increasing the spreading factor by one doubles the amount of time it takes to transmit data and therefore halves the amount of data that can be transmitted. A higher spreading factor also leads to a stricter size limitation for messages. On SF 7 a single message can carry a payload of up to 222 bytes, on SF 12 only 51 bytes are allowed. It is therefore advisable to use the lowest possible spreading factor for your devises. Tuning this by hand is a difficult task, but there is a mechanism called Adaptive Data Rate (ADR) that does this for you. Enabling ADR in your device allows the Network Server to change the Spreading Factor of your device according to the reception quality. The SF will never be set higher than the starting value you configure in your device. Most of our devices are configured to use ADR and to start at a SF of 12. This gives the Network Server full flexibility in organising all attached devices and should result in the optimal configuration. It gives the network the ability to adapt to changes, like an increase of the number of deployed devices, or to the installation of additional gateways (or a gateway stopping to work).","title":"Spreading Factor"},{"location":"background/lorawan.html#timestamp","text":"Many of our devices include timestamps somewhere in their payloads. The encoding of timestamps in our payload is the same in all our LoRaWAN devices except some of our oldest. There are some details you should be aware of. Format: Points in time are represented as UNIX-timestamps within our products. That is a integer value indicating the number of seconds that have passed since 0:00h on January 1 1970 in UTC. Encoding: We encode the UNIX-timestamp in a signed 40 bit big endian integer ( int40 , 5 bytes long). The 40 bit integer is unconventional but used with good reasoning. UNIX-timestamps have traditionally been stored as signed 32 bit integers ( int32 ). This poses the problem that points in time later than January 2038 cannot be expressed . A simple solution to this is switching to store timestamps in singed 64 bit integers. This is a suitable solution for modern computers and our devices do that internally for calculations. The problem is that 64 bit integers take 8 bytes of space, and with LoRaWAN every byte is precious. 3 of those 8 bytes will be zeros for thousands of years to come, so we chose to increase the size of our timestamps by only a single byte to 40 bit. This lets us store timestamps up unto the year 19391, which we dare say is enough. Storing numerical values with a number of bits that is not a power of 2 might be unusual, but there is nothing wrong with it. If you have problems decoding 40 bit values you can find an example implementation in JavaScript below in our example TTN parser. Device's internal clock: The timestamp uploaded by the devices is always referring to the device's internal clock. That clock is not always in sync with actual time. In fact when you power up the device it has no way to know what time it is. It sets the internal clock to 2010-01-01T00:00:00 . For many applications this is not a problem! If you set the device's cron to execute at 0h, 6h, 12h, and 18h it will activate every 6 hours at the same times every day. But when exactly the device is activated depends on the the time it was first powered on. If you require your device to run in sync with actual time you can set its clock using the configuration adapter and the Lobaro Tool. LoRaWAN 1.1 also introduced time synchronization over the air which is supported by some of our devices. You will need to use a LoRaWAN Network Server that also supports this feature.","title":"Timestamp"},{"location":"background/lorawan.html#remote-configuration","text":"IoT devices are often installed at places that are difficult to reach. If you need to change the settings of such a device it is often not easily possible to get physical access to attach a config adapter. Many of our devices support Remote Configuration that allows you to change the configuration of the device by sending Downlink messages via LoRaWAN. The Remote Configuration must be enabled in the device by setting the parameter RemoteConf to true . If this is set to false , none of the remote commands described here will work, and you can only activate it with physical access to the device. This is meant as a security feature if you want to make sure that your device will not be controlled over the network. If you are using Remote Configuration, please be aware that LoRaWAN devices can only be reached by the network under certain conditions. See Uplinks and Downlinks . Lobaro LoRaWAN devices receive remote configuration commands as Downlinks on port 128. Responses to those commands will be sent as Uplinks on port 128 (and 129-131 for long responses). The remote commands and their responses are all encoded in ASCII, to make it easier for humans to use them. The first byte of a Downlink message on port 128 contains a single character that identifies the command you want to send. Some commands take a parameter following the command char. The responses to a command start with the same character as the command followed by an optional parameter. If a command is unknown or it fails for some reason, an error response is sent via Uplink that contains with a ! followed by a readable error message. Changing configuration does nothing until you save the changes and reboot the device. The device has a safety feature that prevents configurations that make the device unusable. A new configuration is tested in the first run after rebooting. Only after the device reaches a stable state will the configuration be adopted and used permanently. If a problem occurs the device will restore its last stable connection and reboot. If the device uses OTAA (which we recommend) the device will only adopt the new configuration only after a join request is accepted, to make sure the LoRaWAN parameters are correct. After a few failed attempts it will restore the previous configuration. This can take up to about 10 minutes. Char Command Parameter Hex ? Request firmware and version None 3F g Get config parameter value Name of parameter 67 r Reset config parameter value Name of parameter 72 s Set config parameter value <name>=<value> 73 a Append to config parameter value <name>=<value> 61 b Reboot device without saving None 62 w Save config and reboot device None 77 ? Request firmware and version. This command triggers the device to send what firmware it is running and in which version. This can be used to test if the remote configuration is working. g<name> Get the value of the config parameter <name> . This command makes the device sent a response containing <name>=<value> as parameter giving you the current value of a configuration parameter. r<name> / r* Reset config parameter <name> to its default value. As a confirmation the device sends a response containing <name>=<value> , reporting the new value of the parameter. Sending the special value * will reset all config parameters. s<name>=<value> Set config parameter <name> to <value> . Sets the parameter to the value given in the parameter. As a confirmation it sends a response containing <name>=<value> , reporting the new value of the parameter. a<name>=<value> Append <value> to the config parameter <name> . This command appends the value given to the current value of the parameter. This is intended to allow setting values that are too long for a single Downlink message. As a confirmation it sends the length of the config parameter's value after the appending. Append works for config paramters of type string . b Reboot device without saving. This command restarts the device. Any changes too the config that have been committed before will be lost! This command does not send a Response. w / wFORCE Save config and reboot device. This command saves all configuration changes to a temporarily configuration and restarts the device. Only if the device boots successfully and reaches normal operation mode is the new configuration made permanent. If any fatal configuration error occurs or if the LoRaWAN OTAA Join does not succeed, the previous configuration will be restored and the device restarted again. This command does not send a Response. If you add the special argument FORCE to the command, the configuration will be made permanent without testing the configuration. Using wFORCE can leave your device useless and unreachable! Do not use wFORCE unless you have a very good reason. If the device is set to an invalid configuration it will no longer be reachable by the Network Server. From such a state it can only be recovered with physical access and a config adapter. It will also most likely drain the battery quickly.","title":"Remote Configuration"},{"location":"background/lorawan.html#example-changing-configuration","text":"The following is a short example of how you can update two configuration values remotely (that includes rebooting the device). Most LoRaWAN devices (all that are running in Class A, which are by fast the most) can only be reached when they contact the network. Network Servers (like The Things Network) provide a mechanism to enqueue messages for a specific device. The messages will be sent as downlink the next time that device contacts the network. Normally, multiple messages can be enqueued and will all be transmitted as soon as possible. Please be advised that the gateways communicating with your device must respect their duty cycle, so there is a very limited amount of downlinks that can be sent for a given time (downlinks are expensive). For this example we want to set Time Synchronisation to sync the internal clock every 10 days, and we want to deactivate Adaptive Date Rate (ADR). These are both LoRaWAN configuration parameters that are present on most devices (find details under LoRaWAN Configuration ), but you can of course also change parameters specific to your device, e.g. Modbus configuration or wMBus configuration, with this feature. We will need to send three commands: sTimeSync=10 \u2013 set time synchronisation to 10 day interval sADR=false \u2013 disable adaptive data rate w \u2013 write changes to device configuration and reboot The s -commands will of course differ for your case, but the w command at the end will be the same. After sending the final command, the device will reboot and try the new configuration. If the boot process and the connection to the network are successful, the device will make the changes permanent. If there is a problem (if you accidentally set an invalid value, e.g. sADR=flase or if you changed your AppKey to wrong value and your OTAA fails), the device will revert to the previous configuration.","title":"Example: changing configuration"},{"location":"background/lorawan.html#downlinks-on-ttn","text":"How you sent your downlinks depends on the LoRaWAN Network Server you use to connect your devices. You will most likely need to convert the commands (that are all ASCII) to some different representation, e.g. Hex or Base64. In The Things Network you find the downlink panel on the \"Device Overview\" page for each device, directly below the panel that shows you OTAA/ABP information (DevEUI, AppKey, ...). It is shown in the following screenshot: You will have to encode the commands in hex. In the screenshot you see 73 54 69 6d 65 53 79 6e 63 3d 31 30 as the message to send; that is the hex representation of sTimeSync=10 . The Port used for remote configuration for our devices is 128. When you enter multiple messages to send, be sure to set the correct scheduling ( last ). The preselected replace will overwrite your previously enqueued messages.","title":"Downlinks on TTN"},{"location":"background/lorawan.html#parser","text":"LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 , 40 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } // float32([62, 132, 168, 155]) = 0.305068 function float32 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); bytes = int32_BE ( bytes , 0 ) var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ // Decoder function for TTN function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io // Uncomment only when used in niota! /* module.exports = function (payload, meta) { const port = meta.lora.fport; const buf = Buffer.from(payload, 'hex'); return Decoder(buf, port); }*/","title":"Parser"},{"location":"background/obis-codes.html","text":"OBIS-Codes Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61. Structure Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used Examples 1-0:1.8.0*255 Positive active energy (A+) total [kWh] 1-0:3.8.1*255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"OBIS Codes"},{"location":"background/obis-codes.html#obis-codes","text":"Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61.","title":"OBIS-Codes"},{"location":"background/obis-codes.html#structure","text":"Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used","title":"Structure"},{"location":"background/obis-codes.html#examples","text":"1-0:1.8.0*255 Positive active energy (A+) total [kWh] 1-0:3.8.1*255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"Examples"},{"location":"background/weee-disposal.html","text":"Disposal of Lobaro Devices Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash. WEEE The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility. Proper disposal of Lobaro B2B devices Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\". RoHS As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU. Batteries Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"WEEE Disposal"},{"location":"background/weee-disposal.html#disposal-of-lobaro-devices","text":"Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash.","title":"Disposal of Lobaro Devices"},{"location":"background/weee-disposal.html#weee","text":"The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility.","title":"WEEE"},{"location":"background/weee-disposal.html#proper-disposal-of-lobaro-b2b-devices","text":"Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\".","title":"Proper disposal of Lobaro B2B devices"},{"location":"background/weee-disposal.html#rohs","text":"As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU.","title":"RoHS"},{"location":"background/weee-disposal.html#batteries","text":"Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"Batteries"},{"location":"background/weee-entsorgung.html","text":"Entsorgung von Ger\u00e4ten von Lobaro English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten. WEEE Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung. Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein. RoHS Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU. Batteriegesetz Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#entsorgung-von-geraten-von-lobaro","text":"English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten.","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#weee","text":"Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung.","title":"WEEE"},{"location":"background/weee-entsorgung.html#ordnungsgemae-entsorgung-von-b2b-lobaro-geraten","text":"Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein.","title":"Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten"},{"location":"background/weee-entsorgung.html#rohs","text":"Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU.","title":"RoHS"},{"location":"background/weee-entsorgung.html#batteriegesetz","text":"Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Batteriegesetz"},{"location":"dashboard/index.html","text":"// Page required to support old links from Platform! Dashboard Moved to: Platform window.location.href = window.location.origin + \"/platform\"; //console.log(window.location) //alert(window.location.origin + \"/platform\")","title":"Index"},{"location":"dashboard/index.html#dashboard","text":"Moved to: Platform window.location.href = window.location.origin + \"/platform\"; //console.log(window.location) //alert(window.location.origin + \"/platform\")","title":"Dashboard"},{"location":"lorawan-sensors/config-lorawan.html","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"Config lorawan"},{"location":"lorawan-sensors/1-wire-lorawan/index.html","text":"1-Wire LoRaWAN Bridge Order number: 8000001 Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks. Configuration Without configuration the sensors will be transmitted ordered by the 48 Bit id, ignoring the Sensorfamily prefix and the Checksum. name description example value SendInternalTemp Toggle output of internal sensor \"true\" or \"false\" SensorIdOrder Semicolon separated list of 48 Bit IDs in hex 22ffffff0000;44ffffff0000;11ffffff0000 Payload Example payloads for each port: Status Message (Port 1) Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" } Data Message (Port 2) Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true } Parser TheThingsNetwork (TTN) function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota platform module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); } CE Declaration of Conformity CE Declaration of Conformity (pdf).","title":"Manual"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#1-wire-lorawan-bridge","text":"Order number: 8000001 Consider using the latest firmware on your hardware See available firmware downloads","title":"1-Wire LoRaWAN Bridge"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#target-measurement-purpose","text":"Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#configuration","text":"Without configuration the sensors will be transmitted ordered by the 48 Bit id, ignoring the Sensorfamily prefix and the Checksum. name description example value SendInternalTemp Toggle output of internal sensor \"true\" or \"false\" SensorIdOrder Semicolon separated list of 48 Bit IDs in hex 22ffffff0000;44ffffff0000;11ffffff0000","title":"Configuration"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#payload","text":"Example payloads for each port:","title":"Payload"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#status-message-port-1","text":"Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" }","title":"Status Message (Port 1)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#data-message-port-2","text":"Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true }","title":"Data Message (Port 2)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#thethingsnetwork-ttn","text":"function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota platform module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); }","title":"TheThingsNetwork (TTN)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html","text":"1-Wire LoRaWAN Bridge (Temperature Sensors) Firmware Downloads: app-lorawan-onewire-bridge-0.3.4.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog v0.3.4 (13.08.2019) fixed bug in sorting algorithm v0.3.3 (01.08.2019) Added ADR config parameter v0.3.2 (01.08.2019) Fixed Onewire init after DeepSleep v0.3.1 (29.07.2019) Temp sensors will be printed and sent sorted by parameter \"SensorIdOrder\" and by ID or just by ID if parameter \"SensorIdOrder\" is empty v0.2.0 (15.02.2019) Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload v0.0.3 Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset v0.0.2 Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"Firmware & Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#1-wire-lorawan-bridge-temperature-sensors","text":"","title":"1-Wire LoRaWAN Bridge (Temperature Sensors)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-onewire-bridge-0.3.4.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v034-13082019","text":"fixed bug in sorting algorithm","title":"v0.3.4 (13.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v033-01082019","text":"Added ADR config parameter","title":"v0.3.3 (01.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v032-01082019","text":"Fixed Onewire init after DeepSleep","title":"v0.3.2 (01.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v031-29072019","text":"Temp sensors will be printed and sent sorted by parameter \"SensorIdOrder\" and by ID or just by ID if parameter \"SensorIdOrder\" is empty","title":"v0.3.1 (29.07.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v020-15022019","text":"Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload","title":"v0.2.0 (15.02.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v003","text":"Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset","title":"v0.0.3"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v002","text":"Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"v0.0.2"},{"location":"lorawan-sensors/_template/index.html","text":"Name of Sensor Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#name-of-sensor","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#target-measurement-purpose","text":"xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/_template/firmware.html","text":"Name of Sensor Firmware Downloads : firmware.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog v0.0.1 Initial release","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#name-of-sensor","text":"","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#firmware","text":"Downloads : firmware.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/_template/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/_template/firmware.html#v001","text":"Initial release","title":"v0.0.1"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html","text":"EDL21 Electricity meter LoRaWAN Bridge The EDL21 over LoRaWAN bridge is a device that can be used to readout modern utility meters with standardized infrared \"INFO\" interface. These type of meters are called in Germany to be \"EDL21\"-compatible - hence the name. The meter outputs over its infrared \"INFO\" interface a serial protocol conforming to the Smart Meter Language Protocol 1.04 (SML). This interface is intended to be used by end-users and not for billing purposes of the electricity supplier. The read information normally contains the current consumption values of the meter and gets interpreted and forwarded by the EDL21 bridge via a LoRaWAN network to web based applications interested in further processing this data. Warning Older meters with \"infrared pulse\" output are not compatible to the Lobaro EDL21 bridge. Please check our list of compatible meters to make sure it is equipped with the correct interface. Consider using the latest firmware on your hardware See available firmware downloads Top Features LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Configuration via USB or remotely via LoRaWAN downlink Compatible with many electrical utility meters RGB Status LED Variants with external power-supply and D-cell batteries available on request Separation of infrared readout head and LoRaWAN antenna possible Compatible utility meters Electricity meter Manufacturer More information DTZ541-ZEBA Holley External Link LK13 series Logarex External Link OpenWay\u00ae 3.HZ iTron External Link SGM-C4 series efr External Link SGM-D series efr External Link eHZ-K series EMH External Link mMe4.0 series EMH External Link ED300 series EMH External Link eBZD series EMH External Link ITZ series EMH External Link E320 Landis+Gyr External Link Alternative IEC 62056-21 protocol On request we offer also the integration of electricity meters using the D0 interface conforming to IEC 62056-21 . This interface is not compatible to the SML protocol. Please contact us if you need an offer for a custom firmware supporting your meter of interest. Product variants EDL21-LoRaWAN Bridge (universal head, AA, int. Ant.), Order number: 8000057 Customization Options The product variant shown above is the standard variant in our compact housing and powered by two AA batteries. Other power supply options & housing are available on request External antenna D-cell batteries External power-supply NB-IoT instead of LoRaWAN Different infrared data formats other than SML Contact us via support@lobaro.de if you need our offer for a special variant. Quickstart Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Not supported by this firmware bool false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot Operation Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1-0:1.7.255*255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes . LED blinking patterns The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red/green/blue 300ms each initial pattern after reset red/green 1s NEW in 0.3.2: single readout success/failure before OTAA join red short, blinking trying to receive meter optical data for the first time after OTAA join green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once. Appendices Technical characteristics Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards Disposal / WEEE / Entsorgung Information about the disposal of the Device . Payload Format Status Packet (Port 1) Once per day a status packet will be sent. It contains basic information about the device. The Battery Voltage is transmitted in 1/1000 V and the temperature in 1/10 \u00b0C. Both are in Big Endian byte order. Version Major Version Minor Version Patch Flags Battery Voltage Temperature 1 byte 1 byte 1 byte 1 byte 2 byte 2byte unsigned unsigned unsigned unsigned unsigned signed Payload Format (old, Port 2, without exponent) The payload consists of multiple entries, one entry per OBIS code given in the configuration. Each entry follows the following structure: OBISCode (hex) lenght of value (n) value 6 bytes 1 byte n bytes, LSB first Example packet: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 Entry 1: OBISCode (hex) lenght of value (n) value 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 1-0:1.8.0*254 8 511 Entry 2: OBISCode (hex) lenght of value (n) value 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 1-0:1.8.0*254 8 767 Payload Format (new, Port 3, with exponent) The payload consists of multiple entries, one entry per OBIS code given in the configuration. Each entry follows the following structure: OBISCode (hex) lenght of value (n) value exponent 6 bytes 1 byte n bytes, LSB first 1 byte (signed) Example packet: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 ff 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 02 Entry 1: OBISCode (hex) lenght of value (n) value exponent 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 ff 1-0:1.8.0*254 8 511 -1 Value = 511 * 10^-1 = 51.1 Entry 2: OBISCode (hex) lenght of value (n) value exponent 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 02 1-0:1.8.0*254 8 767 2 Value = 767 * 10^2 = 76700 Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } } // Wrapper for niota.io module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); } Example parser result Test input (Port 3): 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 51.1 , \"valueHex\" : \"ff01000000000000\" } ] } CE Declaration of Conformity CE Declaration of Conformity (pdf).","title":"Manual"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#edl21-electricity-meter-lorawan-bridge","text":"The EDL21 over LoRaWAN bridge is a device that can be used to readout modern utility meters with standardized infrared \"INFO\" interface. These type of meters are called in Germany to be \"EDL21\"-compatible - hence the name. The meter outputs over its infrared \"INFO\" interface a serial protocol conforming to the Smart Meter Language Protocol 1.04 (SML). This interface is intended to be used by end-users and not for billing purposes of the electricity supplier. The read information normally contains the current consumption values of the meter and gets interpreted and forwarded by the EDL21 bridge via a LoRaWAN network to web based applications interested in further processing this data. Warning Older meters with \"infrared pulse\" output are not compatible to the Lobaro EDL21 bridge. Please check our list of compatible meters to make sure it is equipped with the correct interface. Consider using the latest firmware on your hardware See available firmware downloads","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#top-features","text":"LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Configuration via USB or remotely via LoRaWAN downlink Compatible with many electrical utility meters RGB Status LED Variants with external power-supply and D-cell batteries available on request Separation of infrared readout head and LoRaWAN antenna possible","title":"Top Features"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#compatible-utility-meters","text":"Electricity meter Manufacturer More information DTZ541-ZEBA Holley External Link LK13 series Logarex External Link OpenWay\u00ae 3.HZ iTron External Link SGM-C4 series efr External Link SGM-D series efr External Link eHZ-K series EMH External Link mMe4.0 series EMH External Link ED300 series EMH External Link eBZD series EMH External Link ITZ series EMH External Link E320 Landis+Gyr External Link Alternative IEC 62056-21 protocol On request we offer also the integration of electricity meters using the D0 interface conforming to IEC 62056-21 . This interface is not compatible to the SML protocol. Please contact us if you need an offer for a custom firmware supporting your meter of interest.","title":"Compatible utility meters"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#product-variants","text":"EDL21-LoRaWAN Bridge (universal head, AA, int. Ant.), Order number: 8000057 Customization Options The product variant shown above is the standard variant in our compact housing and powered by two AA batteries. Other power supply options & housing are available on request External antenna D-cell batteries External power-supply NB-IoT instead of LoRaWAN Different infrared data formats other than SML Contact us via support@lobaro.de if you need our offer for a special variant.","title":"Product variants"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#quickstart","text":"Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment","title":"Quickstart"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Not supported by this firmware bool false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot","title":"LoRaWAN"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1-0:1.7.255*255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes .","title":"Operation"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#led-blinking-patterns","text":"The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red/green/blue 300ms each initial pattern after reset red/green 1s NEW in 0.3.2: single readout success/failure before OTAA join red short, blinking trying to receive meter optical data for the first time after OTAA join green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once.","title":"LED blinking patterns"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#technical-characteristics","text":"Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#payload-format-status-packet-port-1","text":"Once per day a status packet will be sent. It contains basic information about the device. The Battery Voltage is transmitted in 1/1000 V and the temperature in 1/10 \u00b0C. Both are in Big Endian byte order. Version Major Version Minor Version Patch Flags Battery Voltage Temperature 1 byte 1 byte 1 byte 1 byte 2 byte 2byte unsigned unsigned unsigned unsigned unsigned signed","title":"Payload Format Status Packet (Port 1)"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#payload-format-old-port-2-without-exponent","text":"The payload consists of multiple entries, one entry per OBIS code given in the configuration. Each entry follows the following structure: OBISCode (hex) lenght of value (n) value 6 bytes 1 byte n bytes, LSB first Example packet: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 Entry 1: OBISCode (hex) lenght of value (n) value 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 1-0:1.8.0*254 8 511 Entry 2: OBISCode (hex) lenght of value (n) value 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 1-0:1.8.0*254 8 767","title":"Payload Format (old, Port 2, without exponent)"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#payload-format-new-port-3-with-exponent","text":"The payload consists of multiple entries, one entry per OBIS code given in the configuration. Each entry follows the following structure: OBISCode (hex) lenght of value (n) value exponent 6 bytes 1 byte n bytes, LSB first 1 byte (signed) Example packet: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 ff 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 02 Entry 1: OBISCode (hex) lenght of value (n) value exponent 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000 ff 1-0:1.8.0*254 8 511 -1 Value = 511 * 10^-1 = 51.1 Entry 2: OBISCode (hex) lenght of value (n) value exponent 01\u200000\u200001\u200008\u200000\u2000FE 08 FF\u200002\u200000\u200000\u200000\u200000\u200000\u200000 02 1-0:1.8.0*254 8 767 2 Value = 767 * 10^2 = 76700","title":"Payload Format (new, Port 3, with exponent)"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } } // Wrapper for niota.io module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); }","title":"Reference decoder"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#example-parser-result","text":"Test input (Port 3): 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u2000FF\u200001\u200000\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 51.1 , \"valueHex\" : \"ff01000000000000\" } ] }","title":"Example parser result"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html","text":"EDL21 Electricity meter LoRaWAN Bridge Firmware Downloads: WARNING When upgrading from Versions <0.4.1 to 0.4.1 or higher: Due to changes in the generation of the LoRaWAN parameters the default values for JoinEUI and AppKey will change if you use the Restore Default function in the Lobaro Maintenance Tool in order to reset the configuration. app-edl21-opto-0.4.1+LoRa.hex New Opto-Head Version (round) [current release] app-edl21-opto-0.2.0+LoRa.hex Old Opto-Head Version (square) Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog Firmware: app-edl21-opto v0.4.1 [current release] Fixed remote append WARNING: Due to changes in the generation of the LoRa paramters the values for JoinEUI and AppKey will change if you use the Restore Default function in the Lobaro Maintenance Tool in order to reset the configuration. v0.4.0 Added remote config via downlink v0.3.2 Added initial readout before OTAA join to check optical connection v0.3.1 Initial release for new round Opto-Head Legacy Downloads: app-edl21-opto-0.3.2+LoRa.hex New Opto-Head Version (round) app-edl21-opto-0.3.1+LoRa.hex New Opto-Head Version (round)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#edl21-electricity-meter-lorawan-bridge","text":"","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#firmware","text":"Downloads: WARNING When upgrading from Versions <0.4.1 to 0.4.1 or higher: Due to changes in the generation of the LoRaWAN parameters the default values for JoinEUI and AppKey will change if you use the Restore Default function in the Lobaro Maintenance Tool in order to reset the configuration. app-edl21-opto-0.4.1+LoRa.hex New Opto-Head Version (round) [current release] app-edl21-opto-0.2.0+LoRa.hex Old Opto-Head Version (square) Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#changelog","text":"Firmware: app-edl21-opto","title":"Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v041-current-release","text":"Fixed remote append WARNING: Due to changes in the generation of the LoRa paramters the values for JoinEUI and AppKey will change if you use the Restore Default function in the Lobaro Maintenance Tool in order to reset the configuration.","title":"v0.4.1 [current release]"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v040","text":"Added remote config via downlink","title":"v0.4.0"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v032","text":"Added initial readout before OTAA join to check optical connection","title":"v0.3.2"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v031","text":"Initial release for new round Opto-Head Legacy Downloads: app-edl21-opto-0.3.2+LoRa.hex New Opto-Head Version (round) app-edl21-opto-0.3.1+LoRa.hex New Opto-Head Version (round)","title":"v0.3.1"},{"location":"lorawan-sensors/environment-lorawan/index.html","text":"Environment LoRaWAN Sensor Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose High precision measuring of Temperature, Humidity, and Pressure, using the Bosch BME680 environmental sensor. Configuration For configuration of the LoRaWAN parameters, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. name description example value MeasureCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes \u2020 See also our Introduction to Cron expressions . Payload Example payloads for each port: Status Message (Port 1) Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.0.1\" } Data Message (Port 2) Structure: name pos len type description timestamp 0 5 uint40 Time of measurement (see timestamps in our LoRaWAN devices ) error flag 5 1 byte 1 : error, 0 : success humidity 6 2 uint16 BE Humidity in 1/10 % rH temperature 8 2 int16 BE Temperature in 1/10 \u00b0C pressure 10 2 uint16 BE Pressure in 10 Pa Example Payload: 00386d440700015400f527d1 Decoded: { \"error\" : false , \"humidity\" : 34 , \"pressure\" : 1019.3 , \"temperature\" : 24.5 , \"time\" : 946684935000 } Parser Javascript Parser function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function uint40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function uint16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function int40_BE ( bytes , idx ) { return signed ( uint40_BE ( bytes , idx ), 40 ); } function int16_BE ( bytes , idx ) { return signed ( uint16_BE ( bytes , idx ), 16 ); } function ParseStatusMessage ( data ) { var decoded = {}; decoded . version = readVersion ( data , 0 ); decoded . vBat = uint16_BE ( data , 5 ) / 1000.0 ; decoded . temp = int16_BE ( data , 3 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; return decoded ; } function ParseDataMessage ( data ) { return { \"time\" : int40_BE ( data , 0 ) * 1000 , \"error\" : !! data [ 5 ], \"humidity\" : uint16_BE ( data , 6 ) / 10.0 , \"temperature\" : int16_BE ( data , 8 ) / 10.0 , \"pressure\" : uint16_BE ( data , 10 ) / 10 }; } // Decoder function for TTN function Decoder ( bytes , port ) { // Decode an incoming message to an object of fields. var decoded ; switch ( port ) { case 1 : decoded = ParseStatusMessage ( bytes ); break ; case 2 : decoded = ParseDataMessage ( bytes ); break ; default : decoded = {}; } return decoded ; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); if ( input . fPort == 2 ) { Device . setProperty ( \"status.firmware\" , decoded . FirmwareVersion ); Device . setProperty ( \"status.voltage\" , decoded . Vbat ); Device . setProperty ( \"status.temperature\" , decoded . Temp ); } return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); };","title":"Manual"},{"location":"lorawan-sensors/environment-lorawan/index.html#environment-lorawan-sensor","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Environment LoRaWAN Sensor"},{"location":"lorawan-sensors/environment-lorawan/index.html#target-measurement-purpose","text":"High precision measuring of Temperature, Humidity, and Pressure, using the Bosch BME680 environmental sensor.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/environment-lorawan/index.html#configuration","text":"For configuration of the LoRaWAN parameters, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. name description example value MeasureCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes \u2020 See also our Introduction to Cron expressions .","title":"Configuration"},{"location":"lorawan-sensors/environment-lorawan/index.html#payload","text":"Example payloads for each port:","title":"Payload"},{"location":"lorawan-sensors/environment-lorawan/index.html#status-message-port-1","text":"Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.0.1\" }","title":"Status Message (Port 1)"},{"location":"lorawan-sensors/environment-lorawan/index.html#data-message-port-2","text":"Structure: name pos len type description timestamp 0 5 uint40 Time of measurement (see timestamps in our LoRaWAN devices ) error flag 5 1 byte 1 : error, 0 : success humidity 6 2 uint16 BE Humidity in 1/10 % rH temperature 8 2 int16 BE Temperature in 1/10 \u00b0C pressure 10 2 uint16 BE Pressure in 10 Pa Example Payload: 00386d440700015400f527d1 Decoded: { \"error\" : false , \"humidity\" : 34 , \"pressure\" : 1019.3 , \"temperature\" : 24.5 , \"time\" : 946684935000 }","title":"Data Message (Port 2)"},{"location":"lorawan-sensors/environment-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/environment-lorawan/index.html#javascript-parser","text":"function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function uint40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function uint16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function int40_BE ( bytes , idx ) { return signed ( uint40_BE ( bytes , idx ), 40 ); } function int16_BE ( bytes , idx ) { return signed ( uint16_BE ( bytes , idx ), 16 ); } function ParseStatusMessage ( data ) { var decoded = {}; decoded . version = readVersion ( data , 0 ); decoded . vBat = uint16_BE ( data , 5 ) / 1000.0 ; decoded . temp = int16_BE ( data , 3 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; return decoded ; } function ParseDataMessage ( data ) { return { \"time\" : int40_BE ( data , 0 ) * 1000 , \"error\" : !! data [ 5 ], \"humidity\" : uint16_BE ( data , 6 ) / 10.0 , \"temperature\" : int16_BE ( data , 8 ) / 10.0 , \"pressure\" : uint16_BE ( data , 10 ) / 10 }; } // Decoder function for TTN function Decoder ( bytes , port ) { // Decode an incoming message to an object of fields. var decoded ; switch ( port ) { case 1 : decoded = ParseStatusMessage ( bytes ); break ; case 2 : decoded = ParseDataMessage ( bytes ); break ; default : decoded = {}; } return decoded ; } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); if ( input . fPort == 2 ) { Device . setProperty ( \"status.firmware\" , decoded . FirmwareVersion ); Device . setProperty ( \"status.voltage\" , decoded . Vbat ); Device . setProperty ( \"status.temperature\" , decoded . Temp ); } return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); };","title":"Javascript Parser"},{"location":"lorawan-sensors/environment-lorawan/firmware.html","text":"Environment LoRaWAN Sensor Firmware Downloads: app-lorawan-environment-TZ0-0.0.1.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog v0.0.1 (06.01.2020) Initial release","title":"Firmware & Changelog"},{"location":"lorawan-sensors/environment-lorawan/firmware.html#environment-lorawan-sensor","text":"","title":"Environment LoRaWAN Sensor"},{"location":"lorawan-sensors/environment-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-environment-TZ0-0.0.1.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/environment-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/environment-lorawan/firmware.html#v001-06012020","text":"Initial release","title":"v0.0.1 (06.01.2020)"},{"location":"lorawan-sensors/gps-lorawan/index.html","text":"GPS / GLONASS LoRaWAN Tracker Variant without Power Addon Order number: 8000014 Variant with Power Addon Order number: 8000082 Hardware Revisions The picture above shows the tracker in hardware revision 2 with GPS and additional GLONASS support for best positioning. Hardware revision 1 with GPS only is no longer available. Show pictures of different hardware revisions Overview The LoRaWAN GPS Tracker (GPS-LoRaWAN) is a battery powered tracking device, that uses the satellite based positioning services GPS and GLONASS to determine its location and transmits the obtained coordinates via LoRaWAN radio technology. Intervals between measurements can be freely configured, in order to adjust the device to individual needs. An integrated motion sensor detects changes in the device's movement (if it is picked up or transported in a vehicle). This allows the device to switch between an Active Mode in which frequent updates are uploaded during phases of movement and an Alive Mode that saves battery power by sending only few updates. While not sending updates, the device enters a sleep mode that only uses \u223c30 \u00b5A. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device. Operating the GPS Tracker Once batteries are inserted into the device, it will start working. The Tracker will most likely need to be adjusted to your personal LoRaWAN configuration (see chapter \"Configuration\"). Batteries The LoRaWAN GPS Tracker default power supply consists of two series connected off-theshelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium-Iron- Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB). Installation The device can be fixed on a flat surface using the lateral mounting holes of the case, see Hardware Variations for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Note Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Work Cycle graph LR; GPS(GPS Collection) Data(Data Transfer) Active(Active Sleep) Alive(Alive Sleep) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>GPS(GPS Collect.); Data==>|recent movement|Active(Active Sleep); GPS==>Data(Data Transfer); Active==>|short time cron expression|GPS(GPS Collection); Data(Data Transfer)==>|no recent movement|Alive(Alive Sleep); Alive==>|movement or long time cron expression|GPS(GPS Collection); The GPS Tracker has a work cycle that adapts to detected motion of the device. Initial Phase This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered. GPS Collection Phase During the GPS Collection Phase the device will try to determine its coordinates (latitude, longitude, and height) using GPS. You can identify this phase by the onboard LED flashing on and off in one second intervals. Once the position has been determined successfully (or the attempt timed out and failed, because of bad GPS reception), the device enters the Data Transfer Phase. Data Transfer Phase During the Data Transfer Phase the Tracker uploads the GPS coordinates to the LoRaWAN network. The message contains the information if the measurement was successful. Some status information about the device are included as well. For a detailed description of the data sent refer to \"LoRaWAN Data Upload Formats\". After data transfer, the GPS Tracker enters a sleep state to save power. Depending on how much time passed since the last physical movement of the device (determined by the internal motion sensor), the Tracker enters diferent sleep phases. If the time since the last detected motion is less than a timeout value (configurable, standard value is 65 minutes), the device remains in Active mode enters only a short sleep phase ( Active Sleep ). If no motion was detected for a time longer than the timeout, the device enters the Alive Sleep Phase, which typically has a much longer sleeping time, but in which the device will also be activated through movement. Active Sleep Phase Even in Active Mode, the device spends most of its time in a deep sleep state to conserve energy. The frequency with which the Tracker wakes up in Active Mode can be configured using a Cron expression (see \"GPS configuration parameters\"). Typical values for active sleep time are 5 or 15 minutes. When in Active Sleep Phase, the device will not be triggered to gather more GPS positions through motion, but movement of the device will still be registered to keep the Tracker in Active Mode. Alive Sleep Phase When no movement has been detected for a long amount of time (configurable), the device stops sending updates, since there is not much point in sending frequent position information when the device does not change its position. In Alive Mode, only very few updates are sent to keep the network informed about the device's health. Typically one message is sent per day in this mode (frequency can be configured with a cron expression, see \"GPS configuration parameters\"). When physical movement is detected by the internal motion sensor during this phase, the GPS Tracker immediately wakes up and switches to Active Mode. Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration gets plugged/unplugged! Connecting the USB config adapter For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. Hardware Revisions The picture above shows the tracker in hardware revision 1 with GPS only support. Hardware revision 1 with GPS only is no longer available. System Parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Not supported by this firmware bool false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot GPS configuration parameters The behaviour of the GPS Tracker and how it switches between its two operation modes ('Active' and 'Alive') can be adjusted to your needs. The table explains the configuration parameters used for this. Name Type Description default value ActiveCron string Cron expression defining how often the device will take a measurement and send its position over LoRaWAN while the Tracker is in Active Mode. This expression should trigger much more frequent than the one for Alive Mode. The standard is 0 0/15 * * * *, which will trigger every 15 minutes. See chapter \"Cron expressions\" for an introduction to cron expressions. 0 0/15 * * * * AliveCron string Cron expression defining how often the device will wake up when in Alive Mode. This should be less frequent than in Active Mode. The standard is 0 0 0/12 * * *, which translates to twice each day. See chapter \"Cron expressions\" for an introduction to cron expressions. 0 0 0/12 * * * gpsTO int Time in seconds to wait for GPS to get a fix before timing out. 180 seconds actTO int Time in minutes without movement after which the Tracker switches to Alive Mode. 65 minutes memsTh int Threshold for the internal motion detector to register movement. Values range from 2 to 255. A higher value makes the device less sensitive. 2 Environment (wind or steps) may trigger. 5 Standard, picking up the device will activate it. 20 Carefully picking it up will not trigger the device. 50 When carried, running will trigger, walking won't. 100+ Shaking will activate, dropping the device might not. 5 CayenneLPP bool Use alternative Cayenne LPP upload format. Standard: false, e.g. use Lobaro Format. See chapter \"myDevices Cayenne format\" for an introduction to this format. false maxHDOP int Maximum acceptable Horizontal Dilution Of Precision, between 1 and 50, smaller is better 2 maxDataAfterFix int If the HDOP target cannot be matched this value determines after how many datapackets with fix the position will be accepted 20 Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00 LoRaWAN Data Upload Formats After reading GPS coordinates (either successfully or unsuccessfully), the Tracker uploads the data using LoRaWAN. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes, no keys or data types are included. The meaning of a byte is determined by its position within a message. The tracker supports two different upload formats as described in the following: Lobaro upload format (since Firmware Version 5) Only a single massage format is used by the GPS Tracker, it has a fixed length of 17 bytes. The table explains the message format used. This format uses the decimal degrees notation for the location, e.g. 53.4724\u00b0 north and 9.9334\u00b0 east. Positive (+) values indicate north longitudes and east latitudes, negative (-) values indicate south longitudes and west latitudes. Both location values are transmitted as signed integers in big endian format and get multiplied by 100.000. So after receiving the location data must be divided by this factor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units, e.g. 1/100000 degree (as described before), to handle only with integers. Fields, Data Packet name bytes type description example / range temp 0-1 int16 Temperature inside the device in 1/10\u00b0C 246 = 24.6 \u00b0C v_bat 2-3 uint16 Current battery voltage in mV 3547 = 3.547 V latitude deg 4-7 int32 int32 degrees of the latitude x 100 000 -9 000 000 to 9 000 000 longitude deg 8-11 int32 degrees of the longitude x 100 000 -18 000 000 to 18 000 000 altitude 12-14 int24 Altitude of the device in centimeters -8 388 607 to 8 388 606 flags 15 uint8 Status flag, refer to table below 00bin = invalid, alive 01bin = valid, alive 10bin = invalid, active 11bin = valid, active sat 16 uint8 GPS satellites found / in view 7 Status flag bit function not set set 1 Validity of last measurement invalid valid 2 Current operation mode alive active 3-8 reserved for future use If during some configurable period of time (see \"gpsTO\" parameter in table \"GPS configuration parameters\") no GPS location can be found the last known valid GPS location will be transmitted but with the valid flag set to false. We provide a JavaScript reference implementation of a decoder for the data packages, which can be used directly for decoding in The Things Network . myDevices Cayenne format As an alternative for the Lobaro data format the tracker can be configured to send Cayenne LPP compatible LoRaWAN uploads. myDevices Cayenne allows you to quickly visualize the via LoRaWAN transmitted data of the Lobaro GPS-tracker. You can use Cayenne as a tool to visualize real-time and historical data, sent over The Things Network and various other LoRaWAN providers. To use the alternative upload format configuration parameter \"CayenneLPP\" must be set to \"true\" as described in section \"GPS configuration parameters\" The advantages of using the cayenne format is a quick device evaluation without programming some custom backend and/or front software. Disadvantages are bigger LoRaWAN message sizes due to the additional schema meta information overhead the format needs. The Lobaro GPS Trackers maps its data to cayenne channels as follows: description cayenne channel cayenne type Internal Temperature 0 Temperature Battery Voltage 1 AnalogOutput GPS data 2 GPS satellites found 3 Digital Output Legacy upload format (up to Firmware Version 4) This format is not supported any more since firmware version V5.0.0! Please consider updating your device firmware using the Lobaro maintenance tool. Only a single massage format is used by the GPS Tracker, it has a fixed length of 15 bytes. This format uses the degrees with decimal minutes notation for the location. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). The table underneath explains the message format used. name type description example/range flags uint8 Status flags, for internal use 0 temp int16 Temperature inside the device in 1/10\u00b0C 246 \u2259 24.6 \u00b0C v_bat uint16 Current battery voltage in mV 3547 \u2259 3:547 V latitude deg int8 Whole degrees of the latitude -90 to 90 Example As an illustration, if the received data would consist of the 15 bytes (hexencoded): 00 01 18 0D 69 35 1C 0F 71 09 38 02 4B 01 06 type example description flag 00 for internal use, ignore temp 01 18 0118 hex = 0280dec \u2259 280 d\u00b0C = 28.0 \u00b0C v_bat 0D 69 0D89 hex = 3465dec \u2259 3465mV = 3.465V latitude 35 1C 0F 71 35hex = 53dec \u2259 53\u00b0 1C hex = 28dec \u2259 28' 0F71 hex = 3953dec \u2259 0.3953' 351C0F71 \u2259 53\u00b028.3952' = 53.473255\u00b0 = 53\u00b028'23.718'' North longitude 09 38 02 4B 09 hex = 09dec \u2259 09\u00b0 38 hex = 56dec \u2259 56' 024B hex = 0587dec \u2259 0.0587' 0938024B \u2259 9\u00b056.0587' = 9.934 312\u00b0 = 9\u00b056'3.522'' East valid 01 01hex \u2259 valid measurement, could receive GPS signal sat 06 06hex = 06dec \u2259 Signal of 6 satellites received for measurement Technical characteristics Product Type name GPS-LoRaWAN Description LoRaWAN GPS Tracker RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with GPS standby and MEMS running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Parser The Things Network For Version 4.x, 5.x and 6.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io (uncomment only when used in niota) /* module.exports = function (payload, meta) { const port = meta.lora.fport; const buf = Buffer.from(payload, 'hex'); return Decoder(buf, port); }*/ PDF Documentation Product Dimensions (pdf) User Manual (en) CE Declaration of Conformity","title":"Manual"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-glonass-lorawan-tracker","text":"","title":"GPS / GLONASS LoRaWAN Tracker"},{"location":"lorawan-sensors/gps-lorawan/index.html#variant-without-power-addon","text":"Order number: 8000014","title":"Variant without Power Addon"},{"location":"lorawan-sensors/gps-lorawan/index.html#variant-with-power-addon","text":"Order number: 8000082 Hardware Revisions The picture above shows the tracker in hardware revision 2 with GPS and additional GLONASS support for best positioning. Hardware revision 1 with GPS only is no longer available. Show pictures of different hardware revisions","title":"Variant with Power Addon"},{"location":"lorawan-sensors/gps-lorawan/index.html#overview","text":"The LoRaWAN GPS Tracker (GPS-LoRaWAN) is a battery powered tracking device, that uses the satellite based positioning services GPS and GLONASS to determine its location and transmits the obtained coordinates via LoRaWAN radio technology. Intervals between measurements can be freely configured, in order to adjust the device to individual needs. An integrated motion sensor detects changes in the device's movement (if it is picked up or transported in a vehicle). This allows the device to switch between an Active Mode in which frequent updates are uploaded during phases of movement and an Alive Mode that saves battery power by sending only few updates. While not sending updates, the device enters a sleep mode that only uses \u223c30 \u00b5A. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device.","title":"Overview"},{"location":"lorawan-sensors/gps-lorawan/index.html#operating-the-gps-tracker","text":"Once batteries are inserted into the device, it will start working. The Tracker will most likely need to be adjusted to your personal LoRaWAN configuration (see chapter \"Configuration\").","title":"Operating the GPS Tracker"},{"location":"lorawan-sensors/gps-lorawan/index.html#batteries","text":"The LoRaWAN GPS Tracker default power supply consists of two series connected off-theshelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium-Iron- Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB).","title":"Batteries"},{"location":"lorawan-sensors/gps-lorawan/index.html#installation","text":"The device can be fixed on a flat surface using the lateral mounting holes of the case, see Hardware Variations for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Note Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Installation"},{"location":"lorawan-sensors/gps-lorawan/index.html#work-cycle","text":"graph LR; GPS(GPS Collection) Data(Data Transfer) Active(Active Sleep) Alive(Alive Sleep) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>GPS(GPS Collect.); Data==>|recent movement|Active(Active Sleep); GPS==>Data(Data Transfer); Active==>|short time cron expression|GPS(GPS Collection); Data(Data Transfer)==>|no recent movement|Alive(Alive Sleep); Alive==>|movement or long time cron expression|GPS(GPS Collection); The GPS Tracker has a work cycle that adapts to detected motion of the device.","title":"Work Cycle"},{"location":"lorawan-sensors/gps-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan-join-phase","text":"If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-collection-phase","text":"During the GPS Collection Phase the device will try to determine its coordinates (latitude, longitude, and height) using GPS. You can identify this phase by the onboard LED flashing on and off in one second intervals. Once the position has been determined successfully (or the attempt timed out and failed, because of bad GPS reception), the device enters the Data Transfer Phase.","title":"GPS Collection Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Tracker uploads the GPS coordinates to the LoRaWAN network. The message contains the information if the measurement was successful. Some status information about the device are included as well. For a detailed description of the data sent refer to \"LoRaWAN Data Upload Formats\". After data transfer, the GPS Tracker enters a sleep state to save power. Depending on how much time passed since the last physical movement of the device (determined by the internal motion sensor), the Tracker enters diferent sleep phases. If the time since the last detected motion is less than a timeout value (configurable, standard value is 65 minutes), the device remains in Active mode enters only a short sleep phase ( Active Sleep ). If no motion was detected for a time longer than the timeout, the device enters the Alive Sleep Phase, which typically has a much longer sleeping time, but in which the device will also be activated through movement.","title":"Data Transfer Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#active-sleep-phase","text":"Even in Active Mode, the device spends most of its time in a deep sleep state to conserve energy. The frequency with which the Tracker wakes up in Active Mode can be configured using a Cron expression (see \"GPS configuration parameters\"). Typical values for active sleep time are 5 or 15 minutes. When in Active Sleep Phase, the device will not be triggered to gather more GPS positions through motion, but movement of the device will still be registered to keep the Tracker in Active Mode.","title":"Active Sleep Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#alive-sleep-phase","text":"When no movement has been detected for a long amount of time (configurable), the device stops sending updates, since there is not much point in sending frequent position information when the device does not change its position. In Alive Mode, only very few updates are sent to keep the network informed about the device's health. Typically one message is sent per day in this mode (frequency can be configured with a cron expression, see \"GPS configuration parameters\"). When physical movement is detected by the internal motion sensor during this phase, the GPS Tracker immediately wakes up and switches to Active Mode.","title":"Alive Sleep Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/gps-lorawan/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration gets plugged/unplugged!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/gps-lorawan/index.html#connecting-the-usb-config-adapter","text":"For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. Hardware Revisions The picture above shows the tracker in hardware revision 1 with GPS only support. Hardware revision 1 with GPS only is no longer available.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/gps-lorawan/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System Parameters"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Not supported by this firmware bool false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot","title":"LoRaWAN"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-configuration-parameters","text":"The behaviour of the GPS Tracker and how it switches between its two operation modes ('Active' and 'Alive') can be adjusted to your needs. The table explains the configuration parameters used for this. Name Type Description default value ActiveCron string Cron expression defining how often the device will take a measurement and send its position over LoRaWAN while the Tracker is in Active Mode. This expression should trigger much more frequent than the one for Alive Mode. The standard is 0 0/15 * * * *, which will trigger every 15 minutes. See chapter \"Cron expressions\" for an introduction to cron expressions. 0 0/15 * * * * AliveCron string Cron expression defining how often the device will wake up when in Alive Mode. This should be less frequent than in Active Mode. The standard is 0 0 0/12 * * *, which translates to twice each day. See chapter \"Cron expressions\" for an introduction to cron expressions. 0 0 0/12 * * * gpsTO int Time in seconds to wait for GPS to get a fix before timing out. 180 seconds actTO int Time in minutes without movement after which the Tracker switches to Alive Mode. 65 minutes memsTh int Threshold for the internal motion detector to register movement. Values range from 2 to 255. A higher value makes the device less sensitive. 2 Environment (wind or steps) may trigger. 5 Standard, picking up the device will activate it. 20 Carefully picking it up will not trigger the device. 50 When carried, running will trigger, walking won't. 100+ Shaking will activate, dropping the device might not. 5 CayenneLPP bool Use alternative Cayenne LPP upload format. Standard: false, e.g. use Lobaro Format. See chapter \"myDevices Cayenne format\" for an introduction to this format. false maxHDOP int Maximum acceptable Horizontal Dilution Of Precision, between 1 and 50, smaller is better 2 maxDataAfterFix int If the HDOP target cannot be matched this value determines after how many datapackets with fix the position will be accepted 20","title":"GPS configuration parameters"},{"location":"lorawan-sensors/gps-lorawan/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan-data-upload-formats","text":"After reading GPS coordinates (either successfully or unsuccessfully), the Tracker uploads the data using LoRaWAN. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes, no keys or data types are included. The meaning of a byte is determined by its position within a message. The tracker supports two different upload formats as described in the following:","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/gps-lorawan/index.html#lobaro-upload-format-since-firmware-version-5","text":"Only a single massage format is used by the GPS Tracker, it has a fixed length of 17 bytes. The table explains the message format used. This format uses the decimal degrees notation for the location, e.g. 53.4724\u00b0 north and 9.9334\u00b0 east. Positive (+) values indicate north longitudes and east latitudes, negative (-) values indicate south longitudes and west latitudes. Both location values are transmitted as signed integers in big endian format and get multiplied by 100.000. So after receiving the location data must be divided by this factor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units, e.g. 1/100000 degree (as described before), to handle only with integers.","title":"Lobaro upload format (since Firmware Version 5)"},{"location":"lorawan-sensors/gps-lorawan/index.html#fields-data-packet","text":"name bytes type description example / range temp 0-1 int16 Temperature inside the device in 1/10\u00b0C 246 = 24.6 \u00b0C v_bat 2-3 uint16 Current battery voltage in mV 3547 = 3.547 V latitude deg 4-7 int32 int32 degrees of the latitude x 100 000 -9 000 000 to 9 000 000 longitude deg 8-11 int32 degrees of the longitude x 100 000 -18 000 000 to 18 000 000 altitude 12-14 int24 Altitude of the device in centimeters -8 388 607 to 8 388 606 flags 15 uint8 Status flag, refer to table below 00bin = invalid, alive 01bin = valid, alive 10bin = invalid, active 11bin = valid, active sat 16 uint8 GPS satellites found / in view 7","title":"Fields, Data Packet"},{"location":"lorawan-sensors/gps-lorawan/index.html#status-flag","text":"bit function not set set 1 Validity of last measurement invalid valid 2 Current operation mode alive active 3-8 reserved for future use If during some configurable period of time (see \"gpsTO\" parameter in table \"GPS configuration parameters\") no GPS location can be found the last known valid GPS location will be transmitted but with the valid flag set to false. We provide a JavaScript reference implementation of a decoder for the data packages, which can be used directly for decoding in The Things Network .","title":"Status flag"},{"location":"lorawan-sensors/gps-lorawan/index.html#mydevices-cayenne-format","text":"As an alternative for the Lobaro data format the tracker can be configured to send Cayenne LPP compatible LoRaWAN uploads. myDevices Cayenne allows you to quickly visualize the via LoRaWAN transmitted data of the Lobaro GPS-tracker. You can use Cayenne as a tool to visualize real-time and historical data, sent over The Things Network and various other LoRaWAN providers. To use the alternative upload format configuration parameter \"CayenneLPP\" must be set to \"true\" as described in section \"GPS configuration parameters\" The advantages of using the cayenne format is a quick device evaluation without programming some custom backend and/or front software. Disadvantages are bigger LoRaWAN message sizes due to the additional schema meta information overhead the format needs. The Lobaro GPS Trackers maps its data to cayenne channels as follows: description cayenne channel cayenne type Internal Temperature 0 Temperature Battery Voltage 1 AnalogOutput GPS data 2 GPS satellites found 3 Digital Output","title":"myDevices Cayenne format"},{"location":"lorawan-sensors/gps-lorawan/index.html#legacy-upload-format-up-to-firmware-version-4","text":"This format is not supported any more since firmware version V5.0.0! Please consider updating your device firmware using the Lobaro maintenance tool. Only a single massage format is used by the GPS Tracker, it has a fixed length of 15 bytes. This format uses the degrees with decimal minutes notation for the location. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). The table underneath explains the message format used. name type description example/range flags uint8 Status flags, for internal use 0 temp int16 Temperature inside the device in 1/10\u00b0C 246 \u2259 24.6 \u00b0C v_bat uint16 Current battery voltage in mV 3547 \u2259 3:547 V latitude deg int8 Whole degrees of the latitude -90 to 90","title":"Legacy upload format (up to Firmware Version 4)"},{"location":"lorawan-sensors/gps-lorawan/index.html#example","text":"As an illustration, if the received data would consist of the 15 bytes (hexencoded): 00 01 18 0D 69 35 1C 0F 71 09 38 02 4B 01 06 type example description flag 00 for internal use, ignore temp 01 18 0118 hex = 0280dec \u2259 280 d\u00b0C = 28.0 \u00b0C v_bat 0D 69 0D89 hex = 3465dec \u2259 3465mV = 3.465V latitude 35 1C 0F 71 35hex = 53dec \u2259 53\u00b0 1C hex = 28dec \u2259 28' 0F71 hex = 3953dec \u2259 0.3953' 351C0F71 \u2259 53\u00b028.3952' = 53.473255\u00b0 = 53\u00b028'23.718'' North longitude 09 38 02 4B 09 hex = 09dec \u2259 09\u00b0 38 hex = 56dec \u2259 56' 024B hex = 0587dec \u2259 0.0587' 0938024B \u2259 9\u00b056.0587' = 9.934 312\u00b0 = 9\u00b056'3.522'' East valid 01 01hex \u2259 valid measurement, could receive GPS signal sat 06 06hex = 06dec \u2259 Signal of 6 satellites received for measurement","title":"Example"},{"location":"lorawan-sensors/gps-lorawan/index.html#technical-characteristics","text":"Product Type name GPS-LoRaWAN Description LoRaWAN GPS Tracker RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with GPS standby and MEMS running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity","title":"Technical characteristics"},{"location":"lorawan-sensors/gps-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/gps-lorawan/index.html#the-things-network","text":"For Version 4.x, 5.x and 6.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } } // Wrapper for Lobaro Platform function Parse ( input ) { // Decode an incoming message to an object of fields. var b = bytes ( atob ( input . data )); var decoded = Decoder ( b , input . fPort ); return decoded ; } // Wrapper for Loraserver / ChirpStack function Decode ( fPort , bytes ) { return Decoder ( bytes , fPort ); } // Wrapper for Digimondo niota.io (uncomment only when used in niota) /* module.exports = function (payload, meta) { const port = meta.lora.fport; const buf = Buffer.from(payload, 'hex'); return Decoder(buf, port); }*/","title":"The Things Network"},{"location":"lorawan-sensors/gps-lorawan/index.html#pdf-documentation","text":"Product Dimensions (pdf) User Manual (en) CE Declaration of Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/gps-lorawan/firmware.html","text":"LoRaWAN GPS Tracker Firmware Downloads Hardware Revision 2.x Downloads : app-lorawan-gps-button-6.1.0.hex (hardware v2.x) [current release] app-lorawan-gps-button-6.0.3.hex (hardware v2.x) Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Hardware Revision 1.x Downloads : app-lorawan-gps-button-5.0.5.hex (hardware v1.x) app-lorawan-gps-button-4.0.9.hex (hardware v1.x) Info The LoRaWAN GPS data uplink data encoding has been changed between firmware 4.x (\"legacy format\") and 5.x. See the manual for details. Warning This hardware revision is no longer available for sale! Consider using the improved HW Rev 2.x. Changelog v6.1.0 - 09.12.2019 added new parameters to increase accuracy: maxHDOP & maxDataAfterFix v6.0.3 - 02.08.2019 fixed temperature sensor readout v6.0.2 - 22.07.2019 inverted powerpin for telit module (hardware v2.1) added nmea prefix GN ( Glonass+GPS ) to the parser v5.0.5 - 09.01.2019 Update LoRaWAN Stack Enable stepUp if needed by battery condition v5.0.4 - 15.11.2018 update board driver v5.0.3 - 15.11.2018 fix signed issue with longitude v5.0.0 - 26.10.2018 Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack v4.0.9 - 05.10.2018 Update LoRaWAN Stack v4.0.7 - 15.08.2018 Fixed bugs with some LoRaWAN Network providers v4.0.6 - 28.05.2018 Clear pending mems IRQ before sleep Updated internal state handling v4.0.4 - 20.03.2018 Disable mems in active mode v4.0.3 - 20.03.2018 compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm v4.0.2 - 23.02.2018 Fix lost GPS messages due to broken CRC checks v4.0.1 - 29.01.2018 Port to LoRa v3.2 Board v3.2 Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR v3.1 Enable buttons for sending (Reed contact connectors)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#lorawan-gps-tracker","text":"","title":"LoRaWAN GPS Tracker"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#firmware-downloads","text":"","title":"Firmware Downloads"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#hardware-revision-2x","text":"Downloads : app-lorawan-gps-button-6.1.0.hex (hardware v2.x) [current release] app-lorawan-gps-button-6.0.3.hex (hardware v2.x) Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Hardware Revision 2.x"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#hardware-revision-1x","text":"Downloads : app-lorawan-gps-button-5.0.5.hex (hardware v1.x) app-lorawan-gps-button-4.0.9.hex (hardware v1.x) Info The LoRaWAN GPS data uplink data encoding has been changed between firmware 4.x (\"legacy format\") and 5.x. See the manual for details. Warning This hardware revision is no longer available for sale! Consider using the improved HW Rev 2.x.","title":"Hardware Revision 1.x"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v610-09122019","text":"added new parameters to increase accuracy: maxHDOP & maxDataAfterFix","title":"v6.1.0 - 09.12.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v603-02082019","text":"fixed temperature sensor readout","title":"v6.0.3 - 02.08.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v602-22072019","text":"inverted powerpin for telit module (hardware v2.1) added nmea prefix GN ( Glonass+GPS ) to the parser","title":"v6.0.2 - 22.07.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v505-09012019","text":"Update LoRaWAN Stack Enable stepUp if needed by battery condition","title":"v5.0.5 - 09.01.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v504-15112018","text":"update board driver","title":"v5.0.4 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v503-15112018","text":"fix signed issue with longitude","title":"v5.0.3 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v500-26102018","text":"Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack","title":"v5.0.0 - 26.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v409-05102018","text":"Update LoRaWAN Stack","title":"v4.0.9 - 05.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v407-15082018","text":"Fixed bugs with some LoRaWAN Network providers","title":"v4.0.7 - 15.08.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v406-28052018","text":"Clear pending mems IRQ before sleep Updated internal state handling","title":"v4.0.6 - 28.05.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v404-20032018","text":"Disable mems in active mode","title":"v4.0.4 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v403-20032018","text":"compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm","title":"v4.0.3 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v402-23022018","text":"Fix lost GPS messages due to broken CRC checks","title":"v4.0.2 - 23.02.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v401-29012018","text":"Port to LoRa v3.2 Board","title":"v4.0.1 - 29.01.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v32","text":"Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR","title":"v3.2"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v31","text":"Enable buttons for sending (Reed contact connectors)","title":"v3.1"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html","text":"Humidity & Temperature LoRaWAN Sensor Overview Order number: 8000004 The Lobaro LoRaWAN Humidity Sensor AM2305-LoRaWAN is a battery powered radio transmitting sensor device that takes measurements at configurable intervals. Because of its low power consumption it can operate for multiple years with standard AA batteries. The LoRa radio technology allows it to take measurements in places that are hard to reach, and in its water prove casing it can be installed outdoors. The device uses a AM2305 digital relative humidity and temperature sensor probe (also known as RHT05 or DHT44). It is powered by the base device and communicates via a one-wire connection. Note Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device. The Device Operating the Humidity Sensor The RHT05 sensor probe must be attached to the device on the external socket. Insert two 1.5V AA batteries into the slots. When the device starts, its LED flashes once. If it does not start, check that your batteries are still good and inserted the correct way. You can refer to the picture above to check that everything is connected as it should be. When the device is set up correctly and running, put the lid on the base and fasten it from the back using the supplied screws. Watch out that the cables are save inside the box and do not get stuck in the casing, or you might damage the cables and allow water to enter the casing. This can cause damage to the device! Always close the lid so that the socket for the probe is on the opposing side of the antenna (picture above, sensor probe on the left, antenna on the right). This way there will be less interference on the antenna and you will get the best connection possible. Batteries The LoRaWAN Humidity Sensor default power supply consists of two series connected off- the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and LithiumIron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request, we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Options with permanent external power supply (230V, 9-24V, 5V USB) are also available on request. Installation The device must be fixed on a flat surface using the lateral mounting holes of the case. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices Warning Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Work Cycle graph LR; init(Init)-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Initial Phase This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered. Data Collection Phase During the Data Collection Phase is the device activates the sensor probe and reads measured humidity and temperature. There will be up to three attempts to get a correct reading. The communication contains a checksum value to detect data corruption between the probe and the main device. After data collection, the probe is deactivated again to save power. The device then enters the Data Transfer Phase. Data Transfer Phase During the Data Transfer Phase the Bridge uploads the sensor values to the LoRaWAN network. The message contains the information if the measurement was successful. In addition to the register data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. Sleep Phase After transferring all data packets the device enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until the cron expression given in the configuration triggers. When that happens, it enters the Data Collection Phase again Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration has been changed! Connecting the USB config adapter For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. System Parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Sensor configuration parameters The only parameter outside of the LoRaWAN-configuration is a Cron expression used to control the frequency of how often the device takes measurements. Name Type Description MeasureCron string Expression defining how often the device executes a measurement. This parameter is set using a cron expression. Please refer to chapter Cron expressions for an introduction. Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00 Configuration and battery life The time the LoRaWAN Humidity Sensor can operate on one set of batteries depends on the configuration of the device. Most of the time, the sensor remains in a sleep state, during which a very small amount of power is consumed (a current of about 20\u03bcA). Most power is used for sending messages via LoRa. One set of batteries lasts for about 30000 messages (depending on details like spreading factor and transmission power), so you can estimate the battery life for your configuration using the formula in equation 1. For example, if the device is set to send hourly updates, it will send 25 messages per day (including the status message). As illustrated in equation 2, the device should have a battery life of slightly over 3 years. LoRaWAN Data Upload Formats After reading from the sensor probe, the device starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the Humidity Sensor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). Since data packets sent over LoRa can be lost, a timestamp is added to every data packet. Timestamps are encoded as signed 40 bit big endian integers and express the number of seconds passed since 00:00:00 January 1 st , 1970 (UNIX timestamp). Timestamps are according to the devices internal clock, which might be set to an incorrect value. The timestamp always indicates the begin of the corresponding measurement phase. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network . Status Packet Port 1 - In order to provide some information about the health of the device itself, the Modbus Bridge sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 14 bytes. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 0, 4 \u2261 v1.0.4 fl uint8 3 Status flags, for internal use 0 temp int16 4-5 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C v_bat uint16 6-7 Battery voltage in mV 3547 \u2261 3.547V timestamp int40 8-12 Internal date/time at creation of the packet 1533055905 mod uint8 13 Operation mode the device runs 1 Data Packet Port 2 - The data packet is used to transmit the measured environmental values. It includes a timestamp and the information if the measurement was successful. The data packet has a fixed length of 10 bytes. Please remember that the timestamp is always in reference to the devices internal clock, which normally does not know the real time it is still usable to put data points into real time context if you take one reference and calculate the offset of the devices clock to real time. Figure 6 explains the bytes in inside the data package, table 4 explains the fields. name type bytes description example timestamp int40 0-4 UNIX timestamp for measurement 1533055905 err uint8 5 Error indicator. 0=success, 1=error 0 \u2261 success humidity uint16 6-7 Rel. humidity 1/10 % 318 \u2261 31.8 % temperature int16 8-9 Temperature in 1/10 \u00b0C -105 \u2261 -10.5 \u00b0C Sensor Specification Technical characteristics Product Type name AM2305-LoRaWAN Description LoRaWAN Humidity Sensor RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Humidity Sensor (Probe) Range 0%rH to 100%rH Accuracy \u00b12%rH (max \u00b15%rH) Resolution 0.1%rH Temperature Sensor (Probe) Range -40\u00b0C to 80\u00b0C Accuracy \u00b10.3\u00b0C Resolution 0.1\u00b0C Mechanical dimensions Size (Box) 114.3 mm x 59.3 mm x 26.8 mm Size (Probe) 100mm x 16mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Temperature and relative humidity measurements with external probe and LoRaWAN. PDF Documentation User Manual (en) CE Conformity Parser The Things Network (JavaScript) /** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"Manual"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#overview","text":"Order number: 8000004 The Lobaro LoRaWAN Humidity Sensor AM2305-LoRaWAN is a battery powered radio transmitting sensor device that takes measurements at configurable intervals. Because of its low power consumption it can operate for multiple years with standard AA batteries. The LoRa radio technology allows it to take measurements in places that are hard to reach, and in its water prove casing it can be installed outdoors. The device uses a AM2305 digital relative humidity and temperature sensor probe (also known as RHT05 or DHT44). It is powered by the base device and communicates via a one-wire connection. Note Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device.","title":"Overview"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-device","text":"","title":"The Device"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#operating-the-humidity-sensor","text":"The RHT05 sensor probe must be attached to the device on the external socket. Insert two 1.5V AA batteries into the slots. When the device starts, its LED flashes once. If it does not start, check that your batteries are still good and inserted the correct way. You can refer to the picture above to check that everything is connected as it should be. When the device is set up correctly and running, put the lid on the base and fasten it from the back using the supplied screws. Watch out that the cables are save inside the box and do not get stuck in the casing, or you might damage the cables and allow water to enter the casing. This can cause damage to the device! Always close the lid so that the socket for the probe is on the opposing side of the antenna (picture above, sensor probe on the left, antenna on the right). This way there will be less interference on the antenna and you will get the best connection possible.","title":"Operating the Humidity Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#batteries","text":"The LoRaWAN Humidity Sensor default power supply consists of two series connected off- the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and LithiumIron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request, we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Options with permanent external power supply (230V, 9-24V, 5V USB) are also available on request.","title":"Batteries"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#installation","text":"The device must be fixed on a flat surface using the lateral mounting holes of the case. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices Warning Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Installation"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#work-cycle","text":"graph LR; init(Init)-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read;","title":"Work Cycle"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-join-phase","text":"If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-collection-phase","text":"During the Data Collection Phase is the device activates the sensor probe and reads measured humidity and temperature. There will be up to three attempts to get a correct reading. The communication contains a checksum value to detect data corruption between the probe and the main device. After data collection, the probe is deactivated again to save power. The device then enters the Data Transfer Phase.","title":"Data Collection Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Bridge uploads the sensor values to the LoRaWAN network. The message contains the information if the measurement was successful. In addition to the register data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets.","title":"Data Transfer Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sleep-phase","text":"After transferring all data packets the device enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until the cron expression given in the configuration triggers. When that happens, it enters the Data Collection Phase again","title":"Sleep Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration has been changed!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#connecting-the-usb-config-adapter","text":"For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System Parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN Parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sensor-configuration-parameters","text":"The only parameter outside of the LoRaWAN-configuration is a Cron expression used to control the frequency of how often the device takes measurements. Name Type Description MeasureCron string Expression defining how often the device executes a measurement. This parameter is set using a cron expression. Please refer to chapter Cron expressions for an introduction.","title":"Sensor configuration parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#configuration-and-battery-life","text":"The time the LoRaWAN Humidity Sensor can operate on one set of batteries depends on the configuration of the device. Most of the time, the sensor remains in a sleep state, during which a very small amount of power is consumed (a current of about 20\u03bcA). Most power is used for sending messages via LoRa. One set of batteries lasts for about 30000 messages (depending on details like spreading factor and transmission power), so you can estimate the battery life for your configuration using the formula in equation 1. For example, if the device is set to send hourly updates, it will send 25 messages per day (including the status message). As illustrated in equation 2, the device should have a battery life of slightly over 3 years.","title":"Configuration and battery life"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-data-upload-formats","text":"After reading from the sensor probe, the device starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the Humidity Sensor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). Since data packets sent over LoRa can be lost, a timestamp is added to every data packet. Timestamps are encoded as signed 40 bit big endian integers and express the number of seconds passed since 00:00:00 January 1 st , 1970 (UNIX timestamp). Timestamps are according to the devices internal clock, which might be set to an incorrect value. The timestamp always indicates the begin of the corresponding measurement phase. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network .","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#status-packet","text":"Port 1 - In order to provide some information about the health of the device itself, the Modbus Bridge sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 14 bytes. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 0, 4 \u2261 v1.0.4 fl uint8 3 Status flags, for internal use 0 temp int16 4-5 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C v_bat uint16 6-7 Battery voltage in mV 3547 \u2261 3.547V timestamp int40 8-12 Internal date/time at creation of the packet 1533055905 mod uint8 13 Operation mode the device runs 1","title":"Status Packet"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-packet","text":"Port 2 - The data packet is used to transmit the measured environmental values. It includes a timestamp and the information if the measurement was successful. The data packet has a fixed length of 10 bytes. Please remember that the timestamp is always in reference to the devices internal clock, which normally does not know the real time it is still usable to put data points into real time context if you take one reference and calculate the offset of the devices clock to real time. Figure 6 explains the bytes in inside the data package, table 4 explains the fields. name type bytes description example timestamp int40 0-4 UNIX timestamp for measurement 1533055905 err uint8 5 Error indicator. 0=success, 1=error 0 \u2261 success humidity uint16 6-7 Rel. humidity 1/10 % 318 \u2261 31.8 % temperature int16 8-9 Temperature in 1/10 \u00b0C -105 \u2261 -10.5 \u00b0C","title":"Data Packet"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sensor-specification","text":"","title":"Sensor Specification"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#technical-characteristics","text":"Product Type name AM2305-LoRaWAN Description LoRaWAN Humidity Sensor RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Humidity Sensor (Probe) Range 0%rH to 100%rH Accuracy \u00b12%rH (max \u00b15%rH) Resolution 0.1%rH Temperature Sensor (Probe) Range -40\u00b0C to 80\u00b0C Accuracy \u00b10.3\u00b0C Resolution 0.1\u00b0C Mechanical dimensions Size (Box) 114.3 mm x 59.3 mm x 26.8 mm Size (Probe) 100mm x 16mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Consider using the latest firmware on your hardware See available firmware downloads","title":"Technical characteristics"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#target-measurement-purpose","text":"Temperature and relative humidity measurements with external probe and LoRaWAN.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#pdf-documentation","text":"User Manual (en) CE Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-things-network-javascript","text":"/** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"The Things Network (JavaScript)"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html","text":"Humidity & Temperature LoRaWAN Sensor Firmware Downloads: app-lorawan-humidity-0.0.3.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog 0.0.3 Initial public release","title":"Firmware & Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-humidity-0.0.3.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#003","text":"Initial public release","title":"0.0.3"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html","text":"LoRaWAN Modbus Gateway The Lobaro LoRaWAN Modbus Gateway is a LoRaWAN Gateway with integrated LoRaWAN Network Server providing sensor data via Modbus. Hardware Components LoRaWAN Gateway External SSD for storage USB-Modbus Adapter The internal SD-Card is write protected. All variable data is stored on the external SSD to avoid SD-Card damage over time. Software Components Chirpstack Network Server Semtech Packet Forwarder Chirpstack Gateway Bridge Chirpstack Network Server Chirpstack Application Server Postgres Redis Lobaro Modbus Server Usually you will not need to change anything inside the Chirpstack Application Server. All devices are managed by the Lobaro Modbus Server. Remote access Per default the gateway obtains the IP address via DHCP. If configured with a fixed IP address, the gateway has a label with the configured IP address and subnet. The gateway can be accessed via SSH on port 22. Default login credentials are provided by Lobaro. Lobaro Modbus Server The Lobaro Modbus Server ( lobaro-modbus-server ) is responsible for fetching data from the local LoRaWAN Network Server and provides received data via modbus. To change any filed on the SD Card (including all config files) you need to execute the script: ~/enableWriteAccess.sh To disable write access, restart the gateway or execute: ~/disableWriteAccess.sh For editing files vim is installed. Open or change configuration of the Lobaro Modbus Server: sudo vim /etc/lobaro-modbus-server/lobaro-modbus-server.yml After editing the configuration lobaro-modbus-server must be restarted: sudo systemctl restart lobaro-modbus-server Check the status with sudo systemctl status lobaro-modbus-server Check the logs with sudo journalctl --no-pager -e -u lobaro-modbus-server Debugging Beside checking the logs, you can also analyze the files in the dataDir (see config). There are two files that help writing the config and checking the results. device-data.json - contains raw json received from Chirpstack. Can be used to verify mapping[].register.value configuration. register-map.json - contains all register values provided via modbus. All values are formatted as int . Example device-data.json : { \"0000000000000000-1\": { \"adr\": true, \"applicationID\": \"1\", \"applicationName\": \"default\", \"data\": \"AAMEAOQN1g==\", \"devEUI\": \"0000000000000000\", \"deviceName\": \"0000000000000000\", \"fCnt\": 1, \"fPort\": 1, \"object\": { \"temp\": 22.8, \"vBat\": 3.542, \"version\": \"v0.3.4\" }, \"rxInfo\": [ { \"gatewayID\": \"0000000000000000\", \"loRaSNR\": 8.8, \"location\": { \"altitude\": 0, \"latitude\": 0, \"longitude\": 0 }, \"name\": \"default\", \"rssi\": -36, \"uplinkID\": \"ce2e086a-d747-4813-9428-b7a4a45abcc8\" } ], \"txInfo\": { \"dr\": 0, \"frequency\": 868300000 } } } Example register-map.json : { \"Register\": { \"100\": { \"Val\": 0, \"Type\": 1, \"UpdatedAt\": \"2020-02-07T13:44:03.39750918Z\" } } } Configuration file Example config: # The application stores persistent data at this path dataDir: /mnt/ssd/var/data/lobaro-modbus-server/ # Chipstack configuration. Required to manage configured LoRaWAN devices. chirpstack: server: http://localhost:8080 broker: localhost appId: 1 username: admin password: admin # Modbus configuration. # Serial mode is fixed at: 8 Data bits, Even Parity, 1 Stop bit (8E1) modbus: baud: 19200 slaveId: 1 port: /dev/ttyUSB0 # Mapping from LoRaWAN Sensors to Modbus Registers mapping: # LoRaWAN Sensor parameters - devEUI: 0000000000000000 appKey: 00000000000000000000000000000000 # Chirpstack Device Profile to use. Includes the Payload Parser. devProfile: lobaro-environment # Register mapping for this device # One device can fill any number of registers. # The server will check for overlapping definitions on start. register: # Modbus Address (do NOT prefix with 0, else it's octal) - addr: 1 # The value to be mapped. # Usually the value is taken from the Chirpstack Parser result JSON # and can be selected via JSON Path as handled by https://github.com/tidwall/gjson # There are some special values: # @age - age of last update in minutes (for any register of this device) # @now - Current time as Unix Timestamp value: \"@age\" # age of last update in minutes (for any register of this device) # Data type of the value. Default byte order is LittleEndian # Supported types are: int16, uint16 (more will come in future versions) type: int16 # The value is only for messages on the specified port, 0 for \"every\". Default: 0 port: 0 # The register value is multiplied with the given factor, 0 is irgnored. Default: 1 factor: 1 - addr: 2 port: 1 # status packet value: \"object.vBat\" type: int16 factor: 1000 - addr: 3 port: 2 value: \"object.temperature\" type: int16 factor: 10 - addr: 4 port: 2 value: \"object.humidity\" type: int16 factor: 10 - addr: 5 port: 2 value: \"object.pressure\" type: int16 factor: 10 - addr: 6 port: 2 value: \"rxInfo.0.rssi\" type: int16 - addr: 7 port: 2 value: \"txInfo.dr\" type: int16 # A second device as example - devEUI: 0000000000000000 appKey: 00000000000000000000000000000000 devProfile: lobaro-one-wire register: - addr: 100 value: \"@age\" # age of last update in minutes (for any register of this device) type: int16 - addr: 101 port: 1 # status packet value: \"object.vBat\" type: int16 factor: 1000 - addr: 102 port: 2 value: \"object.sensors.0.temp\" type: int16 factor: 10 - addr: 103 port: 2 value: \"rxInfo.0.rssi\" type: int16 - addr: 104 port: 2 value: \"txInfo.dr\" type: int16 Chirpstack The gateway uses a local Chirpstack server. Access management interface on https://<gw-ip>:8080 . Documentation can be found on Chripstack.io . For each type of device the lobaro-modbus-server needs to reference a Device Profile. See: Chirpstack Device Profile Management . The Device Profile of each LoRaWAN device must be referenced by its name or UUID in the lobaro-modbus-server.yml config file. Gateway administration When ever any file on the SD-Card need to change make sure to execute ~/enableWriteAccess.sh Change password Login via SSH (see: Remote access ) passwd Change IP address sudo vim /etc/network/interfaces pi@LoRaGateway:~ $ cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Please note that this file is written to be used with dhcpcd # For static IP, consult /etc/dhcpcd.conf and 'man dhcpcd.conf' # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d auto lo iface lo inet loopback # DHCP (Default, comment line to disable DHCP) iface eth0 inet manual # Fixed IP (Uncomment to enable or use /etc/dhcpcd.conf) #auto eth0 #iface eth0 inet static # address 10.0.0.42/24 # gateway 10.0.0.1","title":"Manual"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#lorawan-modbus-gateway","text":"The Lobaro LoRaWAN Modbus Gateway is a LoRaWAN Gateway with integrated LoRaWAN Network Server providing sensor data via Modbus.","title":"LoRaWAN Modbus Gateway"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#hardware-components","text":"LoRaWAN Gateway External SSD for storage USB-Modbus Adapter The internal SD-Card is write protected. All variable data is stored on the external SSD to avoid SD-Card damage over time.","title":"Hardware Components"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#software-components","text":"Chirpstack Network Server Semtech Packet Forwarder Chirpstack Gateway Bridge Chirpstack Network Server Chirpstack Application Server Postgres Redis Lobaro Modbus Server Usually you will not need to change anything inside the Chirpstack Application Server. All devices are managed by the Lobaro Modbus Server.","title":"Software Components"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#remote-access","text":"Per default the gateway obtains the IP address via DHCP. If configured with a fixed IP address, the gateway has a label with the configured IP address and subnet. The gateway can be accessed via SSH on port 22. Default login credentials are provided by Lobaro.","title":"Remote access"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#lobaro-modbus-server","text":"The Lobaro Modbus Server ( lobaro-modbus-server ) is responsible for fetching data from the local LoRaWAN Network Server and provides received data via modbus. To change any filed on the SD Card (including all config files) you need to execute the script: ~/enableWriteAccess.sh To disable write access, restart the gateway or execute: ~/disableWriteAccess.sh For editing files vim is installed. Open or change configuration of the Lobaro Modbus Server: sudo vim /etc/lobaro-modbus-server/lobaro-modbus-server.yml After editing the configuration lobaro-modbus-server must be restarted: sudo systemctl restart lobaro-modbus-server Check the status with sudo systemctl status lobaro-modbus-server Check the logs with sudo journalctl --no-pager -e -u lobaro-modbus-server","title":"Lobaro Modbus Server"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#debugging","text":"Beside checking the logs, you can also analyze the files in the dataDir (see config). There are two files that help writing the config and checking the results. device-data.json - contains raw json received from Chirpstack. Can be used to verify mapping[].register.value configuration. register-map.json - contains all register values provided via modbus. All values are formatted as int . Example device-data.json : { \"0000000000000000-1\": { \"adr\": true, \"applicationID\": \"1\", \"applicationName\": \"default\", \"data\": \"AAMEAOQN1g==\", \"devEUI\": \"0000000000000000\", \"deviceName\": \"0000000000000000\", \"fCnt\": 1, \"fPort\": 1, \"object\": { \"temp\": 22.8, \"vBat\": 3.542, \"version\": \"v0.3.4\" }, \"rxInfo\": [ { \"gatewayID\": \"0000000000000000\", \"loRaSNR\": 8.8, \"location\": { \"altitude\": 0, \"latitude\": 0, \"longitude\": 0 }, \"name\": \"default\", \"rssi\": -36, \"uplinkID\": \"ce2e086a-d747-4813-9428-b7a4a45abcc8\" } ], \"txInfo\": { \"dr\": 0, \"frequency\": 868300000 } } } Example register-map.json : { \"Register\": { \"100\": { \"Val\": 0, \"Type\": 1, \"UpdatedAt\": \"2020-02-07T13:44:03.39750918Z\" } } }","title":"Debugging"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#configuration-file","text":"Example config: # The application stores persistent data at this path dataDir: /mnt/ssd/var/data/lobaro-modbus-server/ # Chipstack configuration. Required to manage configured LoRaWAN devices. chirpstack: server: http://localhost:8080 broker: localhost appId: 1 username: admin password: admin # Modbus configuration. # Serial mode is fixed at: 8 Data bits, Even Parity, 1 Stop bit (8E1) modbus: baud: 19200 slaveId: 1 port: /dev/ttyUSB0 # Mapping from LoRaWAN Sensors to Modbus Registers mapping: # LoRaWAN Sensor parameters - devEUI: 0000000000000000 appKey: 00000000000000000000000000000000 # Chirpstack Device Profile to use. Includes the Payload Parser. devProfile: lobaro-environment # Register mapping for this device # One device can fill any number of registers. # The server will check for overlapping definitions on start. register: # Modbus Address (do NOT prefix with 0, else it's octal) - addr: 1 # The value to be mapped. # Usually the value is taken from the Chirpstack Parser result JSON # and can be selected via JSON Path as handled by https://github.com/tidwall/gjson # There are some special values: # @age - age of last update in minutes (for any register of this device) # @now - Current time as Unix Timestamp value: \"@age\" # age of last update in minutes (for any register of this device) # Data type of the value. Default byte order is LittleEndian # Supported types are: int16, uint16 (more will come in future versions) type: int16 # The value is only for messages on the specified port, 0 for \"every\". Default: 0 port: 0 # The register value is multiplied with the given factor, 0 is irgnored. Default: 1 factor: 1 - addr: 2 port: 1 # status packet value: \"object.vBat\" type: int16 factor: 1000 - addr: 3 port: 2 value: \"object.temperature\" type: int16 factor: 10 - addr: 4 port: 2 value: \"object.humidity\" type: int16 factor: 10 - addr: 5 port: 2 value: \"object.pressure\" type: int16 factor: 10 - addr: 6 port: 2 value: \"rxInfo.0.rssi\" type: int16 - addr: 7 port: 2 value: \"txInfo.dr\" type: int16 # A second device as example - devEUI: 0000000000000000 appKey: 00000000000000000000000000000000 devProfile: lobaro-one-wire register: - addr: 100 value: \"@age\" # age of last update in minutes (for any register of this device) type: int16 - addr: 101 port: 1 # status packet value: \"object.vBat\" type: int16 factor: 1000 - addr: 102 port: 2 value: \"object.sensors.0.temp\" type: int16 factor: 10 - addr: 103 port: 2 value: \"rxInfo.0.rssi\" type: int16 - addr: 104 port: 2 value: \"txInfo.dr\" type: int16","title":"Configuration file"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#chirpstack","text":"The gateway uses a local Chirpstack server. Access management interface on https://<gw-ip>:8080 . Documentation can be found on Chripstack.io . For each type of device the lobaro-modbus-server needs to reference a Device Profile. See: Chirpstack Device Profile Management . The Device Profile of each LoRaWAN device must be referenced by its name or UUID in the lobaro-modbus-server.yml config file.","title":"Chirpstack"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#gateway-administration","text":"When ever any file on the SD-Card need to change make sure to execute ~/enableWriteAccess.sh","title":"Gateway administration"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#change-password","text":"Login via SSH (see: Remote access ) passwd","title":"Change password"},{"location":"lorawan-sensors/lorawan-modbus-gateway/index.html#change-ip-address","text":"sudo vim /etc/network/interfaces pi@LoRaGateway:~ $ cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Please note that this file is written to be used with dhcpcd # For static IP, consult /etc/dhcpcd.conf and 'man dhcpcd.conf' # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d auto lo iface lo inet loopback # DHCP (Default, comment line to disable DHCP) iface eth0 inet manual # Fixed IP (Uncomment to enable or use /etc/dhcpcd.conf) #auto eth0 #iface eth0 inet static # address 10.0.0.42/24 # gateway 10.0.0.1","title":"Change IP address"},{"location":"lorawan-sensors/modbus-lorawan/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v1.x.x (since 2019-10-16) This is the latest version. For older revisions please refer to the version overview . This version has a different upload format than older versions! If you are using 0.3.x firmware, please see the 0.3.x Manual . If you are updating to this firmware, be aware that you will have to update your configuration and the parser in your backend. Key Features LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Configuration via USB or remotely via LoRaWAN downlink ModBus ASCII and RTU modes supported Readout of ModBus Coils, Discrete Inputs, Input Registers and Holding Registers ModBus dialog mode via USB for easy configuration testing Coexistence with 2 nd Modbus Master possible (bus sharing, Listen before talk) Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via LoRaWAN uplinks. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation. Supported Devices The Lobaro Modbus LoRaWAN Bridge works with all devices that act as a Modbus Client using RTU or ASCII (Modbus TCP is not supported). Some devices that have been used successfully with the Bridge: Device Type Manufacturer More information Octave Ultrasonic Meter Water meter Arad Group External Link ECL Controller Heat/Hot Water Regulation Danfoss External Link UMD 97 Smart Grid Power Meter PQ Plus External Link (German) DRS458DE Power Meter B+G E-Tech GmbH External Link Product variants The LoRaWAN Modbus bridge can be ordered in two standard variants. For even more customizations options see Hardware Variants overview. Variant battery powered LoRaWAN Modbus Bridge (XH battery connector, IP67 housing), Order number: 8000041 ER34615 (3.6V Battery, XH Connector, 0.2A), Order number: 3000169 Variant external powered LoRaWAN Modbus Bridge (ext. Power, Din-Rail, no housing), Order number: 8000043 DR-15-5 DIN-Rail power supply 5V, Order number: 3000006 RK 4/12-L DIN-Rail Housing, Order number: 3000005 Data Sheet with dimensions (PDF) Further customization Options The product variants shown above are the standard variants. Other power supply options & housing are available on request External antenna AA batteries NB-IoT instead of LoRaWAN Contact us via support@lobaro.de if you need our offer for a special variant. Modbus Introduction Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus . Quick Start Guide Please refer to the rest of this documentation for a save and proper use of the Modbus Bridge. This Quick Start Guide can only show you basic operations. It illustrates reading a single value from one Slave Device. Connect the Modbus Bridge to your Modbus Slave Device using the RS485 connection using a twisted pair cable: A to A , B to B , and GND to GND ( GND is not strictly necessary but enhances the connection. Not all slave devices supply a GND connector). Connect the Modbus Bridge to a computer using the Lobaro Configuration Adapter and the Lobaro Maintenance Tool . Synchronise the LoRaWAN configuration parameters between the Bridge and your Network Server. Make sure the Bridge is in reach of a Gateway attached to your Network Server. Set the Modbus Parameters according to your Slave Device (ASCII/RTU, Baud, Data Length, Stop Bits, Parity). Set MbCmd to the Modbus Command to read the register you need (see below). Save the configuration and switch to the Log tab. You should see the device requesting the data and uploading it via LoRaWAN. MbCmd must contain the Modbus Command the Bridge will execute. The command is entered in Hex and without any checksums and is 6 bytes long (12 hexdigits). The default value is 010300000003 , it consists of 4 parts: 01 , 03 , 0000 , 0003 01 Address of the Slave Device. 1 byte: often 01 new devices 03 What kind of Modbus Register to read. 1 byte. 03 stand for Holding Register . 0000 Number/address of the first register to read. 2 bytes. Many devices have some value to read out at 0000 . 0003 Number of consecutive registers to read from the first register. 2 bytes. This would read the registers #0, #1, and #2 in one command. The format used for MbCmd is conforming to the Modbus Standard. See Configurations/Modbus Commands for a description and Examples for some more advance examples. The Modbus Bridge has a Dialog Mode that lets you try out Modbus Commands interactively which helps getting used to the syntax and helps you in trying out your slave devices. Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)==>check(Test Reading); check==>join(LoRaWAN Join); join==>read(Data Collection); read==>send(Data Transfer); send==>sleep(\"Sleep\"); sleep==>|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading After verifying configuration, the Bridge executes all Modbus Commands stored once without uploading the results but logging them only to the console. This makes it easy to verify all Modbus Slaves are reachable and their registers can be read. Connect your computer to the Bridge using the Lobaro Config Adapter and check the output using the Lobaro Maintenance Tool. The device will continue with LoRaWAN Join to connect to the Network (whether the test reading was successful or not does not change this). LoRaWAN Join The Bridge tries to connect to the LoRaWAN Network. The Details depend on the device's configuration (OTAA vs. ABP, optional Time synchronisation). Unless ABP is used, the Bridge will remain in this state until joining succeeds. It will repeat to send Join requests with decreasing frequency. After successfully attaching it enters Data Collection for the first time and starts the normal operation cycle. Data Collection The Bridge sends all Modbus Commands from the Configuration on the Bus and collects the answers (or lack thereof). Data Transfer The collected Modbus Responses are uploaded via LoRaWAN. This can take multiple upload messages depending on the amount of data collected. Once a day a status message is also uploaded, giving some information about the state of the Bridge itself. If many messages are uploaded this can take a long time. At least one message is uploaded during this state. When all data is uploaded, the device goes to Sleep . Sleep Between activations the device enters a very power efficient sleep mode. It stays dormant until the time specified by the Cron expression, when it changes back to Data Collection . Configuration The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter . Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages , see Downlinks description. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values MbProt Modbus-Protocol to use RTU . ASCII MbBaud UART Baud rate 9600 , 19200 , 38400 , ... MbDataLen UART data length 7 , 8 , 9 MbStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) MbPar UART parity NONE , EVEN , ODD MbCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes MbCmd List of Modbus Commands (see below). 010300010003 PlFmt Uplink Format 1 , 2 , or 3 , see Payload Formats EnDL Enable Downlinks true = enable sending Modbus Commands via Downlink DialogMode Enable Dialog Mode true = set the Bridge to Dialog Mode LbtDuration Listen-before-talk Duration 0 = disables, 1 - 3600 = seconds of lbt duration LbtSilence Listen-before-talk Silence 0 = disabled, 1 - 3600 seconds of silence needed \u2020 See also our Introduction to Cron expressions . Modbus Commands Whenever the cron expression given in the configuration value MbCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter MbCmd ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set MbCmd to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 51 byte message limit this only leaves 39 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be split and uploaded using multiple LoRaWAN messages. Your backend will need to those parts back together. Any message that is the continuation of an earlier uplink will be sent using port 5 (see Split Messages ). For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at the examples . Listen-Before-Talk If you want to use the Lobaro Modbus Bridge to read out values on an installation that already has an active Modbus Master, you will run into conflicts, because the Bridge acts as a Master. Normally only a single Master device is allowed on a Modbus installation. The Bridge supports a Listen-Before-Talk feature, that makes it possible to be used alongside a second Master Device (under certain conditions). If your other Master Device has periods of non-communication that are long enough, you can configure the Bridge to wait for those pauses before starting it's own requests: When Listen-Before-Talk is activated, the Bridge does not immediately start sending on the Bus when it normally would. Instead it starts listening on the Bus until the other Master starts talking and then waits for silence to detect when the other Master just finished communicating. Only then does it send it's requests. The Bridge waits for a maximum of LbtDuration seconds for the other Master to start communicating. Then it waits for a period of silence that lasts at least LbtSilence seconds to decide that the other master has completed its work and is now in pause. So if, for example, your other Master has a work interval of 2 minutes and is active for about 30 seconds without longer pauses, you could set LbtDuration to 130 (10 seconds added as a buffer), and LbtSilence to 15 (make sure the value is longer than the timeout your other master has). You will have to know exactly how your other Master acts to setup this feature. If you set either of LbtDuration or LbtSilence to 0 , you will deactivate Listen-Before-Talk completely (it is deactivated by default). Payload formats The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Uplink 5 Continuation of Responses that do not fit in a single Uplink. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document. Uplink Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 uint16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C Data messages Data messages contain responses to Modbus Commands received by the Bridge. The Bridge supports multiple Payload formats for different use cases. The format is selected by the configuration parameter PlFmt : 1 : Verbose payload format (port 3) 2 : Compact payload format with time (port 6) 3 : Compact payload format without time (port 7) Verbose payload format The verbose payload format ( PlFmt = 1 ) is the standard setting of the Bridge. It is designed to be very versatile (it uploads the complete Response sent by the Slave Devices, so reading registers as well as writing registers are both supported). It contains all information you need to know the register and the slave device your data is coming from. You do not need to know the exact configuration of your devices in your backend to be able to parse the data. This is convenient when you have man Modbus Bridges with different configuration in the field. This payload format is also good in communicating error conditions in case the executed Modbus Commands fail. The trade off is overhead in the transmission. If you need to get a lot of data uploaded often, this could be a problem for you with the limited LoRaWAN bandwidth. If this is a problem for your use case, you should take a look at the compact data formats. Data messages using the verbose payload format are uploaded on port 3. Every message starts with a 5 byte timestamp (UNIX timestamp as big endian int40 , see timestamps in our LoRaWAN devices ) for more information). The timestamp is followed by one or more responses of varying length. Each of the responses starts with a single byte ( uint8 ) indicating the length of its payload ( len ) followed by that many bytes of payload. The payload consists of the raw Modbus response as sent by the Slave Device followed by 3 additional bytes: the first register/coil as uint16 (big endian) and the number of registers/coils as uint8 taken from the executed command. The following tables visualise the message structure. See the Examples Section for some sample data messages explained down to the individual bytes. We also provide a Reference Decoder in JavaScript that can read the format. The timestamp in the message is the wakeup time when the device was activated by the cron expression in MbCron (using the devices internal clock). The Modbus Response in the message in addition with the start register/coil and the register/coil count makes it possible to know which registers/coils where exactly read/written, what kind they were, and the address of the device. For Modbus Commands that do not have a register/coil count (like function 5, forcing a single coil), or for those that do not contain a start register/coil (e.g. funtion 7, reading exception status), the contents of the additional fields start register and/or count are undefined. The payload format used only a single byte for the count value, so if you are reading/writing more than 255 coils, the higher byte will be cut off. The Bridge puts as many responses as in one message as possible (without changing the order of responses and respecting the maximal message size of the current Spreading Factor ). If the responses do not fit into a single message it will upload as many messages as needed. When a single response is too long to fit in a message, the response will be split up over multiple messages and will need to be reassembled in the backend. See Split Messages for instructions on how to do that and how to prevent splitting. Structure of a message on port 3: Bytes | 0 . 1 . 2 . 3 . 4 | 5 ... | ... | ... | ... | +-------------------+------------+------------+-----+------------+ Part | timestamp | response 1 | response 2 | ... | response n | Structure of a response part on port 3: Bytes | 0 | 1 .. len-3 | len-2 . len-1 | len | +-----+-----------------+----------------+-------+ Field | len | Modbus response | start register | count | Compact payload format The compact payload format transmits only the payload bytes of the received responses. This format requires less bytes to upload the information than the verbose payload format, allowing more data to be read out per hour, but it requires a customised backend that knows the exact configuration of the Bridge. This format only makes sense for reading registers/coils. Error conditions can not be communicated very well using this format. For PlFmt = 2 the data messages are uploaded on port 6. The messages start with a 5 byte timestamp (same as in verbose payload format). The timestamp is followed by only the payload bytes of the Modbus Responses triggerd by the configuration parameter MbCmd . The bytes are just appended to the message after another, in the order of the Commands in MbCmd . You will need to know the exact value of MbCmd of each of your Bridges to make sense of the data. When using this payload format the Remote Configuration is very helpful: it can be used to read the value of configuration parameters over LoRaWAN without physical access to the device (it can also change those values). If a Modbus command fails to execute (for example if the Slave device has a power outage or if the bus is disconnected), the data bytes of that command are all set to 0xff . This could also be a valid value (depending on the nature of your data), but there is no other channel to communicate failure. 0xff is easy to spot and 0xffff is relative unlikely to be a real value for Modbus registers. When using the Bridge with PlFmt = 3 data messages are uploaded on port 7. The payload format is identical to the payload format for PlFmt = 3 only without the timestamp (to save another 5 bytes in case you do not care about the time of your readings). Split messages LoRaWAN has a very limited message size. For high spreading factors this goes as low as 51 bytes. If a Modbus Response is too long to fit into a single message, the Modbus Bridge will split it up into multiple messages that are sent in sequence. Patching messages back together requires a more complex backend that can save a state. A simple parse on The Things Network will not be able to do that. If your backend cannot handle this process, you can work around it by configuring your MbCmd in a way that no single response will be longer than 45 bytes (by reading out a maximum of 24 consecutive registers in a single command). If you have a configuration that results in longer Responses you should make sure your backend can handle split Responses as described here. If a Response is too long to fit into a single message, the Bridge puts as many bytes as possible into the message. You can tell by the length of the message and the length of the Modbus Response indicated in the message, that this is only the first part of a message. This first part will be upload normally on port 3 (or port 4, if triggered by a downlink). Following the first part, the Bridge will upload the remaining data in messages sent on port 5. For very long Responses and high Spreading Factors, the Response could be split into up to 6 messages. You can use the frame counter and the indicated length to verify if you receive all parts. Modbus Responses that are split up will never be packed together with other Responses. The Examples section contains an illustration of a split up Response. Downlink Please be aware that Downlinks in LoRaWAN can only be received when the device sends an Uplink, or when the device operates in Class C mode. See Uplinks and Downlinks in our LoRaWAN page for more information. Modbus Commands Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length as uint8 . The Modbus Commands must be sent as raw bytes and without any check digits. The Responses to the Commands are sent as Uplink messages on port 4. The payload format on port 4 is the same as on port 3 (see Data messages ), only that the timestamp indicates the time the downlink was received by the Bridge. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, it creates an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command, but it will be performed for any sequence of bytes you send. Commands must have a length of at least 3 bytes. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly from your computer or using the Dialog Mode , to reduce possible error sources. Refer to Examples to see some Downlinks and their answers. Remote Configuration The Modbus Bridge supports configuration via LoRaWAN Downlinks. It receives commands on port 128. See Remote Configuration in our LoRaWAN page for instructions on how to use it. Examples This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings, while on the air they are sent as raw bytes. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus . Uplinks triggered by configuration The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 MbCmd = '010300000003' # Example resulting Uplink after successful readout Up, Port 3: '005d1698fd0c0103061234567890ab000003' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '0c' -> first Response is 12 bytes long '0103061234567890ab000003' 12 bytes modbus response: '01' -> slave device with address 1 '03' -> function 3 = read Holding Register, success '06' -> 6 bytes of data in Response following '1234567890ab' -> 6 bytes of data '0000' -> start reading at register 0 '03' -> read 3 consecutive registers # Example resulting Uplink after failing readout Up, Port 3: '005d1698fd0601830b000003' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '06' -> first Response is 6 bytes long '01830b000003' 3 bytes modbus response: '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register, failed '0b' -> error code 11: \"Gateway Target Device Failed to Respond\" '0000' -> start reading at register 0 '03' -> read 3 consecutive registers Example A2: Read coils 1000-1019 of device 32 MbCmd = '200103e80014' # Example resulting Uplink Up, Port 3: '005d1698fd 09 200103f1041a03e814' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '09' -> first Response is 9 bytes long '200103f1041a03e814' 9 bytes of response: '20' -> slave device with address 32 '01' -> read coils, success '03' -> 3 bytes of data 'f1041a' -> 20 bits of data packed into 3 bytes '03e8' -> start reading at coil 1000 '14' -> read 20 consecutive coils Example A3: Read two devices MbCmd = '0a0300010005,3001ea600020' # Example resulting Uplink Up, Port 3: '005d1698fd100a030a111122223333444455550001050a30010412345678ea6020' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '10' -> first Response is 16 bytes long '0a030a11112222333344445555000105' 16 bytes of Response '0a' -> slave device with address 10 '03' -> read Holding Registers, success '0a' -> 10 bytes of data following '11112222333344445555' 10 bytes of data '0001' -> start reading at register 1 '05' -> read 5 registers '0a' -> second Response is 10 bytes long '30010412345678ea6020' 10 bytes of Response '30' -> slave device with address 48 '01' -> read Coils, success '04' -> 4 bytes of data following '12345678' -> 32 bits of data packed in 4 bytes 'ea60' -> start at coil 60000 '20' -> read 32 coils Example A4: Split up messages MbCmd = '010300010020' # Command reads 32 consecutive registers resulting in 64 bytes payload # Example resulting Uplinks for a Spreading Factor of 12 with 51 bytes of payload per message Up 1, Port 3: '005d1698fd46010340000100020003000400050006000700080009000a000b000c000d000e000f001000110012001300140015' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '46' -> first Response is 70 bytes long since the remainder of the message does not contain 70 bytes, you know there must be an additional part comming Up 2, Port 5: '0016001700180019001a001b001c001d001e001f00200120' This contains the rest of the message. Appended to the privious message, it adds up to the correct number of bytes. TODO: examples for compact payload format All this examples use the verbose payload format. We need to add examples using the compact format. Uplinks triggered by Downlink Commands Example B1: Read single Input Register by Downlink Down, Port 4: '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4, read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up, Port4: '004b3dd67508180402abcd010001' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '08' -> first Response is 8 bytes long '180404abcd010001' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register, success '02' -> 2 bytes of data following 'abcd' -> 2 bytes of data '0100' -> start at register 256 '01' -> read 1 register Example B2: Writing holding registers on multiple devices Down, Port 4: '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6, write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16, write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up, Port 4: '004b3dd67506a1860200000006a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '06' -> first Response is 3 bytes long 'a18602000000' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter, failed '02' -> error code 2: \"Illegal Data Address\" '0000' -> start register not used (undefined) '00' -> count not used (undefined) '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> write multiple Holding Registers, success 'a001' -> start at register 40961 '0004' -> 4 registers to write Dialog Mode The Modbus Bridge has an additional interactive Operation Mode that can help finding the correct Modbus Commands for normal operations. You enter it by setting the Configuration Parameter DialogMode to true using the Lobaro Configuration Adapter and the Lobaro Maintenance Tool. After saving the configuration the device will reboot and enter Dialog Mode. To change the device back to normal operations change the Parameter DialogMode back to false and save the config. In Dialog Mode the Bridge will not connect to the LoRaWAN Network and it will not execute any operations on its own. It will wait for user input over the Lobaro Maintenance Tool. On the tab showing the device's log messages there is an input field labeled Send via UART . You can enter Modbus commands here, followed by pressing return. The Bridge will send the commands over the bus just as it would if it got them from configuration. The response will be observable in the Log. The Commands must be entered as hex strings without any check sums. The Modbus parameters (UART configuration and Modbus Mode RTU/ASCII) are taken from the configuration just as during normal operations. The Bridge operates as an interactive Modbus master device that can be used for diagnosing Modbus installations or executing a few commands on a device that has no permanent Modbus connection. In Dialog Mode the device does not enter any sleep states. If you leave the Modbus Bridge in DialogMode while it is powered by battery it will quickly drain the battery and run out of power. Dialog Mode Example Command sent via UART: '010300100002' Read Holding Registers #16 and #17 from slave device with address 1. Possible Responses: '01830b' -> Device did not respond or could not be reached (error code 11, generated by Bridge) '018302' -> Reading holding registers with that addresses not supported by device (error code 2, generated by Slave device with address 1) '010300100002abcd1234' -> Successful readout of registers: register #16: 'abcd' register #17: '1234' Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Bus IO Protection >\u00b115 kV HBM Protection Bus IO Protection >\u00b112 kV IEC 61000-4-2 Contact Discharge Bus IO Protection >\u00b14 kV IEC 61000-4-4 Fast Transient Burst Max. RS485 Cable Length 3m Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity Modbus LoRaWAN (pdf). CE Declaration DR-15-5 Power Supply (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function uint16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ], \"noData\" : !! ( bytes [ 3 ] & 0x01 ) }; } function port2 ( bytes ) { var regs = []; if ( bytes . length > 5 ) { // loop through data packs var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"register\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x3f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = r [ \"count\" ] * 2 ; if ( b . length >= dataLen + 4 ) { r [ \"data\" ] = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"registers\" : regs }; } function modbusErrorString ( code ) { // Modbus exception codes // see https://en.wikipedia.org/wiki/Modbus#Exception_responses switch ( code ) { case 1 : return \"Illegal Function\" ; case 2 : return \"Illegal Data Address\" ; case 3 : return \"Illegal Data Value\" ; case 4 : return \"Slave Device Failure\" ; case 5 : return \"Acknowledge\" ; case 6 : return \"Slave Device Busy\" ; case 7 : return \"Negative Acknowledge\" ; case 8 : return \"Memory Parity Error\" ; case 10 : return \"Gateway Path Unavailable\" ; case 11 : return \"Gateway Target Device Failed to Respond\" ; default : return \"Unknown error code\" ; } } function parseModbusPayloadRegisters ( payload ) { if ( payload . length < 1 ) { return null ; } var byteCnt = payload [ 0 ]; if ( payload . length !== byteCnt + 1 ) { return null ; } var vals = []; for ( var i = 0 ; i < byteCnt ; i += 2 ) { vals . push ([ + payload [ i + 1 ], + payload [ i + 2 ]]) } return vals ; } function parseModbusResponse ( raw ) { var resp = {}; if ( raw . length >= 6 ) { var fun = raw [ 1 ] & 0xf ; var error = !! ( raw [ 1 ] & 0x80 ); var rawResp = raw . slice ( 0 , raw . length - 3 ); resp [ \"slave\" ] = raw [ 0 ]; resp [ \"function\" ] = fun ; resp [ \"error\" ] = error ; resp [ \"start\" ] = uint16_BE ( raw , raw . length - 3 ); resp [ \"cnt\" ] = raw [ raw . length - 1 ]; resp [ \"raw\" ] = rawResp ; if ( error ) { resp [ \"errorCode\" ] = raw [ 2 ]; resp [ \"errorText\" ] = modbusErrorString ( raw [ 2 ]); } else { resp [ \"values\" ] = parseModbusPayloadRegisters ( rawResp . slice ( 2 )) // TODO: coils } } return resp ; } function FullResponses ( bytes , port ) { var timestamp = int40_BE ( bytes ); var pos = 5 ; var resps = []; while ( pos < bytes . length ) { var respLen = bytes [ pos ++ ]; if ( bytes . length >= pos + respLen ) { var rawResponse = bytes . slice ( pos , pos + respLen ); resps . push ( parseModbusResponse ( rawResponse )); pos += respLen ; } else { break ; } } return { \"port\" : port , \"timestamp\" : timestamp , \"responses\" : resps }; } function bin2String ( array ) { var result = \"\" ; for ( var i = 0 ; i < array . length ; i ++ ) { result += String . fromCharCode ( array [ i ]); } return result ; } function ConfigResponse ( data ) { var t = bin2String ( data ); return { \"response\" : t , \"error\" : ( t . length === 0 ) || ( t [ 0 ] === '!' ) } } /** * TTN decoder function. */ function Decoder ( bytes , port ) { switch ( port ) { case 1 : // Status message: return port1 ( bytes ); case 2 : // not legacy format: return port2 ( bytes ); case 3 : case 4 : // v1.0.0 format, full modbus responses: return FullResponses ( bytes , port ); case 5 : // continuation of previous response: return {}; case 6 : // dense format with prefixed timestamp: return {}; case 7 : // dense format without timestamp: return {}; case 128 : return ConfigResponse ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } /** * LoRaServer decoder function. */ function Decode ( fPort , bytes ) { // wrap TTN Decoder: return Decoder ( bytes , fPort ); } function Parse ( input ) { var data = bytes ( atob ( input . data )); var port = input . fPort ; var fcnt = input . fCnt ; var vals = Decoder ( data , port ); vals [ \"port\" ] = port ; vals [ \"data\" ] = data ; vals [ \"fnct\" ] = fcnt ; var lastFcnt = Device . getProperty ( \"lastFcnt\" ); vals [ \"reset\" ] = fcnt <= lastFcnt ; Device . setProperty ( \"lastFcnt\" , fcnt ); return vals ; } Copyright Modbus Logo","title":"Manual"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v1.x.x (since 2019-10-16) This is the latest version. For older revisions please refer to the version overview . This version has a different upload format than older versions! If you are using 0.3.x firmware, please see the 0.3.x Manual . If you are updating to this firmware, be aware that you will have to update your configuration and the parser in your backend.","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/index.html#key-features","text":"LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Configuration via USB or remotely via LoRaWAN downlink ModBus ASCII and RTU modes supported Readout of ModBus Coils, Discrete Inputs, Input Registers and Holding Registers ModBus dialog mode via USB for easy configuration testing Coexistence with 2 nd Modbus Master possible (bus sharing, Listen before talk)","title":"Key Features"},{"location":"lorawan-sensors/modbus-lorawan/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via LoRaWAN uplinks. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/index.html#supported-devices","text":"The Lobaro Modbus LoRaWAN Bridge works with all devices that act as a Modbus Client using RTU or ASCII (Modbus TCP is not supported). Some devices that have been used successfully with the Bridge: Device Type Manufacturer More information Octave Ultrasonic Meter Water meter Arad Group External Link ECL Controller Heat/Hot Water Regulation Danfoss External Link UMD 97 Smart Grid Power Meter PQ Plus External Link (German) DRS458DE Power Meter B+G E-Tech GmbH External Link","title":"Supported Devices"},{"location":"lorawan-sensors/modbus-lorawan/index.html#product-variants","text":"The LoRaWAN Modbus bridge can be ordered in two standard variants. For even more customizations options see Hardware Variants overview.","title":"Product variants"},{"location":"lorawan-sensors/modbus-lorawan/index.html#variant-battery-powered","text":"LoRaWAN Modbus Bridge (XH battery connector, IP67 housing), Order number: 8000041 ER34615 (3.6V Battery, XH Connector, 0.2A), Order number: 3000169","title":"Variant battery powered"},{"location":"lorawan-sensors/modbus-lorawan/index.html#variant-external-powered","text":"LoRaWAN Modbus Bridge (ext. Power, Din-Rail, no housing), Order number: 8000043 DR-15-5 DIN-Rail power supply 5V, Order number: 3000006 RK 4/12-L DIN-Rail Housing, Order number: 3000005 Data Sheet with dimensions (PDF) Further customization Options The product variants shown above are the standard variants. Other power supply options & housing are available on request External antenna AA batteries NB-IoT instead of LoRaWAN Contact us via support@lobaro.de if you need our offer for a special variant.","title":"Variant external powered"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-introduction","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus .","title":"Modbus Introduction"},{"location":"lorawan-sensors/modbus-lorawan/index.html#quick-start-guide","text":"Please refer to the rest of this documentation for a save and proper use of the Modbus Bridge. This Quick Start Guide can only show you basic operations. It illustrates reading a single value from one Slave Device. Connect the Modbus Bridge to your Modbus Slave Device using the RS485 connection using a twisted pair cable: A to A , B to B , and GND to GND ( GND is not strictly necessary but enhances the connection. Not all slave devices supply a GND connector). Connect the Modbus Bridge to a computer using the Lobaro Configuration Adapter and the Lobaro Maintenance Tool . Synchronise the LoRaWAN configuration parameters between the Bridge and your Network Server. Make sure the Bridge is in reach of a Gateway attached to your Network Server. Set the Modbus Parameters according to your Slave Device (ASCII/RTU, Baud, Data Length, Stop Bits, Parity). Set MbCmd to the Modbus Command to read the register you need (see below). Save the configuration and switch to the Log tab. You should see the device requesting the data and uploading it via LoRaWAN. MbCmd must contain the Modbus Command the Bridge will execute. The command is entered in Hex and without any checksums and is 6 bytes long (12 hexdigits). The default value is 010300000003 , it consists of 4 parts: 01 , 03 , 0000 , 0003 01 Address of the Slave Device. 1 byte: often 01 new devices 03 What kind of Modbus Register to read. 1 byte. 03 stand for Holding Register . 0000 Number/address of the first register to read. 2 bytes. Many devices have some value to read out at 0000 . 0003 Number of consecutive registers to read from the first register. 2 bytes. This would read the registers #0, #1, and #2 in one command. The format used for MbCmd is conforming to the Modbus Standard. See Configurations/Modbus Commands for a description and Examples for some more advance examples. The Modbus Bridge has a Dialog Mode that lets you try out Modbus Commands interactively which helps getting used to the syntax and helps you in trying out your slave devices.","title":"Quick Start Guide"},{"location":"lorawan-sensors/modbus-lorawan/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)==>check(Test Reading); check==>join(LoRaWAN Join); join==>read(Data Collection); read==>send(Data Transfer); send==>sleep(\"Sleep\"); sleep==>|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading After verifying configuration, the Bridge executes all Modbus Commands stored once without uploading the results but logging them only to the console. This makes it easy to verify all Modbus Slaves are reachable and their registers can be read. Connect your computer to the Bridge using the Lobaro Config Adapter and check the output using the Lobaro Maintenance Tool. The device will continue with LoRaWAN Join to connect to the Network (whether the test reading was successful or not does not change this). LoRaWAN Join The Bridge tries to connect to the LoRaWAN Network. The Details depend on the device's configuration (OTAA vs. ABP, optional Time synchronisation). Unless ABP is used, the Bridge will remain in this state until joining succeeds. It will repeat to send Join requests with decreasing frequency. After successfully attaching it enters Data Collection for the first time and starts the normal operation cycle. Data Collection The Bridge sends all Modbus Commands from the Configuration on the Bus and collects the answers (or lack thereof). Data Transfer The collected Modbus Responses are uploaded via LoRaWAN. This can take multiple upload messages depending on the amount of data collected. Once a day a status message is also uploaded, giving some information about the state of the Bridge itself. If many messages are uploaded this can take a long time. At least one message is uploaded during this state. When all data is uploaded, the device goes to Sleep . Sleep Between activations the device enters a very power efficient sleep mode. It stays dormant until the time specified by the Cron expression, when it changes back to Data Collection .","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/index.html#configuration","text":"The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter . Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages , see Downlinks description.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot","title":"LoRaWAN"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values MbProt Modbus-Protocol to use RTU . ASCII MbBaud UART Baud rate 9600 , 19200 , 38400 , ... MbDataLen UART data length 7 , 8 , 9 MbStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) MbPar UART parity NONE , EVEN , ODD MbCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes MbCmd List of Modbus Commands (see below). 010300010003 PlFmt Uplink Format 1 , 2 , or 3 , see Payload Formats EnDL Enable Downlinks true = enable sending Modbus Commands via Downlink DialogMode Enable Dialog Mode true = set the Bridge to Dialog Mode LbtDuration Listen-before-talk Duration 0 = disables, 1 - 3600 = seconds of lbt duration LbtSilence Listen-before-talk Silence 0 = disabled, 1 - 3600 seconds of silence needed \u2020 See also our Introduction to Cron expressions .","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-commands","text":"Whenever the cron expression given in the configuration value MbCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter MbCmd ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set MbCmd to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 51 byte message limit this only leaves 39 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be split and uploaded using multiple LoRaWAN messages. Your backend will need to those parts back together. Any message that is the continuation of an earlier uplink will be sent using port 5 (see Split Messages ). For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at the examples .","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/index.html#listen-before-talk","text":"If you want to use the Lobaro Modbus Bridge to read out values on an installation that already has an active Modbus Master, you will run into conflicts, because the Bridge acts as a Master. Normally only a single Master device is allowed on a Modbus installation. The Bridge supports a Listen-Before-Talk feature, that makes it possible to be used alongside a second Master Device (under certain conditions). If your other Master Device has periods of non-communication that are long enough, you can configure the Bridge to wait for those pauses before starting it's own requests: When Listen-Before-Talk is activated, the Bridge does not immediately start sending on the Bus when it normally would. Instead it starts listening on the Bus until the other Master starts talking and then waits for silence to detect when the other Master just finished communicating. Only then does it send it's requests. The Bridge waits for a maximum of LbtDuration seconds for the other Master to start communicating. Then it waits for a period of silence that lasts at least LbtSilence seconds to decide that the other master has completed its work and is now in pause. So if, for example, your other Master has a work interval of 2 minutes and is active for about 30 seconds without longer pauses, you could set LbtDuration to 130 (10 seconds added as a buffer), and LbtSilence to 15 (make sure the value is longer than the timeout your other master has). You will have to know exactly how your other Master acts to setup this feature. If you set either of LbtDuration or LbtSilence to 0 , you will deactivate Listen-Before-Talk completely (it is deactivated by default).","title":"Listen-Before-Talk"},{"location":"lorawan-sensors/modbus-lorawan/index.html#payload-formats","text":"The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Uplink 5 Continuation of Responses that do not fit in a single Uplink. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document.","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/index.html#uplink","text":"","title":"Uplink"},{"location":"lorawan-sensors/modbus-lorawan/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 uint16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#data-messages","text":"Data messages contain responses to Modbus Commands received by the Bridge. The Bridge supports multiple Payload formats for different use cases. The format is selected by the configuration parameter PlFmt : 1 : Verbose payload format (port 3) 2 : Compact payload format with time (port 6) 3 : Compact payload format without time (port 7)","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#verbose-payload-format","text":"The verbose payload format ( PlFmt = 1 ) is the standard setting of the Bridge. It is designed to be very versatile (it uploads the complete Response sent by the Slave Devices, so reading registers as well as writing registers are both supported). It contains all information you need to know the register and the slave device your data is coming from. You do not need to know the exact configuration of your devices in your backend to be able to parse the data. This is convenient when you have man Modbus Bridges with different configuration in the field. This payload format is also good in communicating error conditions in case the executed Modbus Commands fail. The trade off is overhead in the transmission. If you need to get a lot of data uploaded often, this could be a problem for you with the limited LoRaWAN bandwidth. If this is a problem for your use case, you should take a look at the compact data formats. Data messages using the verbose payload format are uploaded on port 3. Every message starts with a 5 byte timestamp (UNIX timestamp as big endian int40 , see timestamps in our LoRaWAN devices ) for more information). The timestamp is followed by one or more responses of varying length. Each of the responses starts with a single byte ( uint8 ) indicating the length of its payload ( len ) followed by that many bytes of payload. The payload consists of the raw Modbus response as sent by the Slave Device followed by 3 additional bytes: the first register/coil as uint16 (big endian) and the number of registers/coils as uint8 taken from the executed command. The following tables visualise the message structure. See the Examples Section for some sample data messages explained down to the individual bytes. We also provide a Reference Decoder in JavaScript that can read the format. The timestamp in the message is the wakeup time when the device was activated by the cron expression in MbCron (using the devices internal clock). The Modbus Response in the message in addition with the start register/coil and the register/coil count makes it possible to know which registers/coils where exactly read/written, what kind they were, and the address of the device. For Modbus Commands that do not have a register/coil count (like function 5, forcing a single coil), or for those that do not contain a start register/coil (e.g. funtion 7, reading exception status), the contents of the additional fields start register and/or count are undefined. The payload format used only a single byte for the count value, so if you are reading/writing more than 255 coils, the higher byte will be cut off. The Bridge puts as many responses as in one message as possible (without changing the order of responses and respecting the maximal message size of the current Spreading Factor ). If the responses do not fit into a single message it will upload as many messages as needed. When a single response is too long to fit in a message, the response will be split up over multiple messages and will need to be reassembled in the backend. See Split Messages for instructions on how to do that and how to prevent splitting. Structure of a message on port 3: Bytes | 0 . 1 . 2 . 3 . 4 | 5 ... | ... | ... | ... | +-------------------+------------+------------+-----+------------+ Part | timestamp | response 1 | response 2 | ... | response n | Structure of a response part on port 3: Bytes | 0 | 1 .. len-3 | len-2 . len-1 | len | +-----+-----------------+----------------+-------+ Field | len | Modbus response | start register | count |","title":"Verbose payload format"},{"location":"lorawan-sensors/modbus-lorawan/index.html#compact-payload-format","text":"The compact payload format transmits only the payload bytes of the received responses. This format requires less bytes to upload the information than the verbose payload format, allowing more data to be read out per hour, but it requires a customised backend that knows the exact configuration of the Bridge. This format only makes sense for reading registers/coils. Error conditions can not be communicated very well using this format. For PlFmt = 2 the data messages are uploaded on port 6. The messages start with a 5 byte timestamp (same as in verbose payload format). The timestamp is followed by only the payload bytes of the Modbus Responses triggerd by the configuration parameter MbCmd . The bytes are just appended to the message after another, in the order of the Commands in MbCmd . You will need to know the exact value of MbCmd of each of your Bridges to make sense of the data. When using this payload format the Remote Configuration is very helpful: it can be used to read the value of configuration parameters over LoRaWAN without physical access to the device (it can also change those values). If a Modbus command fails to execute (for example if the Slave device has a power outage or if the bus is disconnected), the data bytes of that command are all set to 0xff . This could also be a valid value (depending on the nature of your data), but there is no other channel to communicate failure. 0xff is easy to spot and 0xffff is relative unlikely to be a real value for Modbus registers. When using the Bridge with PlFmt = 3 data messages are uploaded on port 7. The payload format is identical to the payload format for PlFmt = 3 only without the timestamp (to save another 5 bytes in case you do not care about the time of your readings).","title":"Compact payload format"},{"location":"lorawan-sensors/modbus-lorawan/index.html#split-messages","text":"LoRaWAN has a very limited message size. For high spreading factors this goes as low as 51 bytes. If a Modbus Response is too long to fit into a single message, the Modbus Bridge will split it up into multiple messages that are sent in sequence. Patching messages back together requires a more complex backend that can save a state. A simple parse on The Things Network will not be able to do that. If your backend cannot handle this process, you can work around it by configuring your MbCmd in a way that no single response will be longer than 45 bytes (by reading out a maximum of 24 consecutive registers in a single command). If you have a configuration that results in longer Responses you should make sure your backend can handle split Responses as described here. If a Response is too long to fit into a single message, the Bridge puts as many bytes as possible into the message. You can tell by the length of the message and the length of the Modbus Response indicated in the message, that this is only the first part of a message. This first part will be upload normally on port 3 (or port 4, if triggered by a downlink). Following the first part, the Bridge will upload the remaining data in messages sent on port 5. For very long Responses and high Spreading Factors, the Response could be split into up to 6 messages. You can use the frame counter and the indicated length to verify if you receive all parts. Modbus Responses that are split up will never be packed together with other Responses. The Examples section contains an illustration of a split up Response.","title":"Split messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#downlink","text":"Please be aware that Downlinks in LoRaWAN can only be received when the device sends an Uplink, or when the device operates in Class C mode. See Uplinks and Downlinks in our LoRaWAN page for more information.","title":"Downlink"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-commands_1","text":"Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length as uint8 . The Modbus Commands must be sent as raw bytes and without any check digits. The Responses to the Commands are sent as Uplink messages on port 4. The payload format on port 4 is the same as on port 3 (see Data messages ), only that the timestamp indicates the time the downlink was received by the Bridge. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, it creates an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command, but it will be performed for any sequence of bytes you send. Commands must have a length of at least 3 bytes. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly from your computer or using the Dialog Mode , to reduce possible error sources. Refer to Examples to see some Downlinks and their answers.","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/index.html#remote-configuration","text":"The Modbus Bridge supports configuration via LoRaWAN Downlinks. It receives commands on port 128. See Remote Configuration in our LoRaWAN page for instructions on how to use it.","title":"Remote Configuration"},{"location":"lorawan-sensors/modbus-lorawan/index.html#examples","text":"This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings, while on the air they are sent as raw bytes. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus .","title":"Examples"},{"location":"lorawan-sensors/modbus-lorawan/index.html#uplinks-triggered-by-configuration","text":"The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 MbCmd = '010300000003' # Example resulting Uplink after successful readout Up, Port 3: '005d1698fd0c0103061234567890ab000003' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '0c' -> first Response is 12 bytes long '0103061234567890ab000003' 12 bytes modbus response: '01' -> slave device with address 1 '03' -> function 3 = read Holding Register, success '06' -> 6 bytes of data in Response following '1234567890ab' -> 6 bytes of data '0000' -> start reading at register 0 '03' -> read 3 consecutive registers # Example resulting Uplink after failing readout Up, Port 3: '005d1698fd0601830b000003' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '06' -> first Response is 6 bytes long '01830b000003' 3 bytes modbus response: '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register, failed '0b' -> error code 11: \"Gateway Target Device Failed to Respond\" '0000' -> start reading at register 0 '03' -> read 3 consecutive registers Example A2: Read coils 1000-1019 of device 32 MbCmd = '200103e80014' # Example resulting Uplink Up, Port 3: '005d1698fd 09 200103f1041a03e814' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '09' -> first Response is 9 bytes long '200103f1041a03e814' 9 bytes of response: '20' -> slave device with address 32 '01' -> read coils, success '03' -> 3 bytes of data 'f1041a' -> 20 bits of data packed into 3 bytes '03e8' -> start reading at coil 1000 '14' -> read 20 consecutive coils Example A3: Read two devices MbCmd = '0a0300010005,3001ea600020' # Example resulting Uplink Up, Port 3: '005d1698fd100a030a111122223333444455550001050a30010412345678ea6020' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '10' -> first Response is 16 bytes long '0a030a11112222333344445555000105' 16 bytes of Response '0a' -> slave device with address 10 '03' -> read Holding Registers, success '0a' -> 10 bytes of data following '11112222333344445555' 10 bytes of data '0001' -> start reading at register 1 '05' -> read 5 registers '0a' -> second Response is 10 bytes long '30010412345678ea6020' 10 bytes of Response '30' -> slave device with address 48 '01' -> read Coils, success '04' -> 4 bytes of data following '12345678' -> 32 bits of data packed in 4 bytes 'ea60' -> start at coil 60000 '20' -> read 32 coils Example A4: Split up messages MbCmd = '010300010020' # Command reads 32 consecutive registers resulting in 64 bytes payload # Example resulting Uplinks for a Spreading Factor of 12 with 51 bytes of payload per message Up 1, Port 3: '005d1698fd46010340000100020003000400050006000700080009000a000b000c000d000e000f001000110012001300140015' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '46' -> first Response is 70 bytes long since the remainder of the message does not contain 70 bytes, you know there must be an additional part comming Up 2, Port 5: '0016001700180019001a001b001c001d001e001f00200120' This contains the rest of the message. Appended to the privious message, it adds up to the correct number of bytes. TODO: examples for compact payload format All this examples use the verbose payload format. We need to add examples using the compact format.","title":"Uplinks triggered by configuration"},{"location":"lorawan-sensors/modbus-lorawan/index.html#uplinks-triggered-by-downlink-commands","text":"Example B1: Read single Input Register by Downlink Down, Port 4: '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4, read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up, Port4: '004b3dd67508180402abcd010001' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '08' -> first Response is 8 bytes long '180404abcd010001' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register, success '02' -> 2 bytes of data following 'abcd' -> 2 bytes of data '0100' -> start at register 256 '01' -> read 1 register Example B2: Writing holding registers on multiple devices Down, Port 4: '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6, write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16, write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up, Port 4: '004b3dd67506a1860200000006a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '06' -> first Response is 3 bytes long 'a18602000000' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter, failed '02' -> error code 2: \"Illegal Data Address\" '0000' -> start register not used (undefined) '00' -> count not used (undefined) '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> write multiple Holding Registers, success 'a001' -> start at register 40961 '0004' -> 4 registers to write","title":"Uplinks triggered by Downlink Commands"},{"location":"lorawan-sensors/modbus-lorawan/index.html#dialog-mode","text":"The Modbus Bridge has an additional interactive Operation Mode that can help finding the correct Modbus Commands for normal operations. You enter it by setting the Configuration Parameter DialogMode to true using the Lobaro Configuration Adapter and the Lobaro Maintenance Tool. After saving the configuration the device will reboot and enter Dialog Mode. To change the device back to normal operations change the Parameter DialogMode back to false and save the config. In Dialog Mode the Bridge will not connect to the LoRaWAN Network and it will not execute any operations on its own. It will wait for user input over the Lobaro Maintenance Tool. On the tab showing the device's log messages there is an input field labeled Send via UART . You can enter Modbus commands here, followed by pressing return. The Bridge will send the commands over the bus just as it would if it got them from configuration. The response will be observable in the Log. The Commands must be entered as hex strings without any check sums. The Modbus parameters (UART configuration and Modbus Mode RTU/ASCII) are taken from the configuration just as during normal operations. The Bridge operates as an interactive Modbus master device that can be used for diagnosing Modbus installations or executing a few commands on a device that has no permanent Modbus connection. In Dialog Mode the device does not enter any sleep states. If you leave the Modbus Bridge in DialogMode while it is powered by battery it will quickly drain the battery and run out of power.","title":"Dialog Mode"},{"location":"lorawan-sensors/modbus-lorawan/index.html#dialog-mode-example","text":"Command sent via UART: '010300100002' Read Holding Registers #16 and #17 from slave device with address 1. Possible Responses: '01830b' -> Device did not respond or could not be reached (error code 11, generated by Bridge) '018302' -> Reading holding registers with that addresses not supported by device (error code 2, generated by Slave device with address 1) '010300100002abcd1234' -> Successful readout of registers: register #16: 'abcd' register #17: '1234'","title":"Dialog Mode Example"},{"location":"lorawan-sensors/modbus-lorawan/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Bus IO Protection >\u00b115 kV HBM Protection Bus IO Protection >\u00b112 kV IEC 61000-4-2 Contact Discharge Bus IO Protection >\u00b14 kV IEC 61000-4-4 Fast Transient Burst Max. RS485 Cable Length 3m Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity Modbus LoRaWAN (pdf). CE Declaration DR-15-5 Power Supply (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function uint16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ], \"noData\" : !! ( bytes [ 3 ] & 0x01 ) }; } function port2 ( bytes ) { var regs = []; if ( bytes . length > 5 ) { // loop through data packs var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"register\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x3f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = r [ \"count\" ] * 2 ; if ( b . length >= dataLen + 4 ) { r [ \"data\" ] = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"registers\" : regs }; } function modbusErrorString ( code ) { // Modbus exception codes // see https://en.wikipedia.org/wiki/Modbus#Exception_responses switch ( code ) { case 1 : return \"Illegal Function\" ; case 2 : return \"Illegal Data Address\" ; case 3 : return \"Illegal Data Value\" ; case 4 : return \"Slave Device Failure\" ; case 5 : return \"Acknowledge\" ; case 6 : return \"Slave Device Busy\" ; case 7 : return \"Negative Acknowledge\" ; case 8 : return \"Memory Parity Error\" ; case 10 : return \"Gateway Path Unavailable\" ; case 11 : return \"Gateway Target Device Failed to Respond\" ; default : return \"Unknown error code\" ; } } function parseModbusPayloadRegisters ( payload ) { if ( payload . length < 1 ) { return null ; } var byteCnt = payload [ 0 ]; if ( payload . length !== byteCnt + 1 ) { return null ; } var vals = []; for ( var i = 0 ; i < byteCnt ; i += 2 ) { vals . push ([ + payload [ i + 1 ], + payload [ i + 2 ]]) } return vals ; } function parseModbusResponse ( raw ) { var resp = {}; if ( raw . length >= 6 ) { var fun = raw [ 1 ] & 0xf ; var error = !! ( raw [ 1 ] & 0x80 ); var rawResp = raw . slice ( 0 , raw . length - 3 ); resp [ \"slave\" ] = raw [ 0 ]; resp [ \"function\" ] = fun ; resp [ \"error\" ] = error ; resp [ \"start\" ] = uint16_BE ( raw , raw . length - 3 ); resp [ \"cnt\" ] = raw [ raw . length - 1 ]; resp [ \"raw\" ] = rawResp ; if ( error ) { resp [ \"errorCode\" ] = raw [ 2 ]; resp [ \"errorText\" ] = modbusErrorString ( raw [ 2 ]); } else { resp [ \"values\" ] = parseModbusPayloadRegisters ( rawResp . slice ( 2 )) // TODO: coils } } return resp ; } function FullResponses ( bytes , port ) { var timestamp = int40_BE ( bytes ); var pos = 5 ; var resps = []; while ( pos < bytes . length ) { var respLen = bytes [ pos ++ ]; if ( bytes . length >= pos + respLen ) { var rawResponse = bytes . slice ( pos , pos + respLen ); resps . push ( parseModbusResponse ( rawResponse )); pos += respLen ; } else { break ; } } return { \"port\" : port , \"timestamp\" : timestamp , \"responses\" : resps }; } function bin2String ( array ) { var result = \"\" ; for ( var i = 0 ; i < array . length ; i ++ ) { result += String . fromCharCode ( array [ i ]); } return result ; } function ConfigResponse ( data ) { var t = bin2String ( data ); return { \"response\" : t , \"error\" : ( t . length === 0 ) || ( t [ 0 ] === '!' ) } } /** * TTN decoder function. */ function Decoder ( bytes , port ) { switch ( port ) { case 1 : // Status message: return port1 ( bytes ); case 2 : // not legacy format: return port2 ( bytes ); case 3 : case 4 : // v1.0.0 format, full modbus responses: return FullResponses ( bytes , port ); case 5 : // continuation of previous response: return {}; case 6 : // dense format with prefixed timestamp: return {}; case 7 : // dense format without timestamp: return {}; case 128 : return ConfigResponse ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } /** * LoRaServer decoder function. */ function Decode ( fPort , bytes ) { // wrap TTN Decoder: return Decoder ( bytes , fPort ); } function Parse ( input ) { var data = bytes ( atob ( input . data )); var port = input . fPort ; var fcnt = input . fCnt ; var vals = Decoder ( data , port ); vals [ \"port\" ] = port ; vals [ \"data\" ] = data ; vals [ \"fnct\" ] = fcnt ; var lastFcnt = Device . getProperty ( \"lastFcnt\" ); vals [ \"reset\" ] = fcnt <= lastFcnt ; Device . setProperty ( \"lastFcnt\" , fcnt ); return vals ; } Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html","text":"Modbus LoRaWAN Bridge Firmware Make sure to use the latest version of the Lobaro Maintenance Tool! Use at least version 1.4.9 of the Lobaro Maintenance Tool for installing this firmware. Downloads: app-modbus-lora-bridge-TZ0-1.2.1.hex . [current release] app-modbus-lora-bridge-TZ0-1.1.1.hex . app-modbus-lora-bridge-TZ0-1.0.3.hex . app-modbus-lora-bridge-1.0.2.hex . app-modbus-lora-bridge-1.0.1.hex . app-modbus-lora-bridge-0.3.1.hex . [latest release with old stack version] Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog [1.2.1] - 2020-02-17 - [current release] Added Display Version of Lobaro LoRaWAN Stack on boot. Fixed Fix a crash when using remote command append . [1.2.0] Added New config parameter MbAttempts to control how often Modbus Commands will be repeated in case of timeouts. [1.1.1] Changed Increased size available for config. [1.1.0] Added New optional Listen-Before-Talk Modbus communication, so device can coordinate with another master on bus. Fixed Fix issue that could cut of long Modbus responses. [1.0.3] Changed Dialog Mode now logs activity on RS485 Bus while not communicating (to detect other Modbus Masters). Log Frequencies for LoRaWAN. [1.0.2] Added Waitcycles for optional capacitors to load and stabilize on startup [1.0.1] Changed Using FRAM for storing results before uploading, allowing for multiple kB of data to be sent (size depending on hardware). Fixed Removed memory corruption error that could be triggered by configurations with lots of Modbus commands. [1.0.0] Added LoRaWAN 1.1 support Remote configuration via LoRaWAN on port 128. Clock synchronisation via LoRaWAN. Changed Random delay before Uplink (to prevent persistent collisions when using multiple devices). Modbus responses longer than payload now get split up (additional parts on port 5). [0.4.1] Fixed Changed error indication bit on error 11 from 0xf0 to 0x80 . Fixed issue when parsing multiple Modbus commands from config. [0.4.0] Added Writing values to holding registers and coils. Execution of arbitrary Modbus commands triggered by LoRaWAN Downlink messages. Support for LoRaWAN Operation Mode Class C (for short reaction time to Downlinks). Automated register writing and broadcasts possible through new configuration. Changed Automated reading (triggered by cron) is now configured by entering actual Modbus commands (more flexibility and usage of already existing Modbus syntax \u2013 this breaks old configurations ). Upload format changed to sending raw response to Modbus commands ( this breaks existing integrations ). Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again. [0.3.1] \u2013 2019-05-24 Fixed Increased robustness of data reception on higher Baud rates. [0.3.0] \u2013 2019-05-15 Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Changed Parity bit must not be substracted from Data bits anymore. 8E1 can now be confiured with 8 Data bits, EVEN parity, 1 Stop bit . [0.1.0] \u2013 2018-08-13 Added Original hardware release (with RS-485 on holding PCB).","title":"Firmware & Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#modbus-lorawan-bridge","text":"","title":"Modbus LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#firmware","text":"Make sure to use the latest version of the Lobaro Maintenance Tool! Use at least version 1.4.9 of the Lobaro Maintenance Tool for installing this firmware. Downloads: app-modbus-lora-bridge-TZ0-1.2.1.hex . [current release] app-modbus-lora-bridge-TZ0-1.1.1.hex . app-modbus-lora-bridge-TZ0-1.0.3.hex . app-modbus-lora-bridge-1.0.2.hex . app-modbus-lora-bridge-1.0.1.hex . app-modbus-lora-bridge-0.3.1.hex . [latest release with old stack version] Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#121-2020-02-17-current-release","text":"Added Display Version of Lobaro LoRaWAN Stack on boot. Fixed Fix a crash when using remote command append .","title":"[1.2.1] - 2020-02-17 - [current release]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#120","text":"Added New config parameter MbAttempts to control how often Modbus Commands will be repeated in case of timeouts.","title":"[1.2.0]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#111","text":"Changed Increased size available for config.","title":"[1.1.1]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#110","text":"Added New optional Listen-Before-Talk Modbus communication, so device can coordinate with another master on bus. Fixed Fix issue that could cut of long Modbus responses.","title":"[1.1.0]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#103","text":"Changed Dialog Mode now logs activity on RS485 Bus while not communicating (to detect other Modbus Masters). Log Frequencies for LoRaWAN.","title":"[1.0.3]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#102","text":"Added Waitcycles for optional capacitors to load and stabilize on startup","title":"[1.0.2]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#101","text":"Changed Using FRAM for storing results before uploading, allowing for multiple kB of data to be sent (size depending on hardware). Fixed Removed memory corruption error that could be triggered by configurations with lots of Modbus commands.","title":"[1.0.1]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#100","text":"Added LoRaWAN 1.1 support Remote configuration via LoRaWAN on port 128. Clock synchronisation via LoRaWAN. Changed Random delay before Uplink (to prevent persistent collisions when using multiple devices). Modbus responses longer than payload now get split up (additional parts on port 5).","title":"[1.0.0]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#041","text":"Fixed Changed error indication bit on error 11 from 0xf0 to 0x80 . Fixed issue when parsing multiple Modbus commands from config.","title":"[0.4.1]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#040","text":"Added Writing values to holding registers and coils. Execution of arbitrary Modbus commands triggered by LoRaWAN Downlink messages. Support for LoRaWAN Operation Mode Class C (for short reaction time to Downlinks). Automated register writing and broadcasts possible through new configuration. Changed Automated reading (triggered by cron) is now configured by entering actual Modbus commands (more flexibility and usage of already existing Modbus syntax \u2013 this breaks old configurations ). Upload format changed to sending raw response to Modbus commands ( this breaks existing integrations ). Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again.","title":"[0.4.0]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#031-2019-05-24","text":"Fixed Increased robustness of data reception on higher Baud rates.","title":"[0.3.1] &ndash; 2019-05-24"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#030-2019-05-15","text":"Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Changed Parity bit must not be substracted from Data bits anymore. 8E1 can now be confiured with 8 Data bits, EVEN parity, 1 Stop bit .","title":"[0.3.0] &ndash; 2019-05-15"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#010-2018-08-13","text":"Added Original hardware release (with RS-485 on holding PCB).","title":"[0.1.0] &ndash; 2018-08-13"},{"location":"lorawan-sensors/modbus-lorawan/redirect-example.html","text":"latest version","title":"Redirect example"},{"location":"lorawan-sensors/modbus-lorawan/versions.html","text":"Versions of the Modbus LoRaWAN Bridge Our devices are developed further and improved continuously. This sometimes breaks backwards compatibility or leads to huge changes in the documentation. On order to provide documentation for existing older devices we provide the manuals for older versions. If you are looking for the manual for an older revision, choose the manual with the highest version number lower than the version number of your installed firmware. You can find out what firmware is installed on your hardware with our configuration adapter and configuration tool. The firmware version is printed in the log on device startup. For an overview over the changes between manual releases, please refer to the changelog . [1.x.x] (since 2019-09-16 \u2013 current version) [0.4.x] (since 2019-07-29) [0.3.x] (since 2019-05-15 \u2013 leagcy payload format) [0.1.x] (since 2018-08-13 \u2013 pdf)","title":"Versions"},{"location":"lorawan-sensors/modbus-lorawan/versions.html#versions-of-the-modbus-lorawan-bridge","text":"Our devices are developed further and improved continuously. This sometimes breaks backwards compatibility or leads to huge changes in the documentation. On order to provide documentation for existing older devices we provide the manuals for older versions. If you are looking for the manual for an older revision, choose the manual with the highest version number lower than the version number of your installed firmware. You can find out what firmware is installed on your hardware with our configuration adapter and configuration tool. The firmware version is printed in the log on device startup. For an overview over the changes between manual releases, please refer to the changelog . [1.x.x] (since 2019-09-16 \u2013 current version) [0.4.x] (since 2019-07-29) [0.3.x] (since 2019-05-15 \u2013 leagcy payload format) [0.1.x] (since 2018-08-13 \u2013 pdf)","title":"Versions of the Modbus LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v0.3.0 This manual is for an older version of the Modbus Bridge! latest version \u2013 version overview Consider using the latest firmware on your hardware This version uses a different upload format than our newer versions. See available firmware downloads Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. PDF Download Data Sheet with dimensions Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. loRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD Operation Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes See also our Introduction to Cron expressions . Register/Coil definition Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration. Example register definition strings definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5. Payload formats The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ). Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1 Data messages The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined. Structure of a data pack name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document. Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v0.3.0 This manual is for an older version of the Modbus Bridge! latest version \u2013 version overview Consider using the latest firmware on your hardware This version uses a different upload format than our newer versions. See available firmware downloads","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. PDF Download Data Sheet with dimensions","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"loRaWAN Parameters"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes See also our Introduction to Cron expressions .","title":"Operation"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#registercoil-definition","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration.","title":"Register/Coil definition"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#example-register-definition-strings","text":"definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5.","title":"Example register definition strings"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#payload-formats","text":"The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ).","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#data-messages","text":"The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined.","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#structure-of-a-data-pack","text":"name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document.","title":"Structure of a data pack"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/0.3.0/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v0.4.1 (since 2019-07-27) This the manual for an unreleased version of the firmware. For older revisions please refer to the version overview . Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via Uplink. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation. PDF Download Data Sheet with dimensions Modbus Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus . Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't OpMode both char LoRaWAN operation mode, A \u2261 Class A, C \u2261 Class C Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLength UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD ModbusCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes ModbusCommands List of Modbus Commands (see below). 010300010003 \u2020 See also our Introduction to Cron expressions . Modbus Commands Whenever the cron expression given in the configuration value ModbusCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter ModbusCommands ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set ModbusCommands to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 50 byte message limit this only leaves 38 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be dropped! To make sure your data can be uploaded on high spreading factors, do not read out more than 19 consecutive 16 bit registers in a single command. For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at examples . Payload formats The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document. Uplink Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C Data messages Data messages contain responses to Modbus Commands received by the Bridge. They are sent as Uplinks on two different ports, depending on how the command was triggered. The format of the messages is identical for both cases. Data messages on port 3 contain responses to the commands set in the configuration parameter ModbusCommands that are executed automatically every time the cron expression in ModbusCron activates. Data messages on port 4 contain responses to Modbus Commands that have been sent to the Bridge as Downlinks via LoRaWAN. Every Data message starts with 5 bytes containing an int40 timestamp. This is followed by zero or more Modbus Responses. Each Modbus Response is prefixed with a single byte indicating the length of the Response (as uint8 ). The timestamp indicates when the command that triggered the Responses were executed. For Messages on port 3 this is the time at which the Bridge was activated by the cron expression. For Messages on port 4 this is the time at which the received Downlink was executed. Please note our information on timestamps in our LoRaWAN devices . The Bridge tries to put as many Responses into a single message as possible, so depending on the current spreading factor, the number of Responses per message may vary. For a short introduction to Modbus Commands and Responses and some examples of configuration and payload refer to Examples . Downlink Modbus Commands Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length. The Responses to the Commands are sent as Uplink messages on port 4. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, create an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly, without the Bridge, to reduce possible error sources. Refer to Examples to see some Downlinks and their answers. Examples This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus . Uplinks triggered by configuration The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 ModbusCommands = '010300000003' # Example resulting Uplink after successful readout Up, Port 3: '005d1698fd0c0103000000031234567890ab' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '0c' -> first Response is 12 bytes long '0103000000031234567890ab' 12 bytes modbus response: '01' -> slave device with address 1 '03' -> function 3 = read Holding Register, success '0000' -> start reading at register 0 '0003' -> read 3 consecutive registers '1234567890ab' -> 6 bytes of data # Example resulting Uplink after failing readout Up, Port 3: '005d1698fd0301830b' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '03' -> first Response is 3 bytes long '01830b' 3 bytes modbus response: '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register, failed '0b' -> error code 11: \"Gateway Target Device Failed to Respond\" Example A2: Read coils 1000-1019 of device 32 ModbusCommands = '200103e80014' # Example resulting Uplink Up, Port 3: '005d1698fd09200103e80014f1041a' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '09' -> first Response is 9 bytes long '200103e80014f1041a' 9 bytes of modbus response: '20' -> slave device with address 32 '01' -> read coils, success '03e8' -> start reading at coil 1000 '0014' -> read 20 consecutive coils 'f1041a' -> 20 bits of data packed into 3 bytes Example A3: Read two devices ModbusCommands = '0a0300010005,3001ea600020' # Example resulting Uplink Up, Port 3: '005d1698fd100a0300010005111122223333444455550a3001ea60002012345678' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '10' -> first Response is 16 bytes long '0a030001000511112222333344445555' 16 bytes of Modbus Response '0a' -> slave device with address 10 '03' -> read Holding Registers, success '0001' -> start reading at register 1 '0005' -> read 5 registers '11112222333344445555' 10 bytes of data '0a' -> second Response is 10 bytes long '30' -> slave device with address 48 '01' -> read Coils, success 'ea60' -> start at coil 60000 '0020' -> read 32 coils '12345678' -> 32 bits of data packed in 4 bytes Uplinks triggered by Downlinks Example B1: Read single Input Register by Downlink Down, Port 4: '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4, read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up, Port4: '004b3dd67508180401000001abcd' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '08' -> first Response is 8 bytes long '180401000001abcd' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register, success '0100' -> start at register 256 '0001' -> read 1 register 'abcd' -> 2 bytes of data Example B2: Writing holding registers on multiple devices Down, Port 4: '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6, write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16, write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up, Port 4: '004b3dd67503a1860206a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '03' -> first Response is 3 bytes long 'a18602' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter, failed '02' -> error code 2: \"Illegal Data Address\" '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> read multiple Holding Registers, success 'a001' -> start at register 40961 '0004' -> 4 registers to write Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } // TODO: Copyright Modbus Logo","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v0.4.1 (since 2019-07-27) This the manual for an unreleased version of the firmware. For older revisions please refer to the version overview .","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via Uplink. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation. PDF Download Data Sheet with dimensions","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus .","title":"Modbus"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't OpMode both char LoRaWAN operation mode, A \u2261 Class A, C \u2261 Class C","title":"LoRaWAN"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLength UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD ModbusCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes ModbusCommands List of Modbus Commands (see below). 010300010003 \u2020 See also our Introduction to Cron expressions .","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-commands","text":"Whenever the cron expression given in the configuration value ModbusCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter ModbusCommands ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set ModbusCommands to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 50 byte message limit this only leaves 38 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be dropped! To make sure your data can be uploaded on high spreading factors, do not read out more than 19 consecutive 16 bit registers in a single command. For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at examples .","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#payload-formats","text":"The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document.","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplink","text":"","title":"Uplink"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#data-messages","text":"Data messages contain responses to Modbus Commands received by the Bridge. They are sent as Uplinks on two different ports, depending on how the command was triggered. The format of the messages is identical for both cases. Data messages on port 3 contain responses to the commands set in the configuration parameter ModbusCommands that are executed automatically every time the cron expression in ModbusCron activates. Data messages on port 4 contain responses to Modbus Commands that have been sent to the Bridge as Downlinks via LoRaWAN. Every Data message starts with 5 bytes containing an int40 timestamp. This is followed by zero or more Modbus Responses. Each Modbus Response is prefixed with a single byte indicating the length of the Response (as uint8 ). The timestamp indicates when the command that triggered the Responses were executed. For Messages on port 3 this is the time at which the Bridge was activated by the cron expression. For Messages on port 4 this is the time at which the received Downlink was executed. Please note our information on timestamps in our LoRaWAN devices . The Bridge tries to put as many Responses into a single message as possible, so depending on the current spreading factor, the number of Responses per message may vary. For a short introduction to Modbus Commands and Responses and some examples of configuration and payload refer to Examples .","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#downlink","text":"","title":"Downlink"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-commands_1","text":"Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length. The Responses to the Commands are sent as Uplink messages on port 4. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, create an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly, without the Bridge, to reduce possible error sources. Refer to Examples to see some Downlinks and their answers.","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#examples","text":"This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus .","title":"Examples"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplinks-triggered-by-configuration","text":"The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 ModbusCommands = '010300000003' # Example resulting Uplink after successful readout Up, Port 3: '005d1698fd0c0103000000031234567890ab' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '0c' -> first Response is 12 bytes long '0103000000031234567890ab' 12 bytes modbus response: '01' -> slave device with address 1 '03' -> function 3 = read Holding Register, success '0000' -> start reading at register 0 '0003' -> read 3 consecutive registers '1234567890ab' -> 6 bytes of data # Example resulting Uplink after failing readout Up, Port 3: '005d1698fd0301830b' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '03' -> first Response is 3 bytes long '01830b' 3 bytes modbus response: '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register, failed '0b' -> error code 11: \"Gateway Target Device Failed to Respond\" Example A2: Read coils 1000-1019 of device 32 ModbusCommands = '200103e80014' # Example resulting Uplink Up, Port 3: '005d1698fd09200103e80014f1041a' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '09' -> first Response is 9 bytes long '200103e80014f1041a' 9 bytes of modbus response: '20' -> slave device with address 32 '01' -> read coils, success '03e8' -> start reading at coil 1000 '0014' -> read 20 consecutive coils 'f1041a' -> 20 bits of data packed into 3 bytes Example A3: Read two devices ModbusCommands = '0a0300010005,3001ea600020' # Example resulting Uplink Up, Port 3: '005d1698fd100a0300010005111122223333444455550a3001ea60002012345678' '005d1698fd' -> timestamp = 1561762045 -> 2019-06-28T22:47:25 UTC '10' -> first Response is 16 bytes long '0a030001000511112222333344445555' 16 bytes of Modbus Response '0a' -> slave device with address 10 '03' -> read Holding Registers, success '0001' -> start reading at register 1 '0005' -> read 5 registers '11112222333344445555' 10 bytes of data '0a' -> second Response is 10 bytes long '30' -> slave device with address 48 '01' -> read Coils, success 'ea60' -> start at coil 60000 '0020' -> read 32 coils '12345678' -> 32 bits of data packed in 4 bytes","title":"Uplinks triggered by configuration"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplinks-triggered-by-downlinks","text":"Example B1: Read single Input Register by Downlink Down, Port 4: '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4, read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up, Port4: '004b3dd67508180401000001abcd' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '08' -> first Response is 8 bytes long '180401000001abcd' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register, success '0100' -> start at register 256 '0001' -> read 1 register 'abcd' -> 2 bytes of data Example B2: Writing holding registers on multiple devices Down, Port 4: '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6, write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16, write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up, Port 4: '004b3dd67503a1860206a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010-01-01T11:03:17 UTC '03' -> first Response is 3 bytes long 'a18602' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter, failed '02' -> error code 2: \"Illegal Data Address\" '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> read multiple Holding Registers, success 'a001' -> start at register 40961 '0004' -> 4 registers to write","title":"Uplinks triggered by Downlinks"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } // TODO: Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/pressure-lorawan/index.html","text":"Pressure Sensor LoRaWAN Order number: 8000089 Multiple different Variants There are different kinds of Pressure Probes that use very different kinds of communication. As a consequence there exist different Variants of our Hardware for using Pressure Probes. Please take care that you only install the correct Variant of firmware on your device. Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Precise liquid level measurement, e.g. for tanks, via LoRaWAN. Features Cable length 1-15m 0..1,5 Bar (15m water level) Waterproof IP66 Housing Multi-year Battery life, ultra low power (~ 20\u00b5A) Configuration The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter . Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages , see Downlinks description. LoRaWAN Advanced Lobaro LoRaWAN Stack The Hardware Variant Keller Sensor uses our advanced LoRaWAN Stack and supports Remote Configuration and LoRaWAN V1.1, starting with firmware v0.3.0. Refer to Lobaro LoRaWAN stack for a description of those new features. Older Versions and the Variant Lobaro Sensor only support the features described here. The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot Operation Configuration values defining the behaviour of the device. The Min and Max values will be preconfigured when receiving the device. In case of using \"Restore Default\" they will be reset to standard values and have to be set again using the values printed on the sensor or given separately. name description example value sendCron Cron expression defining when to read and send 0 0/15 * * * * for every 15 minutes rangeMin min range in mh2o in most cases 0 rangeMax max range in mh2o in most cases 15 outputMin min digital output value of the sensor in most cases 819 outputMax max digital output value of the sensor in most cases 11664 See also our Introduction to Cron expressions . Payload Format Port: 1 Payload: 8 Bytes Temperature is transmitted in 1/100\u00b0C, battery voltage in Millivolt and pressure in Bar. PRESSURE PRESSURE PRESSURE PRESSURE TEMP TEMP V_BATT V_BATT flaot32 float32 float32 float32 int16 int16 int16 int16 Byte 0 Byte 1 Byte 2 Byte 3 LSB MSB LSB MSB Parser Element-IoT : https://github.com/ZennerIoT/element-parsers/blob/master/lib/lobaro_pressure26d.ex The Things Network function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , v_batt : decodeInt16 ( int16_LE ( bytes , 6 )) / 1000 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; } CE Declaration of Conformity CE Declaration of Conformity (pdf).","title":"Manual"},{"location":"lorawan-sensors/pressure-lorawan/index.html#pressure-sensor-lorawan","text":"Order number: 8000089 Multiple different Variants There are different kinds of Pressure Probes that use very different kinds of communication. As a consequence there exist different Variants of our Hardware for using Pressure Probes. Please take care that you only install the correct Variant of firmware on your device. Consider using the latest firmware on your hardware See available firmware downloads","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/index.html#target-measurement-purpose","text":"Precise liquid level measurement, e.g. for tanks, via LoRaWAN. Features Cable length 1-15m 0..1,5 Bar (15m water level) Waterproof IP66 Housing Multi-year Battery life, ultra low power (~ 20\u00b5A)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/pressure-lorawan/index.html#configuration","text":"The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter . Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages , see Downlinks description.","title":"Configuration"},{"location":"lorawan-sensors/pressure-lorawan/index.html#lorawan","text":"Advanced Lobaro LoRaWAN Stack The Hardware Variant Keller Sensor uses our advanced LoRaWAN Stack and supports Remote Configuration and LoRaWAN V1.1, starting with firmware v0.3.0. Refer to Lobaro LoRaWAN stack for a description of those new features. Older Versions and the Variant Lobaro Sensor only support the features described here. The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot","title":"LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. The Min and Max values will be preconfigured when receiving the device. In case of using \"Restore Default\" they will be reset to standard values and have to be set again using the values printed on the sensor or given separately. name description example value sendCron Cron expression defining when to read and send 0 0/15 * * * * for every 15 minutes rangeMin min range in mh2o in most cases 0 rangeMax max range in mh2o in most cases 15 outputMin min digital output value of the sensor in most cases 819 outputMax max digital output value of the sensor in most cases 11664 See also our Introduction to Cron expressions .","title":"Operation"},{"location":"lorawan-sensors/pressure-lorawan/index.html#payload-format","text":"Port: 1 Payload: 8 Bytes Temperature is transmitted in 1/100\u00b0C, battery voltage in Millivolt and pressure in Bar. PRESSURE PRESSURE PRESSURE PRESSURE TEMP TEMP V_BATT V_BATT flaot32 float32 float32 float32 int16 int16 int16 int16 Byte 0 Byte 1 Byte 2 Byte 3 LSB MSB LSB MSB","title":"Payload Format"},{"location":"lorawan-sensors/pressure-lorawan/index.html#parser","text":"Element-IoT : https://github.com/ZennerIoT/element-parsers/blob/master/lib/lobaro_pressure26d.ex The Things Network function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , v_batt : decodeInt16 ( int16_LE ( bytes , 6 )) / 1000 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Parser"},{"location":"lorawan-sensors/pressure-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html","text":"Pressure Sensor LoRaWAN There exist different Variants of our Hardware with Pressure Probes, because there exist very different Pressure Probes for different situations. Please make sure to install the correct firmware for your Hardware. You can see which firmware your device is running, by checking the log with our config adapter, while the device is booting. Pressure Sensor [Lobaro Sensor] Firmware Downloads : app-lobaro-pressure-0.1.0.hex [current release] app-lobaro-pressure-0.0.3.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog [0.1.0] (22.10.2019) [current release] Added configuration parameters for sensor limits [0.0.3] (30.09.2019) initial release Pressure Sensor LoRaWAN [Keller Sensor] Firmware app-keller-pressure-TZ0-0.3.0.hex [current release] app-keller-pressure-0.2.0.hex app-keller-pressure-0.0.3.hex Changelog v0.3.0 (20.02.2020) Changed to use new Lobaro LoRaWAN stack with remote config. WARNING: default value for AppKey/JoinEUI changed! v0.2.0 (22.07.2019) Added Battery Voltage to payload v0.0.3 (14.02.2019) Reduce I2C speed from 10kHz to 1kHz for 10m cable v0.0.2 Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz v0.0.1 inital version","title":"Firmware & Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#pressure-sensor-lorawan","text":"There exist different Variants of our Hardware with Pressure Probes, because there exist very different Pressure Probes for different situations. Please make sure to install the correct firmware for your Hardware. You can see which firmware your device is running, by checking the log with our config adapter, while the device is booting.","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#pressure-sensor-lobaro-sensor","text":"","title":"Pressure Sensor [Lobaro Sensor]"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#firmware","text":"Downloads : app-lobaro-pressure-0.1.0.hex [current release] app-lobaro-pressure-0.0.3.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#010-22102019-current-release","text":"Added configuration parameters for sensor limits","title":"[0.1.0] (22.10.2019) [current release]"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#003-30092019","text":"initial release","title":"[0.0.3] (30.09.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#pressure-sensor-lorawan-keller-sensor","text":"","title":"Pressure Sensor LoRaWAN [Keller Sensor]"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#firmware_1","text":"app-keller-pressure-TZ0-0.3.0.hex [current release] app-keller-pressure-0.2.0.hex app-keller-pressure-0.0.3.hex","title":"Firmware"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#changelog_1","text":"","title":"Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v030-20022020","text":"Changed to use new Lobaro LoRaWAN stack with remote config. WARNING: default value for AppKey/JoinEUI changed!","title":"v0.3.0 (20.02.2020)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v020-22072019","text":"Added Battery Voltage to payload","title":"v0.2.0 (22.07.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v003-14022019","text":"Reduce I2C speed from 10kHz to 1kHz for 10m cable","title":"v0.0.3 (14.02.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v002","text":"Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz","title":"v0.0.2"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v001","text":"inital version","title":"v0.0.1"},{"location":"lorawan-sensors/usonic-lorawan/index.html","text":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\") Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Distance measurements via ultrasound. Features 30cm to 3m detection range up to 8 detected objects Technical description The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match. The sensor can detect multiple \"objects\" the LoRaWAN Payload only contains the first one! Open Top vs. Closed Top As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts. Configuration LoRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Ultrasonic Parameters Parameters specific to the sensor. name type description ReadDistCron String Cron to start the Distrance readout, blank=DISABLE (See: CRON Expressions ) UsonicPreset Int Preset for Ultrasonic for custom Firmwares (keep the default!) UsonicTest Bool Enables Test-Mode, Measurement is executed and logged permanently LogDump Bool Also log the Raw Data Dump of the Ultrasonic sensor Parser The Things Network (TTN) This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result Note Currently only the first detected object is uploaded via LoRaWAN! { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold. Encoder Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; } CE Declaration of Conformity CE Declaration of Conformity (pdf).","title":"Manual"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ultrasonic-lorawan-sensor-aka-oscar","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\")"},{"location":"lorawan-sensors/usonic-lorawan/index.html#target-measurement-purpose","text":"Distance measurements via ultrasound. Features 30cm to 3m detection range up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/usonic-lorawan/index.html#technical-description","text":"The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match. The sensor can detect multiple \"objects\" the LoRaWAN Payload only contains the first one!","title":"Technical description"},{"location":"lorawan-sensors/usonic-lorawan/index.html#open-top-vs-closed-top","text":"As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts.","title":"Open Top vs. Closed Top"},{"location":"lorawan-sensors/usonic-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/usonic-lorawan/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN Parameters"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ultrasonic-parameters","text":"Parameters specific to the sensor. name type description ReadDistCron String Cron to start the Distrance readout, blank=DISABLE (See: CRON Expressions ) UsonicPreset Int Preset for Ultrasonic for custom Firmwares (keep the default!) UsonicTest Bool Enables Test-Mode, Measurement is executed and logged permanently LogDump Bool Also log the Raw Data Dump of the Ultrasonic sensor","title":"Ultrasonic Parameters"},{"location":"lorawan-sensors/usonic-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/usonic-lorawan/index.html#the-things-network-ttn","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result Note Currently only the first detected object is uploaded via LoRaWAN! { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold.","title":"The Things Network (TTN)"},{"location":"lorawan-sensors/usonic-lorawan/index.html#encoder","text":"Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; }","title":"Encoder"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html","text":"USonic LoRaWAN Firmware Downloads: app-lorawan-usonic-0.1.1.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Changelog Firmware: app-lorawan-usonic v0.1.1 Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"Firmware & Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#usonic-lorawan","text":"","title":"USonic LoRaWAN"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-usonic-0.1.1.hex Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"Firmware"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#changelog","text":"Firmware: app-lorawan-usonic","title":"Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#v011","text":"Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"v0.1.1"},{"location":"lorawan-sensors/wmbus-lorawan/index.html","text":"Wireless mBUS over LoRaWAN Bridge V2 Version v2.x (since 2020-02-18) This is the latest version. The previous v1.x documentation can be found here: doc v1.x . Key Features LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Wireless MBus S1, C1 and T1 modes (868 MHz) compatible Learning mode of meter tx intervals for optimal battery lifetime Configuration via USB or remotely via LoRaWAN downlink Big 19Ah size \"D\" battery for 10 years+ possible battery lifetime IP67 outdoor housing with pressure compensating element Quick closing screws with cover retainer on housing Optional: Lobaro wireless MBUS parsing REST API (free for testing) Optional: complete Lobaro IoT Platform integration Overview The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energy efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 utility meters via any LoRaWAN network onto the Internet. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Note: The Lobaro IoT platform is fully optional! Many gas, water, electricity and heat meters can be read wirelessly using the common short range 868 MHz wireless M-Bus / OMS industry standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is designed for less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data over larger distances onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is one of such a key technologies. You can find details about LoRaWAN in our background article . Please use always the latest firmware on your lorawan wmbus bridge! Check latest firmware releases available for download Compatible meters wMBUS meter Type Manufacturer More information Q caloric 5.5 Heat cost Qundis External Link Sontex 868 Heat cost Sontex External Link SHARKY 775 Heat Diehl Metering External Link MULTICAL\u00ae 603 Heat kampstrup External Link QALCOSONIC E1 Heat & Cooling Axioma Metering External Link Sonometer 30 Heat & Cooling Danfoss External Link INVONIC H Heat & Cooling Apator External Link iPERL\u00ae Water Sensus External Link Hydrus Water Diehl Metering External Link MULTICAL\u00ae 21 / flowIQ\u00ae 210x Water kampstrup External Link Q water 5.5 Water Qundis External Link Modularis yFlow Water addon Hermann Pipersberg External Link Munia Temp. & Humidity Weptech External Link Qalcosonic W1 (Honeywell Q400) Water Axioma Metering External Link Further utility meter compatibility Beside the example meters in the list above the Lobaro wMBUS LoRaWAN bridge works with every meter using standard 868 MHz wireless MBus: wireless MBUS S1, C1 or T1 mode (unidirectional 868 MHz modes following DIN EN 13757-4) Open metering specification v3 & v4 Work Cycle graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases. Initial Phase This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration. Data Collection Phase During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered. Data Transfer Phase During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\". Sleep Phase After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again. The wMBUS LoRaWAN Bridge Hardware revision 2.x (active since 2020) wMBUS LoRaWAN Bridge V2.0 (XH battery-connector, IP67 housing, DAE), PN: 8000095 Hardware revision 1.x (active since 2017) Please note revisions 1.x are no longer the default variant since 02/2020 The v1 hardware revisions are still active but only on special sales inquiry! Please contact Lobaro if you are interested in revisions 1.x hardware. Hardware differences The main differences between hardware revision 1.x and revision 2.x are: HW1.x has an additional on board temperature sensor (seldom used) HW1.x is available in a 2x AA cell (1.5V) variant with compact housing (rarely requested) HW1.x may be combined with external power supply addon (5V...30V) So the main reason to request revision 1.x is the smaller housing with two AA batteries or the need for an external power supply. The same firmware will always provided for both hardware revisions. Device installation The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clips. Mounting height Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal quarter wave monopole antenna can be identified by the pcb trace near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Power Supply The wMBUS over LoRaWAN Bridge default power supply consists of one connected 3.6V 'D' sized battery equipped with a JST XH 2pin connector. Size: D-Cell (34mm x 61.5mm) Connector: JST XH series Voltage: 3.6V Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable) Battery warning Other Batteries or accumulators with a nominal voltage of more or less than 3.6V must not used with the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.7V must not be used! On request we can supply custom product variants with with permanent external power supply (230V, 9-24V, 5V USB) or smaller AA batteries. Battery life time The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to support@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity. Example calculation In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. A real world image of a 4:1 (4 meters, 1 bridge) configuration can be found at the top of this documentation. The meter transmission interval is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"Configuration\"). This will ensure that all four meters of interest send their consumption telegrams at least once during the configured listen period of the bridge. For this example battery-lifetime calculation the weakest and best possible LoRaWAN connectivity will be compared. Weak means to reach a LoRaWAN Gateway the Lobaro bridge has to send its LoRaWAN uplinks very slowly (\u2265 2 seconds) and redundant by using LoRa spreading factor 12 (SF12). Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 have been calculated too. In both coverage scenarios covered the actual usable battery capacity has been set to 80% of the nominal value of 19Ah for the \"D\" sized mono 3.6V cell. The resulting worst-case minimal battery-life times in years for both coverage situations are presented below: Worst-Case Battery life with daily uploads of x meters using LoRa SF12 and SF7: Collected meters Battery life @ SF12 Battery life @SF7 1 24.3 40.0 5 15.0 38.1 10 9.1 35.2 20 5.1 30.6 40 2.7 24.3 80 1.4 17.2 All battery life numbers denote years Usage scenario recommendations As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transferred by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT). Configuration The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter to be connected to the \"config\" connector on the hardware. Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages . LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot wMBUS bridge name description values payloadFormat wMBUS Bridge LoRaWAN Payload Format 0 = Encoding in ports, 1 = prefixed with time, 2 = prefixed with time and rssi loraMaxMsgSize Max. LoRa msg size before split (Payload Format 0 only) 10 - 50 (bytes) listenCron Cron expression \u2020 defining when to rx wMBUS 0 0/15 * * * * (every 15 minutes) cmodeDurSec Duration (Seconds) of C1/T1-mode receive 0 = Do not collect C1/T1 mode smodeDurSec Duration (Seconds) of S1-mode receive 0 = Do not collect S1 mode mFilter wMBus manufacturer filter sep. by \",\" e.g. \"dme,itw\" blank = no filter typFilter wMBus device type filter e.g. \"08,07\" for Heat Coast and Water blank = no filter devFilter wMBus id filter e.g. \"88009035, 06198833\" (8 digits) blank = no filter learningMode Enable tx interval learning mode false = Do not use learning mode meterIntervalSec Expected meter tx interval 0 (Learning mode) learnedListenSec Listen time with learned meeters. 600 (Learning mode) \u2020 See also our Introduction to Cron expressions . Learning Mode The larning mode can be enabled by setting learningMode = true in the configuration. If meterIntervalSec is set to 0 the algorithm will try to learn the tx intervals intervals and times of up to 20 meters to conserve energy When a device is received the first time, it is added to an internal list of known devices. When received the second time the wMBUS transmission interval is calculated. The second step is omitted when meterIntervalSec ist set to any value but 0 . When missing one device for whatever reason, the bridge will start the learning phase again. Learning of individual intervals can be skipped by setting meterIntervalSec to a value that is valid for all meters. If meterIntervalSec is 0 the bridge will wait for two packets from each wMbus device and calculates the sending interval based on the times. This might not always be correct due to possible jitter. Procedure Power ON. Enter \"learning Phase\" and listen for 2x _modeDurSec if meterIntervalSec , else for _modeDurSec . Create an internal list with up to 20 meters, with either individual intervals or all intervals set to meterIntervalSec . On next listenCron only wake up as little as possible based on the learned data. When any learned meter is missing, goto 2. else sleep till listenCron . Example A meter sends with jitter every 55-65 seconds. The bridge might learn an interval of 55 seconds after observing 2 messages around 12:00:00. The bridge will expect next data at 12:00:55, 12:01:50, 12:02:45, etc. and probably miss data, which leads to a new learning phase. When setting the meterIntervalSec to 60 the bridge needs only one wMbus packet e.g. at 12:00:00 and expects the next packets at 12:01:00, 12:02:00, etc. which is closer to reality. To account possible jitter learnedListenSec can be used to tell the bridge how long it should stay awake to receive a meter at a learned point in time. learnedListenSec = 30 would wake up 15 seconds before the expected time and wait until the expected wMbus telegram is received or after 30 seconds. Payload formats After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge. M-Bus telegrams can be longer as the maximal size of a LoRaWAN-Message. For this cases, the Bridge needs to split a telegram into multiple pieces and upload it using multiple LoRaWAN-Messages. There are two different methods this is done, according by the Payload Format you set in the Bridge's configuration. Payload Format 0 is focused on easy reassembly of the pieces. The parts are encoded by port numbers and the data can just be concatenated together. Payload Formats 1 and 2 add additional information to the telegram. They focus on putting as much of a telegram in a single LoRaWAN-Message as possible with respecting the current Spreading Factor. Status Packet Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C Temperature Sensor The temperature sensor is not present anymore on dedicated V2 hardware, instead 0xffff will be returned. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network . Data Packet (Format 0) After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before. Note Reference Implementation in GoLang Examples Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend. Data Packet (Format 1) When using Payload Format 1, collected telegrams are uploaded on a single Port: 101. For each telegram there will be added the timestamp of reception. The first byte of messages on Port 101 encodes splitting of messages as follows. Splitting Every Uplink on Port 101 is prefixed with a single byte, where the least significant Bit indicates if that Uplink is the first part of a message, and the second least significant Bit indicates if that Uplink is the last part or a message. So there are 4 different possible values for the first Byte of an Uplink on Port 101: Value Meaning 0x03 This Uplink is both first and final part of a message. So the remaining Bytes in this Uplink contain the whole message. 0x02 This Uplink is the last but not the first part of a message. There has been at least one Uplink before this one, that contained data that needs to be prepended to the current Uplink in order to get the full Message 0x01 This Uplink is the first but not the last part of a message. There follows at least one Uplink that contains more data to be appended to the current's data in order to get the full message. 0x00 This Uplink is neither first nor last part of a message. There has been at least one Uplink before this one that contains more data of the current Message, and there follows at least one more Uplink with data for this Message. So each message sent on Port 101, whether it is contained in a single Uplink or spread over multiple ones, starts with an Uplink where the least significant Bit of the first Byte is set. Each Message ends with an Uplink where the second least significant Bit of the first Byte is set. In cases where the Message fits in a single Uplink, that Uplink is both first and last Uplink, and therefore both Bits are set. The combination of those two Bits and the Frame Counter of the Uplinks makes it possible to upload Messages of any length while allowing the receiving side to now exactly, if a Message has been transferred completely, or if part of it is missing (when there are Frame Counter values missing). The Bridge puts as many Bytes in each Uplink as possible for the current Spreading Factor, even if the Spreading Factor changes between Uplinks because of ADR. When the data of all Uplinks that are part of a single Message are appended in order of reception (after removing the first Byte of each Uplink), you get the payload Data of a full message. Payload (Format 1) The Payload Data after reassembly of the split parts consists of a 5 Byte Timestamp, that marks the point in time the Bridge did receive that telegram, followed by the Data of the Telegram. The Timestamp follows the convention of all our 40bit-Timestamps; you can find the details under Timestamp in our LoRaWAN Background Information . Examples For easier understanding, the wMBus-Telegram in the examples will always be 0102030405060708090a0b0c0d0e0f . A message sent in a single Uplink # An Uplink of 21 Bytes on Port 101: '03005e53f31a0102030405060708090a0b0c0d0e0f' # Analised: '03' -> First and Last Uplink of Message -> complete Message in this Uplink '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram A message split over two Uplinks # An Uplink of 11 Bytes on Port 101, Frame Counter 341: '01005e53f31a0102030405' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102030405' -> First Part of Message Data. # Another Uplink of 11 Bytes on Port 101, Frame Counter 342: '02060708090a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '060708090a0b0c0d0e0f' -> Second and final Part of Message Data. # We Received a 'first' Part with Frame Counter 341 and a 'last' # Part with Frame Counter 342, so we know we did not miss any # Parts in between. We can now assembly the complete payload: '05e53f31a0102030405060708090a0b0c0d0e0f' # Payload anaylsed: '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram A message split over three Uplinks # An Uplink of 8 Bytes on Port 101, Frame Counter 519: '01005e53f31a0102' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102' -> First Part of Message Data. # Another Uplink of 8 Bytes on Port 101, Frame Counter 520: '0003040506070809' '00' -> Middle Part of Message, there have been some Parts already, more Uplinks follow '03040506070809' -> Second Part of Message Data. # Another Uplink of 7 Bytes on Port 101, Frame Counter 521: '020a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '0a0b0c0d0e0f' -> Third and final Part of Message Data. # Frame Counters are consecuetive, so the complete Message is: '05e53f31a0102030405060708090a0b0c0d0e0f' Missing a Part # An Uplink of 8 Bytes on Port 101, Frame Counter 123: '01005e53f31a0102' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102' -> First Part of Message Data. # Another Uplink of 7 Bytes on Port 101, Frame Counter 125: '020a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '0a0b0c0d0e0f' -> Third and final Part of Message Data. # Frame Counter indicates, that a Part in the middle is missing, # so we have to drop the Message. Data Packet (Format 2) Upload Format 2 works like Upload Format 1, with the same logic for splitting messages, but uploads are sent on Port 102. The Payload consists of a 5 Byte Timestamp marking the time of reception, followed by a uint_8 that holds the (negated) RSSI value for that reception, followed by the Data of the Telegram. Examples # An Uplink of 22 Bytes on Port 102: '03005e53f31a3f0102030405060708090a0b0c0d0e0f' # Analised: '03' -> First and Last Uplink of Message -> complete Message in this Uplink '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '3f' -> 63 -> RSSI of wMBus reception = -63 '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram Upload Speed / Duration The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams via LoRaWAN for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which defines how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured listenCron parameter. Because of this it is advisable to define the cron parameter with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases. Decoding wMBUS telegrams After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided. You can access the decoder service for free during testing. The API can be licensed for production usages. Free online wMBUS decoder (for testing) Lobaro wMBUS Online Parser Lobaro wMBUS REST API Your meter fails to parse correctly? Since wireless MBUS is a complex and grown specification some meters may fail to decode correctly. We try to fix any decoding issues as quickly as possible if you report us problems with your specific wMBUS device. Optional: Lobaro IoT Platform The bridge can also be integrated in the Lobaro IoT platform with the following benefits: wMBUS data reassembling from raw (partial) LoRaWAN uplinks Wireless MBUS data decryption Device management including remote configuration Std. Web APIs to connect external services REST MQTT HTTP Push CSV Exports LoRaWAN data import from many common LoRaWAN network servers: TheThingsNetwork (TTN) ShirpStack Element-IoT Actility Loriot Firefly Everynet Free 12 months test account Please contact Lobaro if you are interested in a free 12 months test account for your 1 st bridge. Technical characteristics Product Type name wMBUS-LoRaWAN-R2 Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory 32KByte (up to 500 telegrams) Power Supply Nominal Supply Voltage 3.6V Supply Voltage Range 2.2V - 3.7V Power supply 3.6V ER34615 3.6V battery Current consumption @3.6V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226415 \u00b5A Mechanical dimensions Size 122 mm x 82 mm x 55 mm Housing Material Industrial polycarbonate Rating IP67 Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Specifications of hardware revisions v1.x can be found in the previous documentation . Housing Specification & Accessories The Lobaro wireless Mbus bridge uses the TG PC 1208-6-o feature rich IP67 housing from Spelsberg. For this housing the following accessories are available on request: Sealing kit (TG PST1) : May be used to seal the box to complicate unauthorized access to the device. External fixing lugs (TG ABL) : Allow the mounting without opening the (sealed) cover. CE Declaration of Conformity CE Declaration of Conformity - Rev1 HW CE Declaration of Conformity - Rev2 HW Example Parser TTN function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"Manual"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#wireless-mbus-over-lorawan-bridge-v2","text":"Version v2.x (since 2020-02-18) This is the latest version. The previous v1.x documentation can be found here: doc v1.x .","title":"Wireless mBUS over LoRaWAN Bridge V2"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#key-features","text":"LoRaWAN 1.0.x and 1.1 network servers supported LoRaWAN Class A or Class C operation LoRaWAN 1.1 time synchronisation Wireless MBus S1, C1 and T1 modes (868 MHz) compatible Learning mode of meter tx intervals for optimal battery lifetime Configuration via USB or remotely via LoRaWAN downlink Big 19Ah size \"D\" battery for 10 years+ possible battery lifetime IP67 outdoor housing with pressure compensating element Quick closing screws with cover retainer on housing Optional: Lobaro wireless MBUS parsing REST API (free for testing) Optional: complete Lobaro IoT Platform integration","title":"Key Features"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#overview","text":"The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energy efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 utility meters via any LoRaWAN network onto the Internet. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Note: The Lobaro IoT platform is fully optional! Many gas, water, electricity and heat meters can be read wirelessly using the common short range 868 MHz wireless M-Bus / OMS industry standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is designed for less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data over larger distances onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is one of such a key technologies. You can find details about LoRaWAN in our background article . Please use always the latest firmware on your lorawan wmbus bridge! Check latest firmware releases available for download","title":"Overview"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#compatible-meters","text":"wMBUS meter Type Manufacturer More information Q caloric 5.5 Heat cost Qundis External Link Sontex 868 Heat cost Sontex External Link SHARKY 775 Heat Diehl Metering External Link MULTICAL\u00ae 603 Heat kampstrup External Link QALCOSONIC E1 Heat & Cooling Axioma Metering External Link Sonometer 30 Heat & Cooling Danfoss External Link INVONIC H Heat & Cooling Apator External Link iPERL\u00ae Water Sensus External Link Hydrus Water Diehl Metering External Link MULTICAL\u00ae 21 / flowIQ\u00ae 210x Water kampstrup External Link Q water 5.5 Water Qundis External Link Modularis yFlow Water addon Hermann Pipersberg External Link Munia Temp. & Humidity Weptech External Link Qalcosonic W1 (Honeywell Q400) Water Axioma Metering External Link Further utility meter compatibility Beside the example meters in the list above the Lobaro wMBUS LoRaWAN bridge works with every meter using standard 868 MHz wireless MBus: wireless MBUS S1, C1 or T1 mode (unidirectional 868 MHz modes following DIN EN 13757-4) Open metering specification v3 & v4","title":"Compatible meters"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#work-cycle","text":"graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases.","title":"Work Cycle"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#lorawan-join-phase","text":"If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-collection-phase","text":"During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered.","title":"Data Collection Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\".","title":"Data Transfer Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#sleep-phase","text":"After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again.","title":"Sleep Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#the-wmbus-lorawan-bridge","text":"","title":"The wMBUS LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#hardware-revision-2x-active-since-2020","text":"wMBUS LoRaWAN Bridge V2.0 (XH battery-connector, IP67 housing, DAE), PN: 8000095","title":"Hardware revision 2.x (active since 2020)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#hardware-revision-1x-active-since-2017","text":"Please note revisions 1.x are no longer the default variant since 02/2020 The v1 hardware revisions are still active but only on special sales inquiry! Please contact Lobaro if you are interested in revisions 1.x hardware.","title":"Hardware revision 1.x (active since 2017)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#hardware-differences","text":"The main differences between hardware revision 1.x and revision 2.x are: HW1.x has an additional on board temperature sensor (seldom used) HW1.x is available in a 2x AA cell (1.5V) variant with compact housing (rarely requested) HW1.x may be combined with external power supply addon (5V...30V) So the main reason to request revision 1.x is the smaller housing with two AA batteries or the need for an external power supply. The same firmware will always provided for both hardware revisions.","title":"Hardware differences"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#device-installation","text":"The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clips. Mounting height Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal quarter wave monopole antenna can be identified by the pcb trace near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Device installation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#power-supply","text":"The wMBUS over LoRaWAN Bridge default power supply consists of one connected 3.6V 'D' sized battery equipped with a JST XH 2pin connector. Size: D-Cell (34mm x 61.5mm) Connector: JST XH series Voltage: 3.6V Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable) Battery warning Other Batteries or accumulators with a nominal voltage of more or less than 3.6V must not used with the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.7V must not be used! On request we can supply custom product variants with with permanent external power supply (230V, 9-24V, 5V USB) or smaller AA batteries.","title":"Power Supply"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#battery-life-time","text":"The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to support@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity.","title":"Battery life time"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#example-calculation","text":"In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. A real world image of a 4:1 (4 meters, 1 bridge) configuration can be found at the top of this documentation. The meter transmission interval is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"Configuration\"). This will ensure that all four meters of interest send their consumption telegrams at least once during the configured listen period of the bridge. For this example battery-lifetime calculation the weakest and best possible LoRaWAN connectivity will be compared. Weak means to reach a LoRaWAN Gateway the Lobaro bridge has to send its LoRaWAN uplinks very slowly (\u2265 2 seconds) and redundant by using LoRa spreading factor 12 (SF12). Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 have been calculated too. In both coverage scenarios covered the actual usable battery capacity has been set to 80% of the nominal value of 19Ah for the \"D\" sized mono 3.6V cell. The resulting worst-case minimal battery-life times in years for both coverage situations are presented below: Worst-Case Battery life with daily uploads of x meters using LoRa SF12 and SF7: Collected meters Battery life @ SF12 Battery life @SF7 1 24.3 40.0 5 15.0 38.1 10 9.1 35.2 20 5.1 30.6 40 2.7 24.3 80 1.4 17.2 All battery life numbers denote years","title":"Example calculation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#usage-scenario-recommendations","text":"As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transferred by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT).","title":"Usage scenario recommendations"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#configuration","text":"The (initial) configuration is normally done using our free Lobaro Maintenance Tool and the USB PC configuation adapter to be connected to the \"config\" connector on the hardware. Beside this the configuration can also be changed or read remotely in the field using LoRaWAN downlink messages .","title":"Configuration"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. For a detailed introduction into how this values need to be configured, please refer to the chapter LoRaWAN configuration in our LoRaWAN background article. Name Description Type Values OTAA Activation: OTAA or ABP bool true = use OTAA, false = use ABP DevEUI DevEUI used to identify the Device byte[8] e.g. 0123456789abcdef JoinEUI Used for OTAA (called AppEUI in v1.0) byte[8] e.g. 0123456789abcdef AppKey Key used for OTAA (v1.0 and v1.1) byte[16] NwkKey Key used for OTAA (v1.1 only) byte[16] SF Initial / maximum Spreading Factor int 7 - 12 ADR Use Adaptive Data Rate bool true = use ADR, false = don't OpMode Operation Mode string A = Class A, C = Class C TimeSync Days after which to sync time int days, 0 =don't sync time RndDelay Random delay before sending int max seconds RemoteConf Support Remote Configuration bool true =allow, false =deactivate LostReboot Days without downlink before reboot int days, 0 =don't reboot","title":"LoRaWAN"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#wmbus-bridge","text":"name description values payloadFormat wMBUS Bridge LoRaWAN Payload Format 0 = Encoding in ports, 1 = prefixed with time, 2 = prefixed with time and rssi loraMaxMsgSize Max. LoRa msg size before split (Payload Format 0 only) 10 - 50 (bytes) listenCron Cron expression \u2020 defining when to rx wMBUS 0 0/15 * * * * (every 15 minutes) cmodeDurSec Duration (Seconds) of C1/T1-mode receive 0 = Do not collect C1/T1 mode smodeDurSec Duration (Seconds) of S1-mode receive 0 = Do not collect S1 mode mFilter wMBus manufacturer filter sep. by \",\" e.g. \"dme,itw\" blank = no filter typFilter wMBus device type filter e.g. \"08,07\" for Heat Coast and Water blank = no filter devFilter wMBus id filter e.g. \"88009035, 06198833\" (8 digits) blank = no filter learningMode Enable tx interval learning mode false = Do not use learning mode meterIntervalSec Expected meter tx interval 0 (Learning mode) learnedListenSec Listen time with learned meeters. 600 (Learning mode) \u2020 See also our Introduction to Cron expressions .","title":"wMBUS bridge"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#learning-mode","text":"The larning mode can be enabled by setting learningMode = true in the configuration. If meterIntervalSec is set to 0 the algorithm will try to learn the tx intervals intervals and times of up to 20 meters to conserve energy When a device is received the first time, it is added to an internal list of known devices. When received the second time the wMBUS transmission interval is calculated. The second step is omitted when meterIntervalSec ist set to any value but 0 . When missing one device for whatever reason, the bridge will start the learning phase again. Learning of individual intervals can be skipped by setting meterIntervalSec to a value that is valid for all meters. If meterIntervalSec is 0 the bridge will wait for two packets from each wMbus device and calculates the sending interval based on the times. This might not always be correct due to possible jitter. Procedure Power ON. Enter \"learning Phase\" and listen for 2x _modeDurSec if meterIntervalSec , else for _modeDurSec . Create an internal list with up to 20 meters, with either individual intervals or all intervals set to meterIntervalSec . On next listenCron only wake up as little as possible based on the learned data. When any learned meter is missing, goto 2. else sleep till listenCron . Example A meter sends with jitter every 55-65 seconds. The bridge might learn an interval of 55 seconds after observing 2 messages around 12:00:00. The bridge will expect next data at 12:00:55, 12:01:50, 12:02:45, etc. and probably miss data, which leads to a new learning phase. When setting the meterIntervalSec to 60 the bridge needs only one wMbus packet e.g. at 12:00:00 and expects the next packets at 12:01:00, 12:02:00, etc. which is closer to reality. To account possible jitter learnedListenSec can be used to tell the bridge how long it should stay awake to receive a meter at a learned point in time. learnedListenSec = 30 would wake up 15 seconds before the expected time and wait until the expected wMbus telegram is received or after 30 seconds.","title":"Learning Mode"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#payload-formats","text":"After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge. M-Bus telegrams can be longer as the maximal size of a LoRaWAN-Message. For this cases, the Bridge needs to split a telegram into multiple pieces and upload it using multiple LoRaWAN-Messages. There are two different methods this is done, according by the Payload Format you set in the Bridge's configuration. Payload Format 0 is focused on easy reassembly of the pieces. The parts are encoded by port numbers and the data can just be concatenated together. Payload Formats 1 and 2 add additional information to the telegram. They focus on putting as much of a telegram in a single LoRaWAN-Message as possible with respecting the current Spreading Factor.","title":"Payload formats"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#status-packet","text":"Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C Temperature Sensor The temperature sensor is not present anymore on dedicated V2 hardware, instead 0xffff will be returned. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network .","title":"Status Packet"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-packet-format-0","text":"After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before. Note Reference Implementation in GoLang","title":"Data Packet (Format 0)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#examples","text":"Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend.","title":"Examples"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-packet-format-1","text":"When using Payload Format 1, collected telegrams are uploaded on a single Port: 101. For each telegram there will be added the timestamp of reception. The first byte of messages on Port 101 encodes splitting of messages as follows.","title":"Data Packet (Format 1)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#splitting","text":"Every Uplink on Port 101 is prefixed with a single byte, where the least significant Bit indicates if that Uplink is the first part of a message, and the second least significant Bit indicates if that Uplink is the last part or a message. So there are 4 different possible values for the first Byte of an Uplink on Port 101: Value Meaning 0x03 This Uplink is both first and final part of a message. So the remaining Bytes in this Uplink contain the whole message. 0x02 This Uplink is the last but not the first part of a message. There has been at least one Uplink before this one, that contained data that needs to be prepended to the current Uplink in order to get the full Message 0x01 This Uplink is the first but not the last part of a message. There follows at least one Uplink that contains more data to be appended to the current's data in order to get the full message. 0x00 This Uplink is neither first nor last part of a message. There has been at least one Uplink before this one that contains more data of the current Message, and there follows at least one more Uplink with data for this Message. So each message sent on Port 101, whether it is contained in a single Uplink or spread over multiple ones, starts with an Uplink where the least significant Bit of the first Byte is set. Each Message ends with an Uplink where the second least significant Bit of the first Byte is set. In cases where the Message fits in a single Uplink, that Uplink is both first and last Uplink, and therefore both Bits are set. The combination of those two Bits and the Frame Counter of the Uplinks makes it possible to upload Messages of any length while allowing the receiving side to now exactly, if a Message has been transferred completely, or if part of it is missing (when there are Frame Counter values missing). The Bridge puts as many Bytes in each Uplink as possible for the current Spreading Factor, even if the Spreading Factor changes between Uplinks because of ADR. When the data of all Uplinks that are part of a single Message are appended in order of reception (after removing the first Byte of each Uplink), you get the payload Data of a full message.","title":"Splitting"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#payload-format-1","text":"The Payload Data after reassembly of the split parts consists of a 5 Byte Timestamp, that marks the point in time the Bridge did receive that telegram, followed by the Data of the Telegram. The Timestamp follows the convention of all our 40bit-Timestamps; you can find the details under Timestamp in our LoRaWAN Background Information .","title":"Payload (Format 1)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#examples_1","text":"For easier understanding, the wMBus-Telegram in the examples will always be 0102030405060708090a0b0c0d0e0f . A message sent in a single Uplink # An Uplink of 21 Bytes on Port 101: '03005e53f31a0102030405060708090a0b0c0d0e0f' # Analised: '03' -> First and Last Uplink of Message -> complete Message in this Uplink '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram A message split over two Uplinks # An Uplink of 11 Bytes on Port 101, Frame Counter 341: '01005e53f31a0102030405' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102030405' -> First Part of Message Data. # Another Uplink of 11 Bytes on Port 101, Frame Counter 342: '02060708090a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '060708090a0b0c0d0e0f' -> Second and final Part of Message Data. # We Received a 'first' Part with Frame Counter 341 and a 'last' # Part with Frame Counter 342, so we know we did not miss any # Parts in between. We can now assembly the complete payload: '05e53f31a0102030405060708090a0b0c0d0e0f' # Payload anaylsed: '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram A message split over three Uplinks # An Uplink of 8 Bytes on Port 101, Frame Counter 519: '01005e53f31a0102' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102' -> First Part of Message Data. # Another Uplink of 8 Bytes on Port 101, Frame Counter 520: '0003040506070809' '00' -> Middle Part of Message, there have been some Parts already, more Uplinks follow '03040506070809' -> Second Part of Message Data. # Another Uplink of 7 Bytes on Port 101, Frame Counter 521: '020a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '0a0b0c0d0e0f' -> Third and final Part of Message Data. # Frame Counters are consecuetive, so the complete Message is: '05e53f31a0102030405060708090a0b0c0d0e0f' Missing a Part # An Uplink of 8 Bytes on Port 101, Frame Counter 123: '01005e53f31a0102' '01' -> First Uplink of Message, more Uplinks follow '05e53f31a0102' -> First Part of Message Data. # Another Uplink of 7 Bytes on Port 101, Frame Counter 125: '020a0b0c0d0e0f' '02' -> Last (but not first) Uplink of Message. '0a0b0c0d0e0f' -> Third and final Part of Message Data. # Frame Counter indicates, that a Part in the middle is missing, # so we have to drop the Message.","title":"Examples"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-packet-format-2","text":"Upload Format 2 works like Upload Format 1, with the same logic for splitting messages, but uploads are sent on Port 102. The Payload consists of a 5 Byte Timestamp marking the time of reception, followed by a uint_8 that holds the (negated) RSSI value for that reception, followed by the Data of the Telegram.","title":"Data Packet (Format 2)"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#examples_2","text":"# An Uplink of 22 Bytes on Port 102: '03005e53f31a3f0102030405060708090a0b0c0d0e0f' # Analised: '03' -> First and Last Uplink of Message -> complete Message in this Uplink '005e53f31a' -> Unix Timestamp 1582560026 -> 2020-02-24T16:00:26 UTC '3f' -> 63 -> RSSI of wMBus reception = -63 '0102030405060708090a0b0c0d0e0f' -> wMBus Telegram","title":"Examples"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#upload-speed-duration","text":"The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams via LoRaWAN for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which defines how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured listenCron parameter. Because of this it is advisable to define the cron parameter with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases.","title":"Upload Speed / Duration"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#decoding-wmbus-telegrams","text":"After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided. You can access the decoder service for free during testing. The API can be licensed for production usages. Free online wMBUS decoder (for testing) Lobaro wMBUS Online Parser Lobaro wMBUS REST API Your meter fails to parse correctly? Since wireless MBUS is a complex and grown specification some meters may fail to decode correctly. We try to fix any decoding issues as quickly as possible if you report us problems with your specific wMBUS device.","title":"Decoding wMBUS telegrams"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#optional-lobaro-iot-platform","text":"The bridge can also be integrated in the Lobaro IoT platform with the following benefits: wMBUS data reassembling from raw (partial) LoRaWAN uplinks Wireless MBUS data decryption Device management including remote configuration Std. Web APIs to connect external services REST MQTT HTTP Push CSV Exports LoRaWAN data import from many common LoRaWAN network servers: TheThingsNetwork (TTN) ShirpStack Element-IoT Actility Loriot Firefly Everynet Free 12 months test account Please contact Lobaro if you are interested in a free 12 months test account for your 1 st bridge.","title":"Optional: Lobaro IoT Platform"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#technical-characteristics","text":"Product Type name wMBUS-LoRaWAN-R2 Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory 32KByte (up to 500 telegrams) Power Supply Nominal Supply Voltage 3.6V Supply Voltage Range 2.2V - 3.7V Power supply 3.6V ER34615 3.6V battery Current consumption @3.6V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226415 \u00b5A Mechanical dimensions Size 122 mm x 82 mm x 55 mm Housing Material Industrial polycarbonate Rating IP67 Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Specifications of hardware revisions v1.x can be found in the previous documentation .","title":"Technical characteristics"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#housing-specification-accessories","text":"The Lobaro wireless Mbus bridge uses the TG PC 1208-6-o feature rich IP67 housing from Spelsberg. For this housing the following accessories are available on request: Sealing kit (TG PST1) : May be used to seal the box to complicate unauthorized access to the device. External fixing lugs (TG ABL) : Allow the mounting without opening the (sealed) cover.","title":"Housing Specification &amp; Accessories"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity - Rev1 HW CE Declaration of Conformity - Rev2 HW","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#example-parser","text":"","title":"Example Parser"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#ttn","text":"function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"TTN"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html","text":"Wireless mBUS over LoRaWAN Bridge The latest firmware version is v2.4.0 (since 2020-02-25) Which firmware version am I using right now? You can see the firmware version of your device by inspecting the USB log output in our PC maintenance tool. Or use the information send in the daily status uplink message send on LoRaWAN port 1 (see Status Packet ). How do I update the firmware? Please refer to Updating Firmware on the page about our Lobaro Maintenance Tool. Firmware Downloads Select correct Hardware revisions Due to permanent development there exist two main hardware revisions of the Lobaro wMBUS over LoRaWAN bridge hardware. Please use the images below to select the right firmware file for your given hardware. The (dedicated) revision 2.x has a simpler production process which helped us to optimize bigger deployments. Hardware Revision 2.x (active since 2020) Download: app-wMbusLoraBridge-2.4.0+hw2.hex (hardware v2.x) [current release] Hardware Revision 1.x (active since 2017) Download: app-wMbusLoraBridge-2.4.0+hw1.hex (hardware v1.x) [current release] Please note revisions 1.x are no longer the default variant since 02/2020 The v1 hardware revisions are still active but only on special sales inquiry! Please contact Lobaro if you are interested in revisions 1.x hardware. E-Mail release notifications Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox! Release changelog v2.4.0 (25.02.2020) Add new Payload Format 2, that includes RSSI of received wMBus telegrams. v2.3.10 (21.02.2020) Change naming of firmware-files to match naming of hardware variants (hw1/hw2). Minor fixes of some edge cases in underlying library on very high values. Add version number of Lobaro LoRaWAN-Stack to log. v2.3.9 (21.01.2020) Fix minor memory Leak in wMBus parser v2.3.8 (09.01.2020) Fix issue in mbus store which triggered raw system resets v2.3.7 (08.01.2020) Internal use only v2.3.6 (07.01.2020) Increase wireless MBUS C1/T1 mode receive bandwidth Change detection method for incoming C1/T1 mode telegrams v2.3.5 (23.12.2019) Improve wireless M-BUS C1/T1 mode receive sensitivity v2.3.4 (13.12.2019) Improve reset line usage (dedicated only) Fix issue with bad measurement timing for status message battery voltage v2.3.3 (10.12.2019) Optimize LoRaWAN RX1/RX2 window timing + add more precise downlink logs v2.3.2 (18.11.2019) Fix crash on receiving certain long non-standard telegrams. v2.3.1 (13.11.2019) Improve Filtering of non-standard wMBus-telegrams v2.3.0 (12.11.2019) Migrate to alternative dedicated board Fix Deep Sleep settings on dedicated board Fix rx/handling of S1-mode CRCs of unencrypted telegrams in wMBUS driver v2.2.0 (unreleased) Integrated with new LoRaWAN stack, now supporting v1.1, Class C, downlinks, ... v2.1.3 (11.03.2019) New Parameter: learnedListenSec to define how long to listen when meters was learned v2.1.2 (11.03.2019) Packet size depending on SF with payloadFormat = 1 v2.1.1 (20.02.2019) New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN frame counter, a whole message can be reconstructed in the backend. v2.0.0 (12.02.2019) Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received. Older v1.x firmware Old v1.x firmware version The v1.x firmware branch is no longer recommended for use. If you rely on these older version you can find it at the end of the outdated v1 documentation .","title":"Firmware & Changelog"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#wireless-mbus-over-lorawan-bridge","text":"The latest firmware version is v2.4.0 (since 2020-02-25) Which firmware version am I using right now? You can see the firmware version of your device by inspecting the USB log output in our PC maintenance tool. Or use the information send in the daily status uplink message send on LoRaWAN port 1 (see Status Packet ). How do I update the firmware? Please refer to Updating Firmware on the page about our Lobaro Maintenance Tool.","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#firmware-downloads","text":"Select correct Hardware revisions Due to permanent development there exist two main hardware revisions of the Lobaro wMBUS over LoRaWAN bridge hardware. Please use the images below to select the right firmware file for your given hardware. The (dedicated) revision 2.x has a simpler production process which helped us to optimize bigger deployments.","title":"Firmware Downloads"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#hardware-revision-2x-active-since-2020","text":"Download: app-wMbusLoraBridge-2.4.0+hw2.hex (hardware v2.x) [current release]","title":"Hardware Revision 2.x (active since 2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#hardware-revision-1x-active-since-2017","text":"Download: app-wMbusLoraBridge-2.4.0+hw1.hex (hardware v1.x) [current release] Please note revisions 1.x are no longer the default variant since 02/2020 The v1 hardware revisions are still active but only on special sales inquiry! Please contact Lobaro if you are interested in revisions 1.x hardware.","title":"Hardware Revision 1.x (active since 2017)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#e-mail-release-notifications","text":"Firmware Release Notifications We normally send e-mail notifications upon release of new firmware versions. To receive this mails you can sign up to the Lobaro newsletter here. Subscribe to our email newsletter here Make sure to select the \"Firmware Updates\" checkbox!","title":"E-Mail release notifications"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#release-changelog","text":"","title":"Release changelog"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v240-25022020","text":"Add new Payload Format 2, that includes RSSI of received wMBus telegrams.","title":"v2.4.0 (25.02.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v2310-21022020","text":"Change naming of firmware-files to match naming of hardware variants (hw1/hw2). Minor fixes of some edge cases in underlying library on very high values. Add version number of Lobaro LoRaWAN-Stack to log.","title":"v2.3.10 (21.02.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v239-21012020","text":"Fix minor memory Leak in wMBus parser","title":"v2.3.9 (21.01.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v238-09012020","text":"Fix issue in mbus store which triggered raw system resets","title":"v2.3.8 (09.01.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v237-08012020","text":"Internal use only","title":"v2.3.7 (08.01.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v236-07012020","text":"Increase wireless MBUS C1/T1 mode receive bandwidth Change detection method for incoming C1/T1 mode telegrams","title":"v2.3.6 (07.01.2020)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v235-23122019","text":"Improve wireless M-BUS C1/T1 mode receive sensitivity","title":"v2.3.5 (23.12.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v234-13122019","text":"Improve reset line usage (dedicated only) Fix issue with bad measurement timing for status message battery voltage","title":"v2.3.4 (13.12.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v233-10122019","text":"Optimize LoRaWAN RX1/RX2 window timing + add more precise downlink logs","title":"v2.3.3 (10.12.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v232-18112019","text":"Fix crash on receiving certain long non-standard telegrams.","title":"v2.3.2 (18.11.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v231-13112019","text":"Improve Filtering of non-standard wMBus-telegrams","title":"v2.3.1 (13.11.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v230-12112019","text":"Migrate to alternative dedicated board Fix Deep Sleep settings on dedicated board Fix rx/handling of S1-mode CRCs of unencrypted telegrams in wMBUS driver","title":"v2.3.0 (12.11.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v220-unreleased","text":"Integrated with new LoRaWAN stack, now supporting v1.1, Class C, downlinks, ...","title":"v2.2.0 (unreleased)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v213-11032019","text":"New Parameter: learnedListenSec to define how long to listen when meters was learned","title":"v2.1.3 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v212-11032019","text":"Packet size depending on SF with payloadFormat = 1","title":"v2.1.2 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v211-20022019","text":"New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN frame counter, a whole message can be reconstructed in the backend.","title":"v2.1.1 (20.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v200-12022019","text":"Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received.","title":"v2.0.0 (12.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#older-v1x-firmware","text":"Old v1.x firmware version The v1.x firmware branch is no longer recommended for use. If you rely on these older version you can find it at the end of the outdated v1 documentation .","title":"Older v1.x firmware"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html","text":"Wireless mBUS over LoRaWAN Bridge Outdated Version v1.x Outdated document version This manual is only valid for firmwares version up to V1.6.0 and hardware revisions V1.x ! Firmware V1.6.0 is deprecated since 02/2020. For revision v2.x please refer to the current documentation v2.x . Overview The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energy efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 consumption meters via any LoRaWAN network onto the Internet. Many gas, water, electricity and heat meters can be read wirelessly today using the common short range Wireless M-Bus standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is often limited to less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is such a key technology. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. This often results in much lower operational costs with the Lobaro wMBUS bridge compared to conventional remote meter reading via LTE networks. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Initial configuration, firmware updates & status readouts are done user-friendly via USB on the PC with the Lobaro Tool (Windows, Linux, Mac). An additional possibility of configuration in the field \"over the air\" by means of LoRaWAN downlinks will soon also be available via firmware update. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro may cause damage to people, the environment, or the device. Consider using the latest firmware on your hardware See available firmware downloads The Device Variants no longer available These device variants are no longer available. Please see current documentation for available options. Please refer to the current documentation v2.x . Variant with compact housing (2xAA batteries) wMBUS LoRaWAN Bridge (AA-cells, compact IP65 housing), Order number: - Variant with D-cell battery wMBUS LoRaWAN Bridge (XH battery-connector, IP67 housing), Order number: - Device installation The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Power Supply The wMBUS over LoRaWAN Bridge default power supply consists of two series connected off-the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium- Iron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB). Battery life time The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to info@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity. Example calculation In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. This behavior is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"wMBUS bridge parameters\"). This will ensure that all meters of interest sent their consumption telegrams at least onces during the configured listen period of the bridge. For a worst-case battery-lifetime calculation the weakest possible LoRaWAN connectivity has been selected. That means to reach a LoRaWAN Gateway the Lobaro hardware has to send out its Uplink data very slowly (\u2265 2 seconds) and redundant by using a LoRa spreading factor of 12. Beside this the actual usable battery capacity has been set to 80% of the nominal value. The resulting worst-case minimal battery-life times are presented below. Battery life for daily LoRaWAN uploads with SF12 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 10.7 32.0 5 7.0 21.1 10 4.9 14.8 20 3.1 9.3 40 1.8 5.3 80 1.0 2.9 Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 are presented below. In real world installations the possible spreading factor may be optimized anytime by setting up additional LoRaWAN Gateways near the meters of interest. Battery life for daily LoRaWAN uploads with SF7 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 12.1 36.4 5 11.8 35.4 10 11.4 34.4 20 10.6 31.9 40 9.4 28.3 80 7.7 23.0 Usage scenario recommendations As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transfered by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT) or classical 4G/LTE. Contact us if you need such a alternative solution by sending your request to info@lobaro.com - either English or German is fine. Work Cycle graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases. Initial Phase This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration. Data Collection Phase During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered. Data Transfer Phase During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\". Sleep Phase After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again. Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 (picture above). Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Please note that the device is automatically restarted each time the configuration has been changed! Connecting the USB config adapter For configuration and firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture below. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART Bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. System parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN network parameters A large part of the configuration parameters are used to control the device's usage of LoRaWAN. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The LoRaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR) wMBUS bridge parameters Name Type Description loraMaxMsgSize int Received wireless M-Bus telegrams might have a byte size bigger than a single LoRaWAN message can hold. This parameter defines the bytes per LoRaWAN message before a partition over multiple LoRaWAN Uplink msg appears. (Range 10-50 bytes) resetHours int Hours after which the firmware will reset and rejoin the network. Can support the change of LoRaWAN network providers with already deployed devices. (0 = never) cmodeCron string Cron Expression defining when the device starts wMBUS T1/C1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no T1/C1 receive) cmodeDurSec int Duration in seconds for each C1/T1-mode wMBUS receive phase, if cmodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. smodeCron string Cron Expression defining when the device starts wMBUS S1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no S1 receive) smodeDurSec int Duration in seconds for each S1-mode wMBUS receive phase, if smodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. devFilter string wMBUS device id white-list filter using 8 digits with leading zeros list separated by ','. Example '88009035,06198833'. (blank = filter inactive) mFilter string wMBUS manufacturer white-list filter separated by ',' . Example: 'DME,QDS' for receiving just telegrams from Diehl Metering GmbH and Qundis GmbH meters. Telegrams with different 3 character wMBUS manufacturer id will not be uploaded via LoRaWAN. (blank = filter inactive) typFilter string wMBUS device type white-list filter list separated by ','. Example: '08,07' for Heat-Cost and Water meters. Please refer to appendix B.1 for a list of possible values. (blank = filter inactive) Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the random time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 * * * * Hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * Daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * Every month daily from day 1 till 5 at 9:00:00 LoRaWAN Data Upload Formats After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge. Status Packet Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network . Data Packet After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before. Examples Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend. Upload Rate The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which de\u001cnes how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured cmodeCron or smodeCron, whichever is earlier. Because of this it is advisable to define the cron parameters with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a wireless M-Bus solution that uses alternate data transmission technologies, for example GSM/LTE or NarrowBand-IoT. Find our contact information under https://www.lobaro.com/contact/ , or simple send us an email to info@lobaro.com - either English or German is fine. Decoding wireless M-Bus After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided (see picture above). This REST API returns a JSON object including all encapsulated fields, e.g. the actual metering values. This greatly simplifies the bridge integration into your web based service or application. A 12 months period of free access to this API is included in our 'wmbus bridge testpacket' offer for quick device evaluation. API Integration into production systems is also possible, but in this case a separate agreement about a royalty fee must be achieved up front. For more information on licensing our wireless M-Bus parsing API plase send us your request via email to info@lobaro.com - either English or German is fine. Technical characteristics Product Type name wMBUS-LoRaWAN Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory up to 500 telegrams (on request: 1.500) Power Supply Nominal Supply Voltage 3V Supply Voltage Range 2.2V - 3.7V Power supply 2xAA battery, 1.5V (LR6/FR6) 5V USB powered over Lobaro Adapter On Request: 230V mains adapter, 3.6V Battery Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Housing Dimensions Target Measurement / Purpose Forwarding of wireless M-BUS messages via LoRaWAN. Features wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request) Parser TTN function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } CE Declaration of Conformity / PDF Manual PDF Manual (en) up to firmware V1.6.0 Product Flyer CE Declaration of Conformity Firmware v1.x Old Firmware Release V1.6 - not recommended for use anymore! Old stable v1.6 firmware release for reference only: Download: app-wMbusLoraBridge-1.6.0.hex Consider using the current v2.x version instead! Firmware Changelog: v1.6.0 (20.05.2019) Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters v1.5.8 (18.02.2019) Reduce chance to miss wMbus packet when there is a lot of traffic v1.5.7 (07.01.2019) Fix issue with very large T1 mode telegrams v1.5.6 (20.11.2018) Support new FRAM memory type Improve random generator behaviour v1.5.5 (14.11.2018) internal use only v1.5.4 (25.10.2018) Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR v1.5.3 (18.10.2018) Fix bug with not working deduplication of same wMBUS messages during listen intervals v1.5.2 Support LoRaWAN Rx1 DataRate Offset v1.5.1 New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never) v1.5.0 Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack v1.4.1 Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output v1.4.0 New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration v1.3.1 Fix ADR Bugs v1.3.0 Allow to enable ADR (default: enabled) v1.2.0 Increase config version (Config will be reset) Introduce LoRaWAN default parameter v1.1.0 New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter) Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#wireless-mbus-over-lorawan-bridge","text":"Outdated Version v1.x Outdated document version This manual is only valid for firmwares version up to V1.6.0 and hardware revisions V1.x ! Firmware V1.6.0 is deprecated since 02/2020. For revision v2.x please refer to the current documentation v2.x .","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#overview","text":"The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energy efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 consumption meters via any LoRaWAN network onto the Internet. Many gas, water, electricity and heat meters can be read wirelessly today using the common short range Wireless M-Bus standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is often limited to less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is such a key technology. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. This often results in much lower operational costs with the Lobaro wMBUS bridge compared to conventional remote meter reading via LTE networks. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Initial configuration, firmware updates & status readouts are done user-friendly via USB on the PC with the Lobaro Tool (Windows, Linux, Mac). An additional possibility of configuration in the field \"over the air\" by means of LoRaWAN downlinks will soon also be available via firmware update. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro may cause damage to people, the environment, or the device. Consider using the latest firmware on your hardware See available firmware downloads","title":"Overview"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#the-device","text":"Variants no longer available These device variants are no longer available. Please see current documentation for available options. Please refer to the current documentation v2.x .","title":"The Device"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#variant-with-compact-housing-2xaa-batteries","text":"wMBUS LoRaWAN Bridge (AA-cells, compact IP65 housing), Order number: -","title":"Variant with compact housing (2xAA batteries)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#variant-with-d-cell-battery","text":"wMBUS LoRaWAN Bridge (XH battery-connector, IP67 housing), Order number: -","title":"Variant with D-cell battery"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#device-installation","text":"The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Device installation"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#power-supply","text":"The wMBUS over LoRaWAN Bridge default power supply consists of two series connected off-the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium- Iron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB).","title":"Power Supply"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#battery-life-time","text":"The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to info@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity.","title":"Battery life time"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#example-calculation","text":"In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. This behavior is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"wMBUS bridge parameters\"). This will ensure that all meters of interest sent their consumption telegrams at least onces during the configured listen period of the bridge. For a worst-case battery-lifetime calculation the weakest possible LoRaWAN connectivity has been selected. That means to reach a LoRaWAN Gateway the Lobaro hardware has to send out its Uplink data very slowly (\u2265 2 seconds) and redundant by using a LoRa spreading factor of 12. Beside this the actual usable battery capacity has been set to 80% of the nominal value. The resulting worst-case minimal battery-life times are presented below. Battery life for daily LoRaWAN uploads with SF12 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 10.7 32.0 5 7.0 21.1 10 4.9 14.8 20 3.1 9.3 40 1.8 5.3 80 1.0 2.9 Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 are presented below. In real world installations the possible spreading factor may be optimized anytime by setting up additional LoRaWAN Gateways near the meters of interest. Battery life for daily LoRaWAN uploads with SF7 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 12.1 36.4 5 11.8 35.4 10 11.4 34.4 20 10.6 31.9 40 9.4 28.3 80 7.7 23.0","title":"Example calculation"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#usage-scenario-recommendations","text":"As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transfered by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT) or classical 4G/LTE. Contact us if you need such a alternative solution by sending your request to info@lobaro.com - either English or German is fine.","title":"Usage scenario recommendations"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#work-cycle","text":"graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases.","title":"Work Cycle"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#lorawan-join-phase","text":"If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#data-collection-phase","text":"During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered.","title":"Data Collection Phase"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\".","title":"Data Transfer Phase"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#sleep-phase","text":"After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again.","title":"Sleep Phase"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 (picture above). Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Please note that the device is automatically restarted each time the configuration has been changed!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#connecting-the-usb-config-adapter","text":"For configuration and firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture below. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART Bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System parameters"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#lorawan-network-parameters","text":"A large part of the configuration parameters are used to control the device's usage of LoRaWAN. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The LoRaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR)","title":"LoRaWAN network parameters"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#wmbus-bridge-parameters","text":"Name Type Description loraMaxMsgSize int Received wireless M-Bus telegrams might have a byte size bigger than a single LoRaWAN message can hold. This parameter defines the bytes per LoRaWAN message before a partition over multiple LoRaWAN Uplink msg appears. (Range 10-50 bytes) resetHours int Hours after which the firmware will reset and rejoin the network. Can support the change of LoRaWAN network providers with already deployed devices. (0 = never) cmodeCron string Cron Expression defining when the device starts wMBUS T1/C1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no T1/C1 receive) cmodeDurSec int Duration in seconds for each C1/T1-mode wMBUS receive phase, if cmodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. smodeCron string Cron Expression defining when the device starts wMBUS S1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no S1 receive) smodeDurSec int Duration in seconds for each S1-mode wMBUS receive phase, if smodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. devFilter string wMBUS device id white-list filter using 8 digits with leading zeros list separated by ','. Example '88009035,06198833'. (blank = filter inactive) mFilter string wMBUS manufacturer white-list filter separated by ',' . Example: 'DME,QDS' for receiving just telegrams from Diehl Metering GmbH and Qundis GmbH meters. Telegrams with different 3 character wMBUS manufacturer id will not be uploaded via LoRaWAN. (blank = filter inactive) typFilter string wMBUS device type white-list filter list separated by ','. Example: '08,07' for Heat-Cost and Water meters. Please refer to appendix B.1 for a list of possible values. (blank = filter inactive)","title":"wMBUS bridge parameters"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the random time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 * * * * Hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * Daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * Every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#lorawan-data-upload-formats","text":"After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge.","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#status-packet","text":"Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network .","title":"Status Packet"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#data-packet","text":"After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before.","title":"Data Packet"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#examples","text":"Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend.","title":"Examples"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#upload-rate","text":"The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which de\u001cnes how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured cmodeCron or smodeCron, whichever is earlier. Because of this it is advisable to define the cron parameters with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a wireless M-Bus solution that uses alternate data transmission technologies, for example GSM/LTE or NarrowBand-IoT. Find our contact information under https://www.lobaro.com/contact/ , or simple send us an email to info@lobaro.com - either English or German is fine.","title":"Upload Rate"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#decoding-wireless-m-bus","text":"After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided (see picture above). This REST API returns a JSON object including all encapsulated fields, e.g. the actual metering values. This greatly simplifies the bridge integration into your web based service or application. A 12 months period of free access to this API is included in our 'wmbus bridge testpacket' offer for quick device evaluation. API Integration into production systems is also possible, but in this case a separate agreement about a royalty fee must be achieved up front. For more information on licensing our wireless M-Bus parsing API plase send us your request via email to info@lobaro.com - either English or German is fine.","title":"Decoding wireless M-Bus"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#technical-characteristics","text":"Product Type name wMBUS-LoRaWAN Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol Class A / Class C LoRaWAN 1.1 EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory up to 500 telegrams (on request: 1.500) Power Supply Nominal Supply Voltage 3V Supply Voltage Range 2.2V - 3.7V Power supply 2xAA battery, 1.5V (LR6/FR6) 5V USB powered over Lobaro Adapter On Request: 230V mains adapter, 3.6V Battery Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity","title":"Technical characteristics"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#housing-dimensions","text":"","title":"Housing Dimensions"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#target-measurement-purpose","text":"Forwarding of wireless M-BUS messages via LoRaWAN. Features wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#ttn","text":"function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; }","title":"TTN"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#ce-declaration-of-conformity-pdf-manual","text":"PDF Manual (en) up to firmware V1.6.0 Product Flyer CE Declaration of Conformity","title":"CE Declaration of Conformity / PDF Manual"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#firmware-v1x","text":"Old Firmware Release V1.6 - not recommended for use anymore! Old stable v1.6 firmware release for reference only: Download: app-wMbusLoraBridge-1.6.0.hex Consider using the current v2.x version instead! Firmware Changelog:","title":"Firmware v1.x"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v160-20052019","text":"Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters","title":"v1.6.0 (20.05.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v158-18022019","text":"Reduce chance to miss wMbus packet when there is a lot of traffic","title":"v1.5.8 (18.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v157-07012019","text":"Fix issue with very large T1 mode telegrams","title":"v1.5.7 (07.01.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v156-20112018","text":"Support new FRAM memory type Improve random generator behaviour","title":"v1.5.6 (20.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v155-14112018","text":"internal use only","title":"v1.5.5 (14.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v154-25102018","text":"Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR","title":"v1.5.4 (25.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v153-18102018","text":"Fix bug with not working deduplication of same wMBUS messages during listen intervals","title":"v1.5.3 (18.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v152","text":"Support LoRaWAN Rx1 DataRate Offset","title":"v1.5.2"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v151","text":"New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never)","title":"v1.5.1"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v150","text":"Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack","title":"v1.5.0"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v141","text":"Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output","title":"v1.4.1"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v140","text":"New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration","title":"v1.4.0"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v131","text":"Fix ADR Bugs","title":"v1.3.1"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v130","text":"Allow to enable ADR (default: enabled)","title":"v1.3.0"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v120","text":"Increase config version (Config will be reset) Introduce LoRaWAN default parameter","title":"v1.2.0"},{"location":"lorawan-sensors/wmbus-lorawan/1.x/index.html#v110","text":"New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter) Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"v1.1.0"},{"location":"nbiot-sensors/wmbus-nbiot/index.html","text":"Wireless M-Bus NB-IoT Gateway Overview The Lobaro Wireless M-Bus Gateway (wMBus) is a simple to use, cost and energy efficient device that can receive, cache, and forward meter information from 100 Wireless M-Bus devices, like water meters, electricity meters, heat meters, etc. Wireless M-Bus activated meters use FSK radio modulation to broadcast their information for up to about 50m. The Lobaro Wireless M-Bus Gateway collects this information and uploads it using mobile technology (NB-IoT or LTE-M), that was designed for use with IoT devices. The meter information is sent to the Lobaro Platform, were it is parsed and displayed for each individual meter. Because most Wireless M-Bus telegrams are encrypted, the Platform allows adding decryption keys for individual meters, so that the data is decrypted in the Platform. It is also possible to use the Lobaro Wireless M-Bus Gateway without the Platform and connect it to your own backend, if it is capable of parsing and decrypting wMBus telegrams. Quick start guide Make sure SIM card and battery are correctly connected. Go to The Lobaro Platform and log into your account. Go to \"Devices\" and select your \"Lobaro NB-IoT wMBus Gateway\". If you have several Gateways: the \"Address\" is printed on the device's case. You should see all wMBus Telegrams the Gateway collected so far. If the data is encrypted (closed lock symbol \ud83d\udd12), you can add keys for your devices under \"Organisation\". Push the reset button inside the device, if you want to trigger data collection (will take several minutes). State of this document This manual is currently a stub. It gives a short description of how to start the device and how to access collected data in the Lobaro Platform. A more thorough manual will be supplied soon. Setting up the device SIM card A SIM card is needed by the Gateway to connect to the mobile network. If you purchased a device together with a SIM card, it should already be inserted. If you provide your own SIM card, you will need to insert it into the socket. A drawing shows you, how the card must be inserted. The contacts should be facing down. Power supply The Gateway is powered by a 3.6V D-Cell battery, that is connected via a XH connector (a white 2 pin socket on the board, labeled \"VBat 3V6\"). If the battery is initially not connected to the board, you will need to plug in the XH connector. When the device powers up, the on-board LED will blink green once. Resetting the device Inside the device on the board is a button labeled \"RESET\". If you push this button while the device is running, it will stop and reboot. You should see a green flash of the LED when the device starts again. Disconnecting the battery from the device will not be enough to reboot the device! The Gateway buffers enough power to run for several minutes without a power supply connected (the actutal time is depending on what the Gateway does during that time). Configuring the device If you purchased your Lobaro wMBus Gateway with a SIM card included and you are using the Lobaro Platform, you will not need to change any configuration for the device to work. Instructions on how to change the device's configuration using the Lobaro Config Adapter will be provided later. The Lobaro Platform The easiest way to work with the Lobaro wMBus NB-IoT Gateway is the Lobaro Platform . You can find it under https://platform.lobaro.com \u2013 Log in with the credentials provided by Lobaro. Your Gateways should be listed under \"Devices\". If you have multiple devices in your account, you can distinguish them by the field \"Address\". The Address is printed on the box of the Gateway (the Address is the IMEI of the modem used by the device; that is the unique hardware address used for mobile communication). Displaying wMBus data Open the tab \"Device Data\" to see a list of all Wireless M-Bus telegrams that your Gateway uploaded. Changing configuration You can see and edit the configuration of the Gateway without physical access to the device from the Lobaro Platform. Open the tab \"Config\" for your device. The current configuration will be shown. You can edit individual config entries by clicking on the pencil. After you entered all the values you want to change, click the \"Update config\" button. The new configuration will be sent to the device the next time it uploads data to the platform. After changing the configuration, it will reboot and start working with the new config. For an explanation of the wMBus specific configuration values, please refer to the explanation of wMbus parameters in the LoRaWAN wMBus Bridge. The remaining configuration parameters (Host, Port, APN, Band, ...) are used to configure the way the device connects to the mobile provider and to the Lobaro Platform. There is no need to change these values when using the Gateway with the Lobaro Platform. wMBus encryption Keys Many meters are sending encrypted data. In order to get the values out of that encrypted telegrams, you will need to provide the decryption key to the Platform. Go to \"Organisation\" / \"wMBus\" to add encryption keys. You will need to set a key for a specific meter (identified by its ID). Once a key is entered for a device, any telegram received after that will be decrypted and listed in clear text under \"Device Data\". Forwarding data to your own system If you want the received data inside your own system, you can add an Integration inside the Lobaro Platform that forwards all data to your system. We currently supply a REST API that allows you to query data from our platform actively, as well as a HTTP(S) integration, that pushes incoming data to your system when it is received. Configuration with the Config Adapter Instead of using the Lobaro Platform, you can use the Lobaro Config Adapter and the Config Tool to change the Configuration directly in your hardware. This can be useful when you want to change configuration while the mobile connection does not work (or if you do not want to use the Lobaro Platform). See Lobaro USB configuration adapter for more information. Troubleshooting I did not get a username/password for the Lobaro Platform . Please contact contact Lobaro to get your account information. I do not see my Gateway listed unter \"Devices\". It is possible that the purchased device has not been added to your account. Please check if you got an Activation Code with your hardware. If so, you can enter it under \"Tools\" / \"Hardware Activation\" in order to claim the device for your account. I cannot find data for my specific meter. Make sure your Gateway collected data since you brought it close to the meter (check timestamps on data). With standard configuration, it only collects data every 8 hours. You can press the \"RESET\" Button inside the device to make it reboot and start collecting data. Also check the specifications of your wMBus meter. How often does it send data? What mode does it use? Using standard configuration, the wMBus Gateway only collects C-Mode and T-Mode telegrams. If your meter is sending S-Mode, you will need to change the Gateway's configuration. Data for my meter only shows \"Payload encrypted\". Most meters encrypt the data they are sending out (information about water/energy usage is personal data). In order to see values from encrypted wMBus telegrams, your will need to supply the decryption key for your meter (you should be able to get the key where you got the meter). You can add the key in the Lobaro Platform under \"Organisation\" / \"wMBus\". You will have to add a key for a specific meter (identified by the meter's ID). After you supplied the key, new telegrams that are received should be decrypted so that you can see the values inside the telegrams.","title":"wMBus Gateway"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#wireless-m-bus-nb-iot-gateway","text":"","title":"Wireless M-Bus NB-IoT Gateway"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#overview","text":"The Lobaro Wireless M-Bus Gateway (wMBus) is a simple to use, cost and energy efficient device that can receive, cache, and forward meter information from 100 Wireless M-Bus devices, like water meters, electricity meters, heat meters, etc. Wireless M-Bus activated meters use FSK radio modulation to broadcast their information for up to about 50m. The Lobaro Wireless M-Bus Gateway collects this information and uploads it using mobile technology (NB-IoT or LTE-M), that was designed for use with IoT devices. The meter information is sent to the Lobaro Platform, were it is parsed and displayed for each individual meter. Because most Wireless M-Bus telegrams are encrypted, the Platform allows adding decryption keys for individual meters, so that the data is decrypted in the Platform. It is also possible to use the Lobaro Wireless M-Bus Gateway without the Platform and connect it to your own backend, if it is capable of parsing and decrypting wMBus telegrams.","title":"Overview"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#quick-start-guide","text":"Make sure SIM card and battery are correctly connected. Go to The Lobaro Platform and log into your account. Go to \"Devices\" and select your \"Lobaro NB-IoT wMBus Gateway\". If you have several Gateways: the \"Address\" is printed on the device's case. You should see all wMBus Telegrams the Gateway collected so far. If the data is encrypted (closed lock symbol \ud83d\udd12), you can add keys for your devices under \"Organisation\". Push the reset button inside the device, if you want to trigger data collection (will take several minutes).","title":"Quick start guide"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#state-of-this-document","text":"This manual is currently a stub. It gives a short description of how to start the device and how to access collected data in the Lobaro Platform. A more thorough manual will be supplied soon.","title":"State of this document"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#setting-up-the-device","text":"","title":"Setting up the device"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#sim-card","text":"A SIM card is needed by the Gateway to connect to the mobile network. If you purchased a device together with a SIM card, it should already be inserted. If you provide your own SIM card, you will need to insert it into the socket. A drawing shows you, how the card must be inserted. The contacts should be facing down.","title":"SIM card"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#power-supply","text":"The Gateway is powered by a 3.6V D-Cell battery, that is connected via a XH connector (a white 2 pin socket on the board, labeled \"VBat 3V6\"). If the battery is initially not connected to the board, you will need to plug in the XH connector. When the device powers up, the on-board LED will blink green once.","title":"Power supply"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#resetting-the-device","text":"Inside the device on the board is a button labeled \"RESET\". If you push this button while the device is running, it will stop and reboot. You should see a green flash of the LED when the device starts again. Disconnecting the battery from the device will not be enough to reboot the device! The Gateway buffers enough power to run for several minutes without a power supply connected (the actutal time is depending on what the Gateway does during that time).","title":"Resetting the device"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#configuring-the-device","text":"If you purchased your Lobaro wMBus Gateway with a SIM card included and you are using the Lobaro Platform, you will not need to change any configuration for the device to work. Instructions on how to change the device's configuration using the Lobaro Config Adapter will be provided later.","title":"Configuring the device"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#the-lobaro-platform","text":"The easiest way to work with the Lobaro wMBus NB-IoT Gateway is the Lobaro Platform . You can find it under https://platform.lobaro.com \u2013 Log in with the credentials provided by Lobaro. Your Gateways should be listed under \"Devices\". If you have multiple devices in your account, you can distinguish them by the field \"Address\". The Address is printed on the box of the Gateway (the Address is the IMEI of the modem used by the device; that is the unique hardware address used for mobile communication).","title":"The Lobaro Platform"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#displaying-wmbus-data","text":"Open the tab \"Device Data\" to see a list of all Wireless M-Bus telegrams that your Gateway uploaded.","title":"Displaying wMBus data"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#changing-configuration","text":"You can see and edit the configuration of the Gateway without physical access to the device from the Lobaro Platform. Open the tab \"Config\" for your device. The current configuration will be shown. You can edit individual config entries by clicking on the pencil. After you entered all the values you want to change, click the \"Update config\" button. The new configuration will be sent to the device the next time it uploads data to the platform. After changing the configuration, it will reboot and start working with the new config. For an explanation of the wMBus specific configuration values, please refer to the explanation of wMbus parameters in the LoRaWAN wMBus Bridge. The remaining configuration parameters (Host, Port, APN, Band, ...) are used to configure the way the device connects to the mobile provider and to the Lobaro Platform. There is no need to change these values when using the Gateway with the Lobaro Platform.","title":"Changing configuration"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#wmbus-encryption-keys","text":"Many meters are sending encrypted data. In order to get the values out of that encrypted telegrams, you will need to provide the decryption key to the Platform. Go to \"Organisation\" / \"wMBus\" to add encryption keys. You will need to set a key for a specific meter (identified by its ID). Once a key is entered for a device, any telegram received after that will be decrypted and listed in clear text under \"Device Data\".","title":"wMBus encryption Keys"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#forwarding-data-to-your-own-system","text":"If you want the received data inside your own system, you can add an Integration inside the Lobaro Platform that forwards all data to your system. We currently supply a REST API that allows you to query data from our platform actively, as well as a HTTP(S) integration, that pushes incoming data to your system when it is received.","title":"Forwarding data to your own system"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#configuration-with-the-config-adapter","text":"Instead of using the Lobaro Platform, you can use the Lobaro Config Adapter and the Config Tool to change the Configuration directly in your hardware. This can be useful when you want to change configuration while the mobile connection does not work (or if you do not want to use the Lobaro Platform). See Lobaro USB configuration adapter for more information.","title":"Configuration with the Config Adapter"},{"location":"nbiot-sensors/wmbus-nbiot/index.html#troubleshooting","text":"I did not get a username/password for the Lobaro Platform . Please contact contact Lobaro to get your account information. I do not see my Gateway listed unter \"Devices\". It is possible that the purchased device has not been added to your account. Please check if you got an Activation Code with your hardware. If so, you can enter it under \"Tools\" / \"Hardware Activation\" in order to claim the device for your account. I cannot find data for my specific meter. Make sure your Gateway collected data since you brought it close to the meter (check timestamps on data). With standard configuration, it only collects data every 8 hours. You can press the \"RESET\" Button inside the device to make it reboot and start collecting data. Also check the specifications of your wMBus meter. How often does it send data? What mode does it use? Using standard configuration, the wMBus Gateway only collects C-Mode and T-Mode telegrams. If your meter is sending S-Mode, you will need to change the Gateway's configuration. Data for my meter only shows \"Payload encrypted\". Most meters encrypt the data they are sending out (information about water/energy usage is personal data). In order to see values from encrypted wMBus telegrams, your will need to supply the decryption key for your meter (you should be able to get the key where you got the meter). You can add the key in the Lobaro Platform under \"Organisation\" / \"wMBus\". You will have to add a key for a specific meter (identified by the meter's ID). After you supplied the key, new telegrams that are received should be decrypted so that you can see the values inside the telegrams.","title":"Troubleshooting"},{"location":"platform/index.html","text":"Lobaro IoT Platform The Lobaro IoT Platform offers device management and can process, display and forward data of IoT Devices. The Platform is optimized for but not limited to handle Lobaro devices. Public Lobaro instance: platform.lobaro.com We offer On-Premise hosting and dedicated cloud instances. The documentation will always reference the Public Lobaro instance of the Platform. Features Multi tenant (Organisations) with branding / white labeling IoT Device Management Support for all Lobaro Devices Possibility to integrate 3 rd party IoT Devices (LoRaWAN, NB-IoT, ...) Device configuration Firmware updates Data parsing and persistence Datasources LoRaWAN Network Server NB-IoT (CoAP) GSM / LTE REST APIs to access or forward data to Use-Case specific applications We offer free access to the platform for 12 Month with the purchase of any Lobaro device in our shared instance. In addition we offer private instance hosting on AWS or On-Premise (any Server with Root access). Overview You can find your organisations name next to the Logo. Admins can change their organisation by clicking the small Icon next to it. Devices : Manage all devices of your organisation. Data : See incoming data of all your devices. Integrations : Manage data connections to and from other applications. (See: Integrations ). Organisation : Manage all organisation related data. Configuration : Platform administration of global entities independent of the Organisation (Admins only). Tools : wMbus Parser and Hardware Activation. The platform shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. The connection to a device in handled by a Datasource . Incoming data is mapped to a matching Device . Raw data is saved as Uplink Message . The Uplink Message gets processed by a Parser . The result of the parser is saved as Device Data used for visualization inside the dashboard and in outgoing API's. graph LR; ds>Datasource] device(Device) parser(Parser) raw[Uplink Message] parsed[Device Data] ds-->device device-->raw raw-->parser parser-->parsed","title":"Manual"},{"location":"platform/index.html#lobaro-iot-platform","text":"The Lobaro IoT Platform offers device management and can process, display and forward data of IoT Devices. The Platform is optimized for but not limited to handle Lobaro devices. Public Lobaro instance: platform.lobaro.com We offer On-Premise hosting and dedicated cloud instances. The documentation will always reference the Public Lobaro instance of the Platform.","title":"Lobaro IoT Platform"},{"location":"platform/index.html#features","text":"Multi tenant (Organisations) with branding / white labeling IoT Device Management Support for all Lobaro Devices Possibility to integrate 3 rd party IoT Devices (LoRaWAN, NB-IoT, ...) Device configuration Firmware updates Data parsing and persistence Datasources LoRaWAN Network Server NB-IoT (CoAP) GSM / LTE REST APIs to access or forward data to Use-Case specific applications We offer free access to the platform for 12 Month with the purchase of any Lobaro device in our shared instance. In addition we offer private instance hosting on AWS or On-Premise (any Server with Root access).","title":"Features"},{"location":"platform/index.html#overview","text":"You can find your organisations name next to the Logo. Admins can change their organisation by clicking the small Icon next to it. Devices : Manage all devices of your organisation. Data : See incoming data of all your devices. Integrations : Manage data connections to and from other applications. (See: Integrations ). Organisation : Manage all organisation related data. Configuration : Platform administration of global entities independent of the Organisation (Admins only). Tools : wMbus Parser and Hardware Activation. The platform shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. The connection to a device in handled by a Datasource . Incoming data is mapped to a matching Device . Raw data is saved as Uplink Message . The Uplink Message gets processed by a Parser . The result of the parser is saved as Device Data used for visualization inside the dashboard and in outgoing API's. graph LR; ds>Datasource] device(Device) parser(Parser) raw[Uplink Message] parsed[Device Data] ds-->device device-->raw raw-->parser parser-->parsed","title":"Overview"},{"location":"platform/changelog-backend.html","text":"Changelog Application: Lobaro Backend 1.6.0 - 2020-04-09 Added Allow org-admin to edit wMbus Keys Allow org-admin to upload organisation logos Documentation for REST API endpoint /api/devices Parser: Record.getReceivedAt() to access the uplink message received_at date Changed Chirpstack device synchronisation reports more details Removed Gateway entity that is no longer used Hardcoded MQTT publishers that are no longer used Fixed Allow to remove App in device via GraphQL API NB-IoT Data is saved for all matching devices, not just one Downlink messages created_at was set to null after update Allow to update config values that are not defined in Device Type Allow org-Admin to edit wMbus Keys 1.5.0 Added Synchronization of devices with Chirpstack","title":"Backend"},{"location":"platform/changelog-backend.html#changelog","text":"Application: Lobaro Backend","title":"Changelog"},{"location":"platform/changelog-backend.html#160-2020-04-09","text":"","title":"1.6.0 - 2020-04-09"},{"location":"platform/changelog-backend.html#added","text":"Allow org-admin to edit wMbus Keys Allow org-admin to upload organisation logos Documentation for REST API endpoint /api/devices Parser: Record.getReceivedAt() to access the uplink message received_at date","title":"Added"},{"location":"platform/changelog-backend.html#changed","text":"Chirpstack device synchronisation reports more details","title":"Changed"},{"location":"platform/changelog-backend.html#removed","text":"Gateway entity that is no longer used Hardcoded MQTT publishers that are no longer used","title":"Removed"},{"location":"platform/changelog-backend.html#fixed","text":"Allow to remove App in device via GraphQL API NB-IoT Data is saved for all matching devices, not just one Downlink messages created_at was set to null after update Allow to update config values that are not defined in Device Type Allow org-Admin to edit wMbus Keys","title":"Fixed"},{"location":"platform/changelog-backend.html#150","text":"","title":"1.5.0"},{"location":"platform/changelog-backend.html#added_1","text":"Synchronization of devices with Chirpstack","title":"Added"},{"location":"platform/changelog-frontend.html","text":"Changelog Application: Dashboard Server 1.6.0 - 2020-04-09 Added Display more details when sync devices with chirpstack New notifications for user actions Allow to select organisation when creating a device in configuration -> hardware Allow to edit Organisation Name and Logo in Organisation -> Settings Allow to import names for devices in Configuration -> Hardware -> Import Allow to import config values from separate cols in Configuration -> Hardware -> Import Changed Use new notifications in organisation -> wMbus Keys Change platform title to \"IoT Platform\" for better white-labeling Fixed Allow to remove App in configuration -> hardware Missing entries in device -> downlinks 1.5.1 Added Device synchronisation with Chirpstack 1.5.0 Added CSV Import for devices Changed Rename directory \"configs\" to \"config\". Needs update of docker volume path","title":"Frontend"},{"location":"platform/changelog-frontend.html#changelog","text":"Application: Dashboard Server","title":"Changelog"},{"location":"platform/changelog-frontend.html#160-2020-04-09","text":"","title":"1.6.0 - 2020-04-09"},{"location":"platform/changelog-frontend.html#added","text":"Display more details when sync devices with chirpstack New notifications for user actions Allow to select organisation when creating a device in configuration -> hardware Allow to edit Organisation Name and Logo in Organisation -> Settings Allow to import names for devices in Configuration -> Hardware -> Import Allow to import config values from separate cols in Configuration -> Hardware -> Import","title":"Added"},{"location":"platform/changelog-frontend.html#changed","text":"Use new notifications in organisation -> wMbus Keys Change platform title to \"IoT Platform\" for better white-labeling","title":"Changed"},{"location":"platform/changelog-frontend.html#fixed","text":"Allow to remove App in configuration -> hardware Missing entries in device -> downlinks","title":"Fixed"},{"location":"platform/changelog-frontend.html#151","text":"","title":"1.5.1"},{"location":"platform/changelog-frontend.html#added_1","text":"Device synchronisation with Chirpstack","title":"Added"},{"location":"platform/changelog-frontend.html#150","text":"","title":"1.5.0"},{"location":"platform/changelog-frontend.html#added_2","text":"CSV Import for devices","title":"Added"},{"location":"platform/changelog-frontend.html#changed_1","text":"Rename directory \"configs\" to \"config\". Needs update of docker volume path","title":"Changed"},{"location":"platform/integrations.html","text":"Integrations Integrations allow exchange data between the Lobaro Platform and other applications. REST Navigate to: Integrations -> REST The API is located and documented at: https://backend.lobaro.com/api Access Tokens All API calls must be authenticated with an access token. Access tokens can be managed on the REST Integration page. Each token has a list of roles assigned to it. Token roles: network-server : Allows to write device data. Required for LoRaWAN Network Server Integrations. Add the Token into the HTTP request Header: Field: Authorization Value: Bearer eyJhbGciOiJIU... Receive data from a LoRaWAN network server Create an Access Token in the Lobaro Platform with the role network-server to allow write access for device data. Configure your network server to send data to the corresponding endpoint (see list below) using the token (e.g. Bearer eyJhbGciOiJ... ) in the Authorization header field. Please consult the documentation of your network server for further instructions. Chirpstack: https://backend.lobaro.com/api/chirpstack/uplink (deprecated: /api/loraserver/uplink ) Element-IoT: https://backend.lobaro.com/api/element-iot/data Actility: https://backend.lobaro.com/api/actility/data Everynet: https://backend.lobaro.com/api/everynet/data We also support other network servers on request, e.g. TTN, Element-IoT, Firefly, Actility, Loriot, ... Just ask! Filter query parameters Filters parameters can be appended to some requests in the form of f:<parameter>=<op>:<value> e.g. f:createdAt=gt:<timestamp> to filter by createdAt date. The Value must be URL encoded e.g. a timestamp might look like gt:2000-01-01T02:37:00%2B01:00 The allowed <parameter> is specified for each endpoint separately. <op> must be one of the following operators: In Query Meaning eq = lte <= lt < gte >= gt > If no operator is given the default eq operator will be used. HTTP (forwarding) Navigate to: Integrations -> HTTP Forward data from the Lobaro Platform to any HTTP(s) endpoint. HTTP Method : The HTTP method to use for the request. Target URL : Any reachable HTTP server endpoint. Authentication : One of the following authentication schemes can be used: Basic Auth: Adds Username & password to request headers. Bearer Token: Adds a Bearer Token to request headers. Just put the Token (without Bearer prefix). OAuth: Fetch a OAuth token with the given scope from a Token URL using a ClientId and Secret as BasicAuth credentials. The fetched token is used for all API calls and automatically refreshed when invalid. Headers : List of headers to be set on HTTP request in the format: <FieldName>: <Value> (e.g. Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== ) MQTT (forwarding) Navigate to: Integrations -> MQTT Forward data from the Lobaro Platform via MQTT Publish to any MQTT broker. Broker URL : must be in one of the following formats: mqtt[s]://host.domain[:port] tcp[s]://host.domain[:port] Default port for mqtt/tcp is 1883 . Default port for mqtts/tcps is 8883 . ClientId : Used on MQTT connect. Default is: lobaro-{RND} . {RND} will be replaced by a unique random string. Username / Password : Used to authenticate with the MQTT broker. Topic : The MQTT topic to publish sensor data. Note Currently we only support username/password authentication for MQTT yet.","title":"Integrations"},{"location":"platform/integrations.html#integrations","text":"Integrations allow exchange data between the Lobaro Platform and other applications.","title":"Integrations"},{"location":"platform/integrations.html#rest","text":"Navigate to: Integrations -> REST The API is located and documented at: https://backend.lobaro.com/api","title":"REST"},{"location":"platform/integrations.html#access-tokens","text":"All API calls must be authenticated with an access token. Access tokens can be managed on the REST Integration page. Each token has a list of roles assigned to it. Token roles: network-server : Allows to write device data. Required for LoRaWAN Network Server Integrations. Add the Token into the HTTP request Header: Field: Authorization Value: Bearer eyJhbGciOiJIU...","title":"Access Tokens"},{"location":"platform/integrations.html#receive-data-from-a-lorawan-network-server","text":"Create an Access Token in the Lobaro Platform with the role network-server to allow write access for device data. Configure your network server to send data to the corresponding endpoint (see list below) using the token (e.g. Bearer eyJhbGciOiJ... ) in the Authorization header field. Please consult the documentation of your network server for further instructions. Chirpstack: https://backend.lobaro.com/api/chirpstack/uplink (deprecated: /api/loraserver/uplink ) Element-IoT: https://backend.lobaro.com/api/element-iot/data Actility: https://backend.lobaro.com/api/actility/data Everynet: https://backend.lobaro.com/api/everynet/data We also support other network servers on request, e.g. TTN, Element-IoT, Firefly, Actility, Loriot, ... Just ask!","title":"Receive data from a LoRaWAN network server"},{"location":"platform/integrations.html#filter-query-parameters","text":"Filters parameters can be appended to some requests in the form of f:<parameter>=<op>:<value> e.g. f:createdAt=gt:<timestamp> to filter by createdAt date. The Value must be URL encoded e.g. a timestamp might look like gt:2000-01-01T02:37:00%2B01:00 The allowed <parameter> is specified for each endpoint separately. <op> must be one of the following operators: In Query Meaning eq = lte <= lt < gte >= gt > If no operator is given the default eq operator will be used.","title":"Filter query parameters"},{"location":"platform/integrations.html#http-forwarding","text":"Navigate to: Integrations -> HTTP Forward data from the Lobaro Platform to any HTTP(s) endpoint. HTTP Method : The HTTP method to use for the request. Target URL : Any reachable HTTP server endpoint. Authentication : One of the following authentication schemes can be used: Basic Auth: Adds Username & password to request headers. Bearer Token: Adds a Bearer Token to request headers. Just put the Token (without Bearer prefix). OAuth: Fetch a OAuth token with the given scope from a Token URL using a ClientId and Secret as BasicAuth credentials. The fetched token is used for all API calls and automatically refreshed when invalid. Headers : List of headers to be set on HTTP request in the format: <FieldName>: <Value> (e.g. Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== )","title":"HTTP (forwarding)"},{"location":"platform/integrations.html#mqtt-forwarding","text":"Navigate to: Integrations -> MQTT Forward data from the Lobaro Platform via MQTT Publish to any MQTT broker. Broker URL : must be in one of the following formats: mqtt[s]://host.domain[:port] tcp[s]://host.domain[:port] Default port for mqtt/tcp is 1883 . Default port for mqtts/tcps is 8883 . ClientId : Used on MQTT connect. Default is: lobaro-{RND} . {RND} will be replaced by a unique random string. Username / Password : Used to authenticate with the MQTT broker. Topic : The MQTT topic to publish sensor data. Note Currently we only support username/password authentication for MQTT yet.","title":"MQTT (forwarding)"},{"location":"platform/parser.html","text":"Parser A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { var dataStr = atob ( input . data ); var data = bytes ( dataStr ); // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; } JS Parser API Helper functions // Bytes can convert binary data to byte array // atob converts Base64 string to byte string var bytes = bytes ( atob ( \"aGFsbG8gYmFzZTY0\" )); // Convert Base64 to byte array, shortcut for bytes(atob(...)) var bytes = parseBase64 ( \"aGFsbG8gYmFzZTY0\" ); // Convert bytes to string var str = string ( bytes ); // byte parsing helper uint16BE ( bytes , idx ); uint16LE ( bytes , idx ); uint32BE ( bytes , idx ); uint32LE ( bytes , idx ); float32LE ( bytes , idx ); float32BE ( bytes , idx ); Special parser functions // Parse wMbus message Parser . parseWmbus ( bytes ); // Takes bytes of a partial message and a cacheKey // In context of the receiving device all data with the same cacheKey // is concatinated and the restult returned // To start a new message, pass a new cacheKey var joined = Parser . joinPartial ( bytes , cacheKey ); // Clears all data with the given cacheKey // returns the joined parts that were added by joinPartial before var joined = Parser . clearPartial ( cacheKey ); // Equivalent to clearPartial followed by joinPartial var joined = Parser . newPartial ( cacheKey ); All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an device config value, displayed on the \"Config\" tab of the device Device . setConfig ( \"key\" , \"value\" ); Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \"value\" ); Get an arbitary device property, displayed on the \"Overview\" tab of the device var value = Device . getProperty ( \"key\" ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ()); Get the time when the data was received by the server in ms, compatible with new Date(...) . Record . getReceivedAt ();","title":"Parser"},{"location":"platform/parser.html#parser","text":"A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { var dataStr = atob ( input . data ); var data = bytes ( dataStr ); // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; }","title":"Parser"},{"location":"platform/parser.html#js-parser-api","text":"Helper functions // Bytes can convert binary data to byte array // atob converts Base64 string to byte string var bytes = bytes ( atob ( \"aGFsbG8gYmFzZTY0\" )); // Convert Base64 to byte array, shortcut for bytes(atob(...)) var bytes = parseBase64 ( \"aGFsbG8gYmFzZTY0\" ); // Convert bytes to string var str = string ( bytes ); // byte parsing helper uint16BE ( bytes , idx ); uint16LE ( bytes , idx ); uint32BE ( bytes , idx ); uint32LE ( bytes , idx ); float32LE ( bytes , idx ); float32BE ( bytes , idx ); Special parser functions // Parse wMbus message Parser . parseWmbus ( bytes ); // Takes bytes of a partial message and a cacheKey // In context of the receiving device all data with the same cacheKey // is concatinated and the restult returned // To start a new message, pass a new cacheKey var joined = Parser . joinPartial ( bytes , cacheKey ); // Clears all data with the given cacheKey // returns the joined parts that were added by joinPartial before var joined = Parser . clearPartial ( cacheKey ); // Equivalent to clearPartial followed by joinPartial var joined = Parser . newPartial ( cacheKey ); All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an device config value, displayed on the \"Config\" tab of the device Device . setConfig ( \"key\" , \"value\" ); Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \"value\" ); Get an arbitary device property, displayed on the \"Overview\" tab of the device var value = Device . getProperty ( \"key\" ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ()); Get the time when the data was received by the server in ms, compatible with new Date(...) . Record . getReceivedAt ();","title":"JS Parser API"},{"location":"platform/table-config.html","text":"Table Config Audience: Platform Admins Platform Admins can manage Table Configs for different tables in the Platform. (Currently only for Device Data) The table config is shared between all devices of a device type. Navigate to: Configuration -> Device Types -> Select a Device Type -> Data Table Config Data -> Gear Icon above table Devices -> Select a Device -> Device Data -> Gear Icon above table Column Fields: Heading: Title of the column Width: Optional width of the column (use CSS) Sort Property: Optional: Path to property to allow sorting CSV Export: Export CSV : Check to enable CSV export for the column CSV Format: Format for the CSV export Cell: Format: Format of the value inside the table Is Html: HTML is not escaped. This is unsafe. Do not use! Href: Add a link to another page to the value Note Formats are handlebar templates. See: Format Template Format Templates Formatting values in HTML or CSS output is done via Handlebar Templates . Please also have a look into the Handlebar Documentation Note You can not use HTML directly for security reasons. There is a checkbox Is HTML to skip the escaping. We do not recommend using it and it might get removed in future versions. The underling data structure can be seen when expanding the table: Parser output is saved in the data field. But you can also render all other fields. To replace part of the template with variable data you need to put the variable in double curly brackets: e.g. {{variable}} Example To display the temperature field of the parser output you can simply write {{data.temperature}} . For more advanced formatting you will need Handlebar Helpers. Handlebar Template Helpers Handlebar Helpers can be used to apply advanced formatting to data outputs. Starting from conditionals to simple calculations. All built-in Handlebar Helpers can be used. Helpers are used in the following format: {{helper_name <required_parameters> [optional_parameters]}} date Format a given time and date. {{date <date> [format]}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. format must be a valid moment.format() string . Example Template: {{date data.time}} Data: { \"data\" : { \"time\" : 1585823609000 } } Output: 02.04.2020 10:33:29 duration Format given duration. {{duration <duration> [format]}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. format must be a valid moment.format() string . Example Template: {{duration duration}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 00:00:10 durationHumanize Format a given duration in a human readable format. {{durationHumanize <duration>}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. Example Template: {{durationHumanize data.duration}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 10 seconds durationAs Get a given duration in a certain unit of time. {{durationAs <duration> [unit_of_time]}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. unit_of_time must be a valid input for moment.duration().as() Example Template: {{durationAs data.duration \"milliseconds\"}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 10000 fromNow Display the time between now and a given time. See also: moment().fromNow() . {{fromNow <date>}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. Example Template: {{fromNow data.time}} Data: { \"data\" : { \"time\" : 1585823609000 } } Output: 3 days ago typeof Display the js type of a value. Useful for debugging. {{typeof <value>}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. Example Template: {{typeof data.value}} Data: { \"data\" : { \"value\" : 1337 } } Output: number toFixed (number of decimals) Display a number with given amount of decimal places. For more advanced formatting see numberFormat . {{toFixed <value> [decimals]}} decimals number of decimal places (Default: 2) Example Template: {{toFixed data.value 3}} Data: { \"data\" : { \"value\" : 1.2345 } } Output: 1.234 numberFormat Format a number. {{numberFormat <value> [options]}} options: thousandsSep separator between 3 digits (Default: locale dependent) decimalSep decimal separator (Default: locale dependent) decimals number of decimal places (Default: 2) Example Template: {{numberFormat 1024.23 thousandsSep=\".\" decimalSep=\",\"}} Data: { \"data\" : { \"value\" : 1024.2345 } } Output: 1.024,23 Math: ceil, floor, div, max Mathematical operations. {{ceil <value>}} round up to integer {{floor <value>}} round down to integer {{div <nom> <denom>}} returns nom / denom {{max <list> [property_path]}} returns the biggest element from the list. Compares the given property_path . Boolean operations Boolean operations, useful for #if conditions. {{not <value>}} negate the value {{eq <v1> <v2>}} v1 == v2 {{lt <v1> <v2>}} v1 < v2 {{lte <v1> <v2>}} v1 <= v2 {{gt <v1> <v2>}} v1 > v2 {{gte <v1> <v2>}} v1 >= v2 icon Render an Icon {{icon <name> [category]}} name name of the icon. Find all icons here: SLDS Icons category category of the icon (Default: \"utility\").","title":"Table Config"},{"location":"platform/table-config.html#table-config","text":"Audience: Platform Admins Platform Admins can manage Table Configs for different tables in the Platform. (Currently only for Device Data) The table config is shared between all devices of a device type. Navigate to: Configuration -> Device Types -> Select a Device Type -> Data Table Config Data -> Gear Icon above table Devices -> Select a Device -> Device Data -> Gear Icon above table Column Fields: Heading: Title of the column Width: Optional width of the column (use CSS) Sort Property: Optional: Path to property to allow sorting CSV Export: Export CSV : Check to enable CSV export for the column CSV Format: Format for the CSV export Cell: Format: Format of the value inside the table Is Html: HTML is not escaped. This is unsafe. Do not use! Href: Add a link to another page to the value Note Formats are handlebar templates. See: Format Template","title":"Table Config"},{"location":"platform/table-config.html#format-template","text":"Formatting values in HTML or CSS output is done via Handlebar Templates . Please also have a look into the Handlebar Documentation Note You can not use HTML directly for security reasons. There is a checkbox Is HTML to skip the escaping. We do not recommend using it and it might get removed in future versions. The underling data structure can be seen when expanding the table: Parser output is saved in the data field. But you can also render all other fields. To replace part of the template with variable data you need to put the variable in double curly brackets: e.g. {{variable}} Example To display the temperature field of the parser output you can simply write {{data.temperature}} . For more advanced formatting you will need Handlebar Helpers.","title":"Format Templates"},{"location":"platform/table-config.html#handlebar-template-helpers","text":"Handlebar Helpers can be used to apply advanced formatting to data outputs. Starting from conditionals to simple calculations. All built-in Handlebar Helpers can be used. Helpers are used in the following format: {{helper_name <required_parameters> [optional_parameters]}}","title":"Handlebar Template Helpers"},{"location":"platform/table-config.html#date","text":"Format a given time and date. {{date <date> [format]}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. format must be a valid moment.format() string . Example Template: {{date data.time}} Data: { \"data\" : { \"time\" : 1585823609000 } } Output: 02.04.2020 10:33:29","title":"date"},{"location":"platform/table-config.html#duration","text":"Format given duration. {{duration <duration> [format]}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. format must be a valid moment.format() string . Example Template: {{duration duration}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 00:00:10","title":"duration"},{"location":"platform/table-config.html#durationhumanize","text":"Format a given duration in a human readable format. {{durationHumanize <duration>}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. Example Template: {{durationHumanize data.duration}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 10 seconds","title":"durationHumanize"},{"location":"platform/table-config.html#durationas","text":"Get a given duration in a certain unit of time. {{durationAs <duration> [unit_of_time]}} duration must be a valid input for moment.duration() . When using timestamps it must be in milliseconds. unit_of_time must be a valid input for moment.duration().as() Example Template: {{durationAs data.duration \"milliseconds\"}} Data: { \"data\" : { \"duration\" : 10000 } } Output: 10000","title":"durationAs"},{"location":"platform/table-config.html#fromnow","text":"Display the time between now and a given time. See also: moment().fromNow() . {{fromNow <date>}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. Example Template: {{fromNow data.time}} Data: { \"data\" : { \"time\" : 1585823609000 } } Output: 3 days ago","title":"fromNow"},{"location":"platform/table-config.html#typeof","text":"Display the js type of a value. Useful for debugging. {{typeof <value>}} date must be a valid input for moment() . When using timestamps it must be in milliseconds. Example Template: {{typeof data.value}} Data: { \"data\" : { \"value\" : 1337 } } Output: number","title":"typeof"},{"location":"platform/table-config.html#tofixed-number-of-decimals","text":"Display a number with given amount of decimal places. For more advanced formatting see numberFormat . {{toFixed <value> [decimals]}} decimals number of decimal places (Default: 2) Example Template: {{toFixed data.value 3}} Data: { \"data\" : { \"value\" : 1.2345 } } Output: 1.234","title":"toFixed (number of decimals)"},{"location":"platform/table-config.html#numberformat","text":"Format a number. {{numberFormat <value> [options]}} options: thousandsSep separator between 3 digits (Default: locale dependent) decimalSep decimal separator (Default: locale dependent) decimals number of decimal places (Default: 2) Example Template: {{numberFormat 1024.23 thousandsSep=\".\" decimalSep=\",\"}} Data: { \"data\" : { \"value\" : 1024.2345 } } Output: 1.024,23","title":"numberFormat"},{"location":"platform/table-config.html#math-ceil-floor-div-max","text":"Mathematical operations. {{ceil <value>}} round up to integer {{floor <value>}} round down to integer {{div <nom> <denom>}} returns nom / denom {{max <list> [property_path]}} returns the biggest element from the list. Compares the given property_path .","title":"Math: ceil, floor, div, max"},{"location":"platform/table-config.html#boolean-operations","text":"Boolean operations, useful for #if conditions. {{not <value>}} negate the value {{eq <v1> <v2>}} v1 == v2 {{lt <v1> <v2>}} v1 < v2 {{lte <v1> <v2>}} v1 <= v2 {{gt <v1> <v2>}} v1 > v2 {{gte <v1> <v2>}} v1 >= v2","title":"Boolean operations"},{"location":"platform/table-config.html#icon","text":"Render an Icon {{icon <name> [category]}} name name of the icon. Find all icons here: SLDS Icons category category of the icon (Default: \"utility\").","title":"icon"},{"location":"tools/lobaro-tool.html","text":"Lobaro Maintenance Tool Downloads Lobaro Maintenance Tool Download (v1.5.4 Windows) Lobaro Maintenance Tool Download (v1.5.4 Linux) Lobaro Maintenance Tool Download (v1.5.4 Mac 64Bit) Lobaro Maintenance Tool previous versions CP2102 Driver Download Device config not saved? When upgrading the Lobaro Tool from version v1.4.x or earlier you have to hit \"F5\" or \"Site full reload\" in your browser once the Lobaro Tool started! Otherwise your device config can not be saved! This is because your browser caches the incompatible frontend from earlier versions. Supports the PC based configuration of all Lobaro IoT sensors. It is intended to be used in conjunction with our USB configuration adapter . Features Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file System Requirements Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge USB Driver The CP2102 USB driver MUST to be installed before using the Lobaro-tool. CP2102 Driver Download Download & Installation macOS / Linux After downloading the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then make the tool file executable: cd ~/lobaro chmod +x lobaro-tool ./lobaro-tool Info If MacOS shows up a security warning and refuses to start the tool: You can solve this by right-clicking the lobaro-tool file, selecting open and overrule the warning. Windows After downloading simply start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway. This is behavior is normal. Connecting to your device Physical connection Connect your Lobaro Device to the USB-port of your computer using the Lobaro Config Adapter . The 6-pin connector must be plugged into the white rectangular socket on the device that is labeled with the word CONFIG . The location of the socket is dependent on the specific device and hardware version you are trying to attach. Make sure to use the port labeled CONFIG Some of our devices have multiple sockets the connector fits into. Be sure to use the correct one, the one labeled CONFIG ! The LoRaWAN Board (left image) can be powered by the config adapter. Other devices, like the NB-IoT/LTE-M boards or the wMBus-LoRaWAN-Bridge Hardware revision 2 , need to be connected to their normal power supply. If in doubt, just make sure you have the device powered! Software connection When your device is successfully attached to your computer, you can build a connection with the Lobaro Maintenance Tool: Under Hardware Connectiom select auto and click Connect , as seen in the screenshot above. If you know to which port the device is connected to your computer (either COM or ttyUSB), you can alternatively select it explicitly instead of using auto . Device Configuration When you are connected to a Lobaro Device, you can use the Tab CONFIGURATION to read and change the configuration parameters of the Device. You can read out the current configuration from the device by pressing the Reload Config button (reading takes a few seconds). Reading/changing config reboots the device! Every time you use one of the buttons Reload Config . Write to Device , or Restore Default , the connected device will be rebooted! Also keep in mind that the operations triggered by pressing the buttons include communication with the device over a serial bus and they will take a few seconds. To avoid errors, please do not those buttons repeatedly! When the configuration is read, you can alter the parameters by clicking on the pencil icon on the right. Values that you changed will by printed in bold font. When you have adjusted all values you want to change, you must press Write to Device to actually change anything on the Device. Writing the values will reboot the device. The Button Restore Default will reset all config parameters of the connected Device to their internal default values. The device will reboot, and the listed values of the configuration in the Lobaro Maintenance Tool well be updated. Always reload the config before changing it! When you are working with multiple devices, make sure that your always press Reload Config after attaching a new device before you start updating values. If you fail to do so, you might accidentally transfer values from the previously attached device to the newly connected. This is especially a problem when working with LoRaWAN sensors, as you will copy the DevEUI from one device to the other! You can watch the rebooting of the Device and check the altered configuration parameters by locking in the LOGS Tab. Device Logging All of our Devices provide extensive logging information over the CONFIG port. When you are connected to a Device in the Lobaro Maintenance Tool, you can read the log messages in the LOGS Tab. This feature is helpful if you try to find out the cause of problems you experience. You can also find out a lot of information about your Device, for example you can find the parameters used to connect your LoRaWAN Devices to your Network Server (DevEUI, AppKey, etc.). All messages are displayed in the big textarea, each line is prefixed by the time it is received (using the clock of your computer). You can use Clear Log to start again with an empty textarea. The cleared messages will still be available through the log files that the tool creates. When starting, our devices print out their current configuration parameter values. Most Devices also have a power on test, that checks if attached sensors can be read successfully. Any Problems that the Device detects will be printed to the log. Restarting The LOGS Tab also contains a button Run (reset) . This button triggers a reboot of the attached device. This can be useful when you start working with your device or if you try to fix issues with connected sensors. Log files The log is also written to a file on your computer whenever a Device is attached to the Maintenance Tool. Every time you start the Lobaro Maintenance Tool, a new log file is created. When you press the button Show Log Files , a file browser is opened at the location where log files are kept. Sending to the Device Below the textarea is an input field Send via UART . Text entered here (and confirmed with Enter) will be sent to the connected Device via UART. Some of our Devices use this feature, for example the LoRaWAN Modbus Bridge for its interactive Dialog Mode. Log parsing If need to parse the log messages of one of our Devices with your own tools, you can connect to it without the Maintenance Tool by using any serial UART reader. You can find the UART parameters at the page for our Config Adapter . Updating Firmware Our devices are shipped ready to use with firmware installed on them, so normally you do not need to install firmware yourself. However, over time we sometimes add new features to our devices or fix bugs that come up over time. If you want to use those improvements for devices all ready shipped to you, you can update the firmware yourself. Firmware updates with our config adapter vs. firmware update over the air (FUOTA) This page describes how you install firmware on devices that you have physical access to. This can be done for most of our devices, those using LoRaWAN and those using NB-IoT/LTE-M. Our NB-IoT/LTE-M devices also support installing firmware over the air, without physical access. This can currently only be done by Lobaro. Getting the Firmware You will need the Firmware you want to install to your device as a file on your computer. You can get the latest Firmware files from this site, the Lobaro Online Documentation , on the Firmware subpage for your Device. The files are in a format called Hex and are therefore also called Hex-File . The filename always starts with app- and contains the version number as well as a short description of its function and the hardware it is used for. So, for example, app-nrf9160-wmbus-TZ2-0.3.1-mcuboot-slot0.hex contains firmware for our wMBus-Gateway on NB-IoT-Hardware (nrf9160) in version 0.3.1 . In some cases you will get a hex-file provided directly by Lobaro, when we develop a specialised solution for you. Make sure you install the correct Firmware for your hardware! If you install Firmware for a different hardware you will get unpredictable results. Installing Firmware Make sure your Device is successfully attached to the your computer and the Maintenance Tool is connected , as described above. In the Tab FIRMWARE you can select the Firmware file you want to install using the button Select Hex File . This will open a file selection dialog, where you can select the hex-file with the Firmware you want to install to your Device. To start installing you need to press Flash Hex File . The upload will take several seconds; progress will be displayed by the blue progress bar. It turns green on successful completion. You can verify the installation succeeded and your Device is now running the correct version by checking the LOGS Tab. You should also take a look at the Configuration Parameters. When an update adds new features, there might be new Configuration Parameters to set, or some existing Parameters might work differently. Check the Firmware's Changelog to see what changed between versions and what you have to look out for, for your individual Firmware update. Changelog 1.5.4 - 11.02.2020 Fix a bug where the configuration can not be changed 1.5.3 - 07.02.2020 Minor: Add \"...flash -t\" command line argument to speedup manual flash startup time 1.5.2 - 05.02.2020 Avoid browser caching of frontend code 1.5.1 - 31.01.2020 Support nRF9160 Config and Firmware update on Lobaro hardware Improve progress indicator and error checks during Flash 1.4.10 - 11.10.2019 No relevant changes 1.4.9 - 17.09.2019 Fix a bug where flashing firmware fails due to UART buffer issues 1.4.4 - 11.09.2019 Fix a bug that failed to flash very big firmware files. Add delays when communicating with Bootloader to avoid timing issues. Flash command now support --verbose flag 1.4.3 - 30.07.2019 Fix a bug where writing the config does not work. 1.4.2 - 29.07.2019 Fix a bug where the program hangs up while connecting to a wrong serial port in \"auto\" mode. Fix a bug where the tool crashes when flashing the firmware while not connected. 1.4.0 - 10.08.2018 Log Tool events like Connect, Disconnect, Read Config, etc. to UART Log Switch to firmware mode after connecting with \"auto\" port 1.3.4 - 09.08.2018 Always switch to Firmware run mode after: Connect, Load Config, Restore Config. 1.3.3 Internet Explorer support 1.3.2 - 09.07.2018 Fix reading configs bigger than 256 Bytes (needed for wMbus Bridge) 1.3.0 - 21.03.2018 Improve connection detection Allow to connect to specific serial port Do not reset to boot mode when connecting to selected serial port 1.2.5 - 07.03.2018 Fix issues with loading a configuration file. Default is now \"config.yaml\" Remove horizontal scrollbars in tabs Add \"Set Time\" button to send \"time= \" via UART Add send UART input below Log Display if Firmware or Booloader is running Add success message when loading config 1.2.4 - 07.03.2018 Allow to replace assets e.g. the logo by placing /assets/logo.png next to the executable 1.2.3 - 05.03.2018 Log Timestamp in UART log file on disk Allow to set http server ip and port to allow remote access 1.2.2 - 19.02.2018 Fix CBOR decoding error that was introduced in 1.2.0 (see: https://github.com/ugorji/go/issues/232 ) 1.2.0 - 16.02.2018 Fix Serial port issues that appear on MAC, Linux and in rare cases on Windows 1.2.0 - 15.02.2018 Log UART output to file in $HOME/.lobaro/ 1.1.x Restore Default Config Close button Closing the browser window now also shut down the server","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#lobaro-maintenance-tool","text":"Downloads Lobaro Maintenance Tool Download (v1.5.4 Windows) Lobaro Maintenance Tool Download (v1.5.4 Linux) Lobaro Maintenance Tool Download (v1.5.4 Mac 64Bit) Lobaro Maintenance Tool previous versions CP2102 Driver Download Device config not saved? When upgrading the Lobaro Tool from version v1.4.x or earlier you have to hit \"F5\" or \"Site full reload\" in your browser once the Lobaro Tool started! Otherwise your device config can not be saved! This is because your browser caches the incompatible frontend from earlier versions. Supports the PC based configuration of all Lobaro IoT sensors. It is intended to be used in conjunction with our USB configuration adapter .","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#features","text":"Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file","title":"Features"},{"location":"tools/lobaro-tool.html#system-requirements","text":"Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge USB Driver The CP2102 USB driver MUST to be installed before using the Lobaro-tool. CP2102 Driver Download","title":"System Requirements"},{"location":"tools/lobaro-tool.html#download-installation","text":"","title":"Download &amp; Installation"},{"location":"tools/lobaro-tool.html#macos-linux","text":"After downloading the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then make the tool file executable: cd ~/lobaro chmod +x lobaro-tool ./lobaro-tool Info If MacOS shows up a security warning and refuses to start the tool: You can solve this by right-clicking the lobaro-tool file, selecting open and overrule the warning.","title":"macOS / Linux"},{"location":"tools/lobaro-tool.html#windows","text":"After downloading simply start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway. This is behavior is normal.","title":"Windows"},{"location":"tools/lobaro-tool.html#connecting-to-your-device","text":"","title":"Connecting to your device"},{"location":"tools/lobaro-tool.html#physical-connection","text":"Connect your Lobaro Device to the USB-port of your computer using the Lobaro Config Adapter . The 6-pin connector must be plugged into the white rectangular socket on the device that is labeled with the word CONFIG . The location of the socket is dependent on the specific device and hardware version you are trying to attach. Make sure to use the port labeled CONFIG Some of our devices have multiple sockets the connector fits into. Be sure to use the correct one, the one labeled CONFIG ! The LoRaWAN Board (left image) can be powered by the config adapter. Other devices, like the NB-IoT/LTE-M boards or the wMBus-LoRaWAN-Bridge Hardware revision 2 , need to be connected to their normal power supply. If in doubt, just make sure you have the device powered!","title":"Physical connection"},{"location":"tools/lobaro-tool.html#software-connection","text":"When your device is successfully attached to your computer, you can build a connection with the Lobaro Maintenance Tool: Under Hardware Connectiom select auto and click Connect , as seen in the screenshot above. If you know to which port the device is connected to your computer (either COM or ttyUSB), you can alternatively select it explicitly instead of using auto .","title":"Software connection"},{"location":"tools/lobaro-tool.html#device-configuration","text":"When you are connected to a Lobaro Device, you can use the Tab CONFIGURATION to read and change the configuration parameters of the Device. You can read out the current configuration from the device by pressing the Reload Config button (reading takes a few seconds). Reading/changing config reboots the device! Every time you use one of the buttons Reload Config . Write to Device , or Restore Default , the connected device will be rebooted! Also keep in mind that the operations triggered by pressing the buttons include communication with the device over a serial bus and they will take a few seconds. To avoid errors, please do not those buttons repeatedly! When the configuration is read, you can alter the parameters by clicking on the pencil icon on the right. Values that you changed will by printed in bold font. When you have adjusted all values you want to change, you must press Write to Device to actually change anything on the Device. Writing the values will reboot the device. The Button Restore Default will reset all config parameters of the connected Device to their internal default values. The device will reboot, and the listed values of the configuration in the Lobaro Maintenance Tool well be updated. Always reload the config before changing it! When you are working with multiple devices, make sure that your always press Reload Config after attaching a new device before you start updating values. If you fail to do so, you might accidentally transfer values from the previously attached device to the newly connected. This is especially a problem when working with LoRaWAN sensors, as you will copy the DevEUI from one device to the other! You can watch the rebooting of the Device and check the altered configuration parameters by locking in the LOGS Tab.","title":"Device Configuration"},{"location":"tools/lobaro-tool.html#device-logging","text":"All of our Devices provide extensive logging information over the CONFIG port. When you are connected to a Device in the Lobaro Maintenance Tool, you can read the log messages in the LOGS Tab. This feature is helpful if you try to find out the cause of problems you experience. You can also find out a lot of information about your Device, for example you can find the parameters used to connect your LoRaWAN Devices to your Network Server (DevEUI, AppKey, etc.). All messages are displayed in the big textarea, each line is prefixed by the time it is received (using the clock of your computer). You can use Clear Log to start again with an empty textarea. The cleared messages will still be available through the log files that the tool creates. When starting, our devices print out their current configuration parameter values. Most Devices also have a power on test, that checks if attached sensors can be read successfully. Any Problems that the Device detects will be printed to the log.","title":"Device Logging"},{"location":"tools/lobaro-tool.html#restarting","text":"The LOGS Tab also contains a button Run (reset) . This button triggers a reboot of the attached device. This can be useful when you start working with your device or if you try to fix issues with connected sensors.","title":"Restarting"},{"location":"tools/lobaro-tool.html#log-files","text":"The log is also written to a file on your computer whenever a Device is attached to the Maintenance Tool. Every time you start the Lobaro Maintenance Tool, a new log file is created. When you press the button Show Log Files , a file browser is opened at the location where log files are kept.","title":"Log files"},{"location":"tools/lobaro-tool.html#sending-to-the-device","text":"Below the textarea is an input field Send via UART . Text entered here (and confirmed with Enter) will be sent to the connected Device via UART. Some of our Devices use this feature, for example the LoRaWAN Modbus Bridge for its interactive Dialog Mode.","title":"Sending to the Device"},{"location":"tools/lobaro-tool.html#log-parsing","text":"If need to parse the log messages of one of our Devices with your own tools, you can connect to it without the Maintenance Tool by using any serial UART reader. You can find the UART parameters at the page for our Config Adapter .","title":"Log parsing"},{"location":"tools/lobaro-tool.html#updating-firmware","text":"Our devices are shipped ready to use with firmware installed on them, so normally you do not need to install firmware yourself. However, over time we sometimes add new features to our devices or fix bugs that come up over time. If you want to use those improvements for devices all ready shipped to you, you can update the firmware yourself. Firmware updates with our config adapter vs. firmware update over the air (FUOTA) This page describes how you install firmware on devices that you have physical access to. This can be done for most of our devices, those using LoRaWAN and those using NB-IoT/LTE-M. Our NB-IoT/LTE-M devices also support installing firmware over the air, without physical access. This can currently only be done by Lobaro.","title":"Updating Firmware"},{"location":"tools/lobaro-tool.html#getting-the-firmware","text":"You will need the Firmware you want to install to your device as a file on your computer. You can get the latest Firmware files from this site, the Lobaro Online Documentation , on the Firmware subpage for your Device. The files are in a format called Hex and are therefore also called Hex-File . The filename always starts with app- and contains the version number as well as a short description of its function and the hardware it is used for. So, for example, app-nrf9160-wmbus-TZ2-0.3.1-mcuboot-slot0.hex contains firmware for our wMBus-Gateway on NB-IoT-Hardware (nrf9160) in version 0.3.1 . In some cases you will get a hex-file provided directly by Lobaro, when we develop a specialised solution for you. Make sure you install the correct Firmware for your hardware! If you install Firmware for a different hardware you will get unpredictable results.","title":"Getting the Firmware"},{"location":"tools/lobaro-tool.html#installing-firmware","text":"Make sure your Device is successfully attached to the your computer and the Maintenance Tool is connected , as described above. In the Tab FIRMWARE you can select the Firmware file you want to install using the button Select Hex File . This will open a file selection dialog, where you can select the hex-file with the Firmware you want to install to your Device. To start installing you need to press Flash Hex File . The upload will take several seconds; progress will be displayed by the blue progress bar. It turns green on successful completion. You can verify the installation succeeded and your Device is now running the correct version by checking the LOGS Tab. You should also take a look at the Configuration Parameters. When an update adds new features, there might be new Configuration Parameters to set, or some existing Parameters might work differently. Check the Firmware's Changelog to see what changed between versions and what you have to look out for, for your individual Firmware update.","title":"Installing Firmware"},{"location":"tools/lobaro-tool.html#changelog","text":"","title":"Changelog"},{"location":"tools/lobaro-tool.html#154-11022020","text":"Fix a bug where the configuration can not be changed","title":"1.5.4 - 11.02.2020"},{"location":"tools/lobaro-tool.html#153-07022020","text":"Minor: Add \"...flash -t\" command line argument to speedup manual flash startup time","title":"1.5.3 - 07.02.2020"},{"location":"tools/lobaro-tool.html#152-05022020","text":"Avoid browser caching of frontend code","title":"1.5.2 - 05.02.2020"},{"location":"tools/lobaro-tool.html#151-31012020","text":"Support nRF9160 Config and Firmware update on Lobaro hardware Improve progress indicator and error checks during Flash","title":"1.5.1 - 31.01.2020"},{"location":"tools/lobaro-tool.html#1410-11102019","text":"No relevant changes","title":"1.4.10 - 11.10.2019"},{"location":"tools/lobaro-tool.html#149-17092019","text":"Fix a bug where flashing firmware fails due to UART buffer issues","title":"1.4.9 - 17.09.2019"},{"location":"tools/lobaro-tool.html#144-11092019","text":"Fix a bug that failed to flash very big firmware files. Add delays when communicating with Bootloader to avoid timing issues. Flash command now support --verbose flag","title":"1.4.4 - 11.09.2019"},{"location":"tools/lobaro-tool.html#143-30072019","text":"Fix a bug where writing the config does not work.","title":"1.4.3 - 30.07.2019"},{"location":"tools/lobaro-tool.html#142-29072019","text":"Fix a bug where the program hangs up while connecting to a wrong serial port in \"auto\" mode. Fix a bug where the tool crashes when flashing the firmware while not connected.","title":"1.4.2 - 29.07.2019"},{"location":"tools/lobaro-tool.html#140-10082018","text":"Log Tool events like Connect, Disconnect, Read Config, etc. to UART Log Switch to firmware mode after connecting with \"auto\" port","title":"1.4.0 - 10.08.2018"},{"location":"tools/lobaro-tool.html#134-09082018","text":"Always switch to Firmware run mode after: Connect, Load Config, Restore Config.","title":"1.3.4 - 09.08.2018"},{"location":"tools/lobaro-tool.html#133","text":"Internet Explorer support","title":"1.3.3"},{"location":"tools/lobaro-tool.html#132-09072018","text":"Fix reading configs bigger than 256 Bytes (needed for wMbus Bridge)","title":"1.3.2 - 09.07.2018"},{"location":"tools/lobaro-tool.html#130-21032018","text":"Improve connection detection Allow to connect to specific serial port Do not reset to boot mode when connecting to selected serial port","title":"1.3.0 - 21.03.2018"},{"location":"tools/lobaro-tool.html#125-07032018","text":"Fix issues with loading a configuration file. Default is now \"config.yaml\" Remove horizontal scrollbars in tabs Add \"Set Time\" button to send \"time= \" via UART Add send UART input below Log Display if Firmware or Booloader is running Add success message when loading config","title":"1.2.5 - 07.03.2018"},{"location":"tools/lobaro-tool.html#124-07032018","text":"Allow to replace assets e.g. the logo by placing /assets/logo.png next to the executable","title":"1.2.4 - 07.03.2018"},{"location":"tools/lobaro-tool.html#123-05032018","text":"Log Timestamp in UART log file on disk Allow to set http server ip and port to allow remote access","title":"1.2.3 - 05.03.2018"},{"location":"tools/lobaro-tool.html#122-19022018","text":"Fix CBOR decoding error that was introduced in 1.2.0 (see: https://github.com/ugorji/go/issues/232 )","title":"1.2.2 - 19.02.2018"},{"location":"tools/lobaro-tool.html#120-16022018","text":"Fix Serial port issues that appear on MAC, Linux and in rare cases on Windows","title":"1.2.0 - 16.02.2018"},{"location":"tools/lobaro-tool.html#120-15022018","text":"Log UART output to file in $HOME/.lobaro/","title":"1.2.0 - 15.02.2018"},{"location":"tools/lobaro-tool.html#11x","text":"Restore Default Config Close button Closing the browser window now also shut down the server","title":"1.1.x"},{"location":"tools/usb-config-adapter.html","text":"Lobaro USB configuration adapter The Lobaro USB configuration adapter connects the configuration serial uart of our hardware to a PC. It is useful for: Sensor initial configuration, e.g. network parameters Viewing firmware log/debug diagnostic output Firmware updates using our free Lobaro Maintenance Tool PC software. Wire orientation The blue wire is not consistent the RST/RTS pin(1) and may be inverted on some adapters, e.g. being the GND wire pin(6). Check the orientation of the adapter with the picture above to determinate the actual pin ordering and do not simply rely on the the wire color coding alone! USB Driver The CP2102 USB driver needs to be installed before using it. Download CP2102 Driver Download Hardware Connection (LoRaWAN Sensors) The USB adapter uses a six-wire JST-ZH series connector for attaching to Lobaro hardware at the config connector. Boot0 of Lobaro sensors is connected to DTR line of the PC uart Reset (active low) of Lobaro sensors is connected to RTS line of the PC uart Note Normally the handling of these uart control is done automatically by the Lobaro PC tool . When using an alternative uart terminal tool (e.g. HTERM ) make sure you setup the RTS and DTR lines correctly or simply cut the DTR/RTS wires from the USB adapter if the reset and/or bootloader functions are not needed. Default UART Configuration The default 8N1 UART configuration that is used by all Lobaro devices on the \"Config\" port: BaudRate 115200 Parity No Parity StopBits OneStopBit DataBits 8 DTR control line Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset RTS control line High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running) Adapter Schematic Picture USB Config Adapter","title":"USB Config Adapter"},{"location":"tools/usb-config-adapter.html#lobaro-usb-configuration-adapter","text":"The Lobaro USB configuration adapter connects the configuration serial uart of our hardware to a PC. It is useful for: Sensor initial configuration, e.g. network parameters Viewing firmware log/debug diagnostic output Firmware updates using our free Lobaro Maintenance Tool PC software. Wire orientation The blue wire is not consistent the RST/RTS pin(1) and may be inverted on some adapters, e.g. being the GND wire pin(6). Check the orientation of the adapter with the picture above to determinate the actual pin ordering and do not simply rely on the the wire color coding alone! USB Driver The CP2102 USB driver needs to be installed before using it. Download CP2102 Driver Download","title":"Lobaro USB configuration adapter"},{"location":"tools/usb-config-adapter.html#hardware-connection-lorawan-sensors","text":"The USB adapter uses a six-wire JST-ZH series connector for attaching to Lobaro hardware at the config connector. Boot0 of Lobaro sensors is connected to DTR line of the PC uart Reset (active low) of Lobaro sensors is connected to RTS line of the PC uart Note Normally the handling of these uart control is done automatically by the Lobaro PC tool . When using an alternative uart terminal tool (e.g. HTERM ) make sure you setup the RTS and DTR lines correctly or simply cut the DTR/RTS wires from the USB adapter if the reset and/or bootloader functions are not needed.","title":"Hardware Connection (LoRaWAN Sensors)"},{"location":"tools/usb-config-adapter.html#default-uart-configuration","text":"The default 8N1 UART configuration that is used by all Lobaro devices on the \"Config\" port: BaudRate 115200 Parity No Parity StopBits OneStopBit DataBits 8","title":"Default UART Configuration"},{"location":"tools/usb-config-adapter.html#dtr-control-line","text":"Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset","title":"DTR control line"},{"location":"tools/usb-config-adapter.html#rts-control-line","text":"High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running)","title":"RTS control line"},{"location":"tools/usb-config-adapter.html#adapter-schematic","text":"Picture USB Config Adapter","title":"Adapter Schematic"}]}