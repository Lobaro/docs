{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview This site is the new upcoming central documentation for IoT products of Lobaro GmbH . Hardware Lobaro IoT Sensoren Sensor Name RF-Technology Target Measurement / Purpose Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout wMBUS LoRaWAN Bridge LoRaWAN wMBUS enabled meter reading Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level Tools Configuration / Setup Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices Background Knowledge Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Home"},{"location":"index.html#overview","text":"This site is the new upcoming central documentation for IoT products of Lobaro GmbH .","title":"Overview"},{"location":"index.html#hardware","text":"","title":"Hardware"},{"location":"index.html#lobaro-iot-sensoren","text":"Sensor Name RF-Technology Target Measurement / Purpose Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout wMBUS LoRaWAN Bridge LoRaWAN wMBUS enabled meter reading Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level","title":"Lobaro IoT Sensoren"},{"location":"index.html#tools","text":"","title":"Tools"},{"location":"index.html#configuration-setup","text":"Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices","title":"Configuration / Setup"},{"location":"index.html#background-knowledge","text":"Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Background Knowledge"},{"location":"hardware.html","text":"Hardware Variations Note We are offering all our hardware in different housings with different power supply and antenna options. Most of our products are compatible with the following variations, for details about a specific product and pricing please contact us at support@lobaro.de Housing Lobaro Box Housing Size: 114,30mm (w) x 59,30mm (l) x 26,80mm (h) Spelsberg IP67 Product Page Size: 122mm (w) x 82mm (l) x 55mm (h) DIN-Rail Housing All DIN-Rail housings that fit our hardware are possible. The DIN-Rail mount can also be used without any housing. We offer to deliver our hardware in the following housings: 130x130 (RK 4/12-L) Product Page Size: 130mm (w) x 130mm (l) x 75mm (h) 110x110 (RK 4/07-L) Product Page Size: 110mm (w) x 110mm (l) x 90mm (h) Power Supply AA-Batteries (3Ah) Only for LoRaWAN products Only our LoRaWAN hardware supports AA-Batteries inside the Lobaro Box Housing. We recommend to use Energizer Ultimate Lithium for our products. Size: AA-Cell Voltage: 1.5V Capacity: 3Ah Operating temperature: -40\u00b0C...+60\u00b0C ER34615 3.6V Battery (D-Cell, 19Ah) Size: D-Cell (34mm x 61.5mm) Voltage: 3.7V Capacity: 19Ah Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable) 5-30V External Supply Can be used standalone on an existing DIN-Rail or inside the DIN-Rail Housing (see above) Antennas By default all our products are shipped with an internal antenna. An external Antenna can be mounted on request. External antennas are connected with a standard SMA connector:","title":"Hardware Variations"},{"location":"hardware.html#hardware-variations","text":"Note We are offering all our hardware in different housings with different power supply and antenna options. Most of our products are compatible with the following variations, for details about a specific product and pricing please contact us at support@lobaro.de","title":"Hardware Variations"},{"location":"hardware.html#housing","text":"","title":"Housing"},{"location":"hardware.html#lobaro-box-housing","text":"Size: 114,30mm (w) x 59,30mm (l) x 26,80mm (h)","title":"Lobaro Box Housing"},{"location":"hardware.html#spelsberg-ip67","text":"Product Page Size: 122mm (w) x 82mm (l) x 55mm (h)","title":"Spelsberg IP67"},{"location":"hardware.html#din-rail-housing","text":"All DIN-Rail housings that fit our hardware are possible. The DIN-Rail mount can also be used without any housing. We offer to deliver our hardware in the following housings: 130x130 (RK 4/12-L) Product Page Size: 130mm (w) x 130mm (l) x 75mm (h) 110x110 (RK 4/07-L) Product Page Size: 110mm (w) x 110mm (l) x 90mm (h)","title":"DIN-Rail Housing"},{"location":"hardware.html#power-supply","text":"","title":"Power Supply"},{"location":"hardware.html#aa-batteries-3ah","text":"Only for LoRaWAN products Only our LoRaWAN hardware supports AA-Batteries inside the Lobaro Box Housing. We recommend to use Energizer Ultimate Lithium for our products. Size: AA-Cell Voltage: 1.5V Capacity: 3Ah Operating temperature: -40\u00b0C...+60\u00b0C","title":"AA-Batteries (3Ah)"},{"location":"hardware.html#er34615-36v-battery-d-cell-19ah","text":"Size: D-Cell (34mm x 61.5mm) Voltage: 3.7V Capacity: 19Ah Operating temperature: -55\u00b0C...+60\u00b0C Li-SOCl2 (not rechargeable)","title":"ER34615 3.6V Battery (D-Cell, 19Ah)"},{"location":"hardware.html#5-30v-external-supply","text":"Can be used standalone on an existing DIN-Rail or inside the DIN-Rail Housing (see above)","title":"5-30V External Supply"},{"location":"hardware.html#antennas","text":"By default all our products are shipped with an internal antenna. An external Antenna can be mounted on request. External antennas are connected with a standard SMA connector:","title":"Antennas"},{"location":"background/cron-expressions.html","text":"Cron Expressions We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0/15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed. Meaning of the six fields: 0 0/15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range (0-59) (0-59) (0-23) (1-31) (1-12) (1-7) Alternative JAN-DEC SUN-SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * / Examples Cron definition Description Trigger time point(s) (hh:mm:ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1/10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1,15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1-5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist. Special Characters: star, asterisk ( * ) Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\". question mark ( ? ) Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification. dash, minus ( - ) Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d. comma ( , ) Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d. slash ( / ) Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u201c\u2153\u201d in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d. Online CRON Generators and Tester: https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html Further Reading All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"CRON Expressions"},{"location":"background/cron-expressions.html#cron-expressions","text":"We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0/15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed.","title":"Cron Expressions"},{"location":"background/cron-expressions.html#meaning-of-the-six-fields","text":"0 0/15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range (0-59) (0-59) (0-23) (1-31) (1-12) (1-7) Alternative JAN-DEC SUN-SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * /","title":"Meaning of the six fields:"},{"location":"background/cron-expressions.html#examples","text":"Cron definition Description Trigger time point(s) (hh:mm:ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1/10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1,15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1-5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist.","title":"Examples"},{"location":"background/cron-expressions.html#special-characters","text":"","title":"Special Characters:"},{"location":"background/cron-expressions.html#star-asterisk","text":"Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\".","title":"star, asterisk (*)"},{"location":"background/cron-expressions.html#question-mark","text":"Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification.","title":"question mark (?)"},{"location":"background/cron-expressions.html#dash-minus-","text":"Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d.","title":"dash, minus (-)"},{"location":"background/cron-expressions.html#comma","text":"Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d.","title":"comma (,)"},{"location":"background/cron-expressions.html#slash","text":"Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u201c\u2153\u201d in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d.","title":"slash (/)"},{"location":"background/cron-expressions.html#online-cron-generators-and-tester","text":"https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html","title":"Online CRON Generators and Tester:"},{"location":"background/cron-expressions.html#further-reading","text":"All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"Further Reading"},{"location":"background/lorawan.html","text":"LoRaWAN LoRaWAN stands for **Lo**ng **Ra**nge **W**ide **A**rea **N**etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network. They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN) LoRa LoRa is the modulation used in LoRaWAN. It's patented by Semtech. To calculate LoRa specific parameters like transmit time you can use the SX1272 LoRa Calculator from Semtech. Timestamp Many of our devices include timestamps somewhere in their payloads. The encoding of timestamps in our payload is the same in all our LoRaWAN devices except some of our oldest. There are some details you should be aware of. Format: Points in time are represented as UNIX-timestamps within our products. That is a integer value indicating the number of seconds that have passed since 0:00h on January 1 1970 in UTC. Encoding: We encode the UNIX-timestamp in a signed 40 bit big endian integer ( int40 , 5 bytes long). The 40 bit integer is unconventional but used with good reasoning. UNIX-timestamps have traditionally been stored as signed 32 bit integers ( int32 ). This poses the problem that points in time later than January 2038 cannot be expressed . A simple solution to this is switching to store timestamps in singed 64 bit integers. This is a suitable solution for modern computers and our devices do that internally for calculations. The problem is that 64 bit integers take 8 bytes of space, and with LoRaWAN every byte is precious. 3 of those 8 bytes will be zeros for thousands of years to come, so we chose to increase the size of our timestamps by only a single byte to 40 bit. This lets us store timestamps up unto the year 19391, which we dare to say is enough. Storing numerical values with a number of bits that is not a power of 2 might be unusual, but there is nothing wrong with it. If you have problems decoding 40 bit values you can find an example implementation in JavaScript below in our example TTN parser. Device's internal clock: The timestamp uploaded by the devices is always referring to the device's internal clock. That clock is not always in sync with actual time. In fact when you power up the device it has no way to know what time it is. It sets the internal clock to 2010-01-01T00:00:00. For many applications this is not a problem! If you set the device's cron to execute at 0h, 6h, 12h, and 18h it will activate every 6 hours at the same times every day. But when exactly the device is activated depends on the the time it was first powered on. If you require your device to run in sync with actual time you can set its clock using the configuration adapter and the Lobaro Tool. LoRaWAN 1.1 also introduced time synchronization over the air which is supported by some of our devices. You will need to use a LoRaWAN Network Server that also supports this feature. Parser LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 , 40 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"LoRaWAN"},{"location":"background/lorawan.html#lorawan","text":"LoRaWAN stands for **Lo**ng **Ra**nge **W**ide **A**rea **N**etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network. They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN)","title":"LoRaWAN"},{"location":"background/lorawan.html#lora","text":"LoRa is the modulation used in LoRaWAN. It's patented by Semtech. To calculate LoRa specific parameters like transmit time you can use the SX1272 LoRa Calculator from Semtech.","title":"LoRa"},{"location":"background/lorawan.html#timestamp","text":"Many of our devices include timestamps somewhere in their payloads. The encoding of timestamps in our payload is the same in all our LoRaWAN devices except some of our oldest. There are some details you should be aware of. Format: Points in time are represented as UNIX-timestamps within our products. That is a integer value indicating the number of seconds that have passed since 0:00h on January 1 1970 in UTC. Encoding: We encode the UNIX-timestamp in a signed 40 bit big endian integer ( int40 , 5 bytes long). The 40 bit integer is unconventional but used with good reasoning. UNIX-timestamps have traditionally been stored as signed 32 bit integers ( int32 ). This poses the problem that points in time later than January 2038 cannot be expressed . A simple solution to this is switching to store timestamps in singed 64 bit integers. This is a suitable solution for modern computers and our devices do that internally for calculations. The problem is that 64 bit integers take 8 bytes of space, and with LoRaWAN every byte is precious. 3 of those 8 bytes will be zeros for thousands of years to come, so we chose to increase the size of our timestamps by only a single byte to 40 bit. This lets us store timestamps up unto the year 19391, which we dare to say is enough. Storing numerical values with a number of bits that is not a power of 2 might be unusual, but there is nothing wrong with it. If you have problems decoding 40 bit values you can find an example implementation in JavaScript below in our example TTN parser. Device's internal clock: The timestamp uploaded by the devices is always referring to the device's internal clock. That clock is not always in sync with actual time. In fact when you power up the device it has no way to know what time it is. It sets the internal clock to 2010-01-01T00:00:00. For many applications this is not a problem! If you set the device's cron to execute at 0h, 6h, 12h, and 18h it will activate every 6 hours at the same times every day. But when exactly the device is activated depends on the the time it was first powered on. If you require your device to run in sync with actual time you can set its clock using the configuration adapter and the Lobaro Tool. LoRaWAN 1.1 also introduced time synchronization over the air which is supported by some of our devices. You will need to use a LoRaWAN Network Server that also supports this feature.","title":"Timestamp"},{"location":"background/lorawan.html#parser","text":"LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 , 40 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Parser"},{"location":"background/obis-codes.html","text":"OBIS-Codes Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61. Structure Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used Examples 1.0:1.8.0*255 Positive active energy (A+) total [kWh] 1.0:3.8.1*255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"OBIS Codes"},{"location":"background/obis-codes.html#obis-codes","text":"Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61.","title":"OBIS-Codes"},{"location":"background/obis-codes.html#structure","text":"Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used","title":"Structure"},{"location":"background/obis-codes.html#examples","text":"1.0:1.8.0*255 Positive active energy (A+) total [kWh] 1.0:3.8.1*255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"Examples"},{"location":"background/weee-disposal.html","text":"Disposal of Lobaro Devices Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash. WEEE The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility. Proper disposal of Lobaro B2B devices Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\". RoHS As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU. Batteries Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"WEEE Disposal"},{"location":"background/weee-disposal.html#disposal-of-lobaro-devices","text":"Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash.","title":"Disposal of Lobaro Devices"},{"location":"background/weee-disposal.html#weee","text":"The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility.","title":"WEEE"},{"location":"background/weee-disposal.html#proper-disposal-of-lobaro-b2b-devices","text":"Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\".","title":"Proper disposal of Lobaro B2B devices"},{"location":"background/weee-disposal.html#rohs","text":"As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU.","title":"RoHS"},{"location":"background/weee-disposal.html#batteries","text":"Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"Batteries"},{"location":"background/weee-entsorgung.html","text":"Entsorgung von Ger\u00e4ten von Lobaro English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten. WEEE Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung. Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein. RoHS Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU. Batteriegesetz Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#entsorgung-von-geraten-von-lobaro","text":"English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten.","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#weee","text":"Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung.","title":"WEEE"},{"location":"background/weee-entsorgung.html#ordnungsgemae-entsorgung-von-b2b-lobaro-geraten","text":"Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein.","title":"Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten"},{"location":"background/weee-entsorgung.html#rohs","text":"Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU.","title":"RoHS"},{"location":"background/weee-entsorgung.html#batteriegesetz","text":"Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Batteriegesetz"},{"location":"dashboard/index.html","text":"Lobaro Dashboard The Lobaro Dashboard can be found at dashboard.lobaro.com Overview The Dashboard shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. Incoming data from a connected Sensor received by a Datasource and mapped to a single Device where the Raw Data is saved and a Parser gets executed. The result of the parser is saved as Device Data used for visualization inside the dashboard. graph LR; data>Sensor Data]-->ds(Datasource) device(device) ds-->device device-->parser(Parser) device-->raw[Raw Data] parser-->parsed[Device Data] REST API The API is located and documented at: https://backend.lobaro.com/api Filter query parameters Filters parameters can be appended to some requests in the form of f:<parameter>=<op>:<value> e.g. f:createdAt=gt:<timestamp> to filter by createdAt date. The Value must be URL encoded e.g. a timestamp might look like gt:2000-01-01T02:37:00%2B01:00 The allowed <parameter> is specified for each endpoint separately. <op> must be one of the following operators: In Query Meaning eq = lte <= lt < gte >= gt > If no operator is given the default eq operator will be used. Parser A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; } JS Parser API All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \"value\" ); Get an arbitary device property, displayed on the \"Overview\" tab of the device var value = Device . getProperty ( \"key\" ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ());","title":"Lobaro Dashboard"},{"location":"dashboard/index.html#lobaro-dashboard","text":"The Lobaro Dashboard can be found at dashboard.lobaro.com","title":"Lobaro Dashboard"},{"location":"dashboard/index.html#overview","text":"The Dashboard shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. Incoming data from a connected Sensor received by a Datasource and mapped to a single Device where the Raw Data is saved and a Parser gets executed. The result of the parser is saved as Device Data used for visualization inside the dashboard. graph LR; data>Sensor Data]-->ds(Datasource) device(device) ds-->device device-->parser(Parser) device-->raw[Raw Data] parser-->parsed[Device Data]","title":"Overview"},{"location":"dashboard/index.html#rest-api","text":"The API is located and documented at: https://backend.lobaro.com/api","title":"REST API"},{"location":"dashboard/index.html#filter-query-parameters","text":"Filters parameters can be appended to some requests in the form of f:<parameter>=<op>:<value> e.g. f:createdAt=gt:<timestamp> to filter by createdAt date. The Value must be URL encoded e.g. a timestamp might look like gt:2000-01-01T02:37:00%2B01:00 The allowed <parameter> is specified for each endpoint separately. <op> must be one of the following operators: In Query Meaning eq = lte <= lt < gte >= gt > If no operator is given the default eq operator will be used.","title":"Filter query parameters"},{"location":"dashboard/index.html#parser","text":"A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; }","title":"Parser"},{"location":"dashboard/index.html#js-parser-api","text":"All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \"value\" ); Get an arbitary device property, displayed on the \"Overview\" tab of the device var value = Device . getProperty ( \"key\" ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ());","title":"JS Parser API"},{"location":"lorawan-sensors/config-lorawan.html","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"Config lorawan"},{"location":"lorawan-sensors/1-wire-lorawan/index.html","text":"1-Wire LoRaWAN Bridge Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks. Configuration Without configuration the sensors will be transmitted ordered by the 48 Bit id, ignoring the Sensorfamily prefix and the Checksum. name description example value SendInternalTemp Toggle output of internal sensor \"true\" or \"false\" SensorIdOrder Semicolon separated list of 48 Bit IDs in hex 22ffffff0000;44ffffff0000;11ffffff0000 Payload Example payloads for each port: Status Message (Port 1) Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" } Data Message (Port 2) Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true } Parser TheThingsNetwork (TTN) function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; } module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); }","title":"Manual"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#1-wire-lorawan-bridge","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"1-Wire LoRaWAN Bridge"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#target-measurement-purpose","text":"Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#configuration","text":"Without configuration the sensors will be transmitted ordered by the 48 Bit id, ignoring the Sensorfamily prefix and the Checksum. name description example value SendInternalTemp Toggle output of internal sensor \"true\" or \"false\" SensorIdOrder Semicolon separated list of 48 Bit IDs in hex 22ffffff0000;44ffffff0000;11ffffff0000","title":"Configuration"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#payload","text":"Example payloads for each port:","title":"Payload"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#status-message-port-1","text":"Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" }","title":"Status Message (Port 1)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#data-message-port-2","text":"Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true }","title":"Data Message (Port 2)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#thethingsnetwork-ttn","text":"function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; } module . exports = function ( payload , meta ) { const port = meta . lora . fport ; const buf = Buffer . from ( payload , 'hex' ); return Decoder ( buf , port ); }","title":"TheThingsNetwork (TTN)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html","text":"1-Wire LoRaWAN Bridge (Temperature Sensors) Firmware Downloads: app-lorawan-onewire-bridge-0.3.4.hex Changelog v0.3.4 (13.08.2019) fixed bug in sorting algorithm v0.3.3 (01.08.2019) Added ADR config parameter v0.3.2 (01.08.2019) Fixed Onewire init after DeepSleep v0.3.1 (29.07.2019) Temp sensors will be printed and sent sorted by parameter \"SensorIdOrder\" and by ID or just by ID if parameter \"SensorIdOrder\" is empty v0.2.0 (15.02.2019) Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload v0.0.3 Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset v0.0.2 Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"Firmware & Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#1-wire-lorawan-bridge-temperature-sensors","text":"","title":"1-Wire LoRaWAN Bridge (Temperature Sensors)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-onewire-bridge-0.3.4.hex","title":"Firmware"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v034-13082019","text":"fixed bug in sorting algorithm","title":"v0.3.4 (13.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v033-01082019","text":"Added ADR config parameter","title":"v0.3.3 (01.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v032-01082019","text":"Fixed Onewire init after DeepSleep","title":"v0.3.2 (01.08.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v031-29072019","text":"Temp sensors will be printed and sent sorted by parameter \"SensorIdOrder\" and by ID or just by ID if parameter \"SensorIdOrder\" is empty","title":"v0.3.1 (29.07.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v020-15022019","text":"Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload","title":"v0.2.0 (15.02.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v003","text":"Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset","title":"v0.0.3"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v002","text":"Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"v0.0.2"},{"location":"lorawan-sensors/_template/index.html","text":"Name of Sensor Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#name-of-sensor","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#target-measurement-purpose","text":"xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/_template/firmware.html","text":"Name of Sensor Firmware Downloads : firmware.hex Changelog v0.0.1 Initial release","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#name-of-sensor","text":"","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#firmware","text":"Downloads : firmware.hex","title":"Firmware"},{"location":"lorawan-sensors/_template/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/_template/firmware.html#v001","text":"Initial release","title":"v0.0.1"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html","text":"EDL21 Electricity meter LoRaWAN Bridge Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Readout of EDL21 electricity meter with optical infrared \"INFO\" interface. Quickstart Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Operation Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1-0:1.7.255*255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes . LED blinking patterns The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red/green/blue 300ms each initial pattern after reset red short, blinking trying to receive meter optical data for the first time after reset green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once. Appendices Technical characteristics Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } } Example parser result Test input: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u20007B\u20007D\u200023\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 232588.30000000002 , \"valueHex\" : \"7b7d230000000000\" } ] }","title":"Manual"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#edl21-electricity-meter-lorawan-bridge","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#target-measurement-purpose","text":"Readout of EDL21 electricity meter with optical infrared \"INFO\" interface.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#quickstart","text":"Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment","title":"Quickstart"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1-0:1.7.255*255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes .","title":"Operation"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#led-blinking-patterns","text":"The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red/green/blue 300ms each initial pattern after reset red short, blinking trying to receive meter optical data for the first time after reset green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once.","title":"LED blinking patterns"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#technical-characteristics","text":"Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } }","title":"Reference decoder"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#example-parser-result","text":"Test input: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u20007B\u20007D\u200023\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 232588.30000000002 , \"valueHex\" : \"7b7d230000000000\" } ] }","title":"Example parser result"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html","text":"EDL21 Electricity meter LoRaWAN Bridge Firmware Downloads: app-edl21-opto-0.3.1+LoRa.hex New Opto-Head Version (round) app-edl21-opto-0.2.0+LoRa.hex Old Opto-Head Version (square) Changelog Firmware: app-edl21-opto v0.3.1 Initial release for new round Opto-Head","title":"Firmware & Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#edl21-electricity-meter-lorawan-bridge","text":"","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#firmware","text":"Downloads: app-edl21-opto-0.3.1+LoRa.hex New Opto-Head Version (round) app-edl21-opto-0.2.0+LoRa.hex Old Opto-Head Version (square)","title":"Firmware"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#changelog","text":"Firmware: app-edl21-opto","title":"Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v031","text":"Initial release for new round Opto-Head","title":"v0.3.1"},{"location":"lorawan-sensors/gps-lorawan/index.html","text":"GPS / GLONASS LoRaWAN Tracker Hardware Revisions The picture above shows the tracker in hardware revision 2 with GPS and additional GLONASS support for best positioning. Hardware revision 1 with GPS only is no longer available. Show pictures of different hardware revisions Overview The LoRaWAN GPS Tracker (GPS-LoRaWAN) is a battery powered tracking device, that uses the satellite based positioning services GPS and GLONASS to determine its location and transmits the obtained coordinates via LoRaWAN radio technology. Intervals between measurements can be freely configured, in order to adjust the device to individual needs. An integrated motion sensor detects changes in the device's movement (if it is picked up or transported in a vehicle). This allows the device to switch between an Active Mode in which frequent updates are uploaded during phases of movement and an Alive Mode that saves battery power by sending only few updates. While not sending updates, the device enters a sleep mode that only uses \u223c30 \u00b5A. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device. Operating the GPS Tracker Once batteries are inserted into the device, it will start working. The Tracker will most likely need to be adjusted to your personal LoRaWAN configuration (see chapter \"Configuration\"). Batteries The LoRaWAN GPS Tracker default power supply consists of two series connected off-theshelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium-Iron- Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB). Installation The device can be fixed on a flat surface using the lateral mounting holes of the case, see Hardware Variations for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Note Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Work Cycle graph LR; GPS(GPS Collection) Data(Data Transfer) Active(Active Sleep) Alive(Alive Sleep) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>GPS(GPS Collect.); Data==>|recent movement|Active(Active Sleep); GPS==>Data(Data Transfer); Active==>|short time cron expression|GPS(GPS Collection); Data(Data Transfer)==>|no recent movement|Alive(Alive Sleep); Alive==>|movement or long time cron expression|GPS(GPS Collection); The GPS Tracker has a work cycle that adapts to detected motion of the device. Initial Phase This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered. GPS Collection Phase During the GPS Collection Phase the device will try to determine its coordinates (latitude, longitude, and height) using GPS. You can identify this phase by the onboard LED flashing on and off in one second intervals. Once the position has been determined successfully (or the attempt timed out and failed, because of bad GPS reception), the device enters the Data Transfer Phase. Data Transfer Phase During the Data Transfer Phase the Tracker uploads the GPS coordinates to the LoRaWAN network. The message contains the information if the measurement was successful. Some status information about the device are included as well. For a detailed description of the data sent refer to \"LoRaWAN Data Upload Formats\". After data transfer, the GPS Tracker enters a sleep state to save power. Depending on how much time passed since the last physical movement of the device (determined by the internal motion sensor), the Tracker enters diferent sleep phases. If the time since the last detected motion is less than a timeout value (configurable, standard value is 65 minutes), the device remains in Active mode enters only a short sleep phase ( Active Sleep ). If no motion was detected for a time longer than the timeout, the device enters the Alive Sleep Phase, which typically has a much longer sleeping time, but in which the device will also be activated through movement. Active Sleep Phase Even in Active Mode, the device spends most of its time in a deep sleep state to conserve energy. The frequency with which the Tracker wakes up in Active Mode can be configured using a Cron expression (see \"GPS configuration parameters\"). Typical values for active sleep time are 5 or 15 minutes. When in Active Sleep Phase, the device will not be triggered to gather more GPS positions through motion, but movement of the device will still be registered to keep the Tracker in Active Mode. Alive Sleep Phase When no movement has been detected for a long amount of time (configurable), the device stops sending updates, since there is not much point in sending frequent position information when the device does not change its position. In Alive Mode, only very few updates are sent to keep the network informed about the device's health. Typically one message is sent per day in this mode (frequency can be configured with a cron expression, see \"GPS configuration parameters\"). When physical movement is detected by the internal motion sensor during this phase, the GPS Tracker immediately wakes up and switches to Active Mode. Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration gets plugged/unplugged! Connecting the USB config adapter For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. Hardware Revisions The picture above shows the tracker in hardware revision 1 with GPS only support. Hardware revision 1 with GPS only is no longer available. System Parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN network parameters A large part of the configuration parameters are used to control the device's usage of Lo- RaWAN. The table lists all of them. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The Lo-RaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR) GPS configuration parameters The behaviour of the GPS Tracker and how it switches between its two operation modes ('Active' and 'Alive') can be adjusted to your needs. The table explains the configuration parameters used for this. Name Type Description ActiveCron string Cron expression defining how often the device will take a measurement and send its position over LoRaWAN while the Tracker is in Active Mode. This expression should trigger much more frequent than the one for Alive Mode. The standard is 0 0/15 * * * *, which will trigger every 15 minutes. See chapter \"Cron expressions\" for an introduction to cron expressions. AliveCron string Cron expression defining how often the device will wake up when in Alive Mode. This should be less frequent than in Active Mode. The standard is 0 0 0/12 * * *, which translates to twice each day. See chapter \"Cron expressions\" for an introduction to cron expressions. gpsTO int Time in seconds to wait for GPS to get a fix before timing out. The standard value is 180 seconds. actTO int Time in minutes without movement after which the Tracker switches to Alive Mode. The standard value is 65 minutes. memsTh int Threshold for the internal motion detector to register movement. Values range from 2 to 255. A higher value makes the device less sensitive. 2 Environment (wind or steps) may trigger. 5 Standard, picking up the device will activate it. 20 Carefully picking it up will not trigger the device. 50 When carried, running will trigger, walking won't. 100+ Shaking will activate, dropping the device might not. CayenneLPP bool Use alternative Cayenne LPP upload format. Standard: false, e.g. use Lobaro Format. See chapter \"myDevices Cayenne format\" for an introduction to this format. Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00 LoRaWAN Data Upload Formats After reading GPS coordinates (either successfully or unsuccessfully), the Tracker uploads the data using LoRaWAN. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes, no keys or data types are included. The meaning of a byte is determined by its position within a message. The tracker supports two different upload formats as described in the following: Lobaro upload format (since Firmware Version 5) Only a single massage format is used by the GPS Tracker, it has a fixed length of 17 bytes. The table explains the message format used. This format uses the decimal degrees notation for the location, e.g. 53.4724\u00b0 north and 9.9334\u00b0 east. Positive (+) values indicate north longitudes and east latitudes, negative (-) values indicate south longitudes and west latitudes. Both location values are transmitted as signed integers in big endian format and get multiplied by 100.000. So after receiving the location data must be divided by this factor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units, e.g. 1/100000 degree (as described before), to handle only with integers. Fields, Data Packet name bytes type description example / range temp 0-1 int16 Temperature inside the device in 1/10\u00b0C 246 = 24.6 \u00b0C v_bat 2-3 uint16 Current battery voltage in mV 3547 = 3.547 V latitude deg 4-7 int32 int32 degrees of the latitude x 100 000 -9 000 000 to 9 000 000 longitude deg 8-11 int32 degrees of the longitude x 100 000 -18 000 000 to 18 000 000 altitude 12-14 int24 Altitude of the device in centimeters -8 388 607 to 8 388 606 flags 15 uint8 Status flag, refer to table below 00bin = invalid, alive 01bin = valid, alive 10bin = invalid, active 11bin = valid, active sat 16 uint8 GPS satellites found / in view 7 Status flag bit function not set set 1 Validity of last measurement invalid valid 2 Current operation mode alive active 3-8 reserved for future use If during some configurable period of time (see \"gpsTO\" parameter in table \"GPS configuration parameters\") no GPS location can be found the last known valid GPS location will be transmitted but with the valid flag set to false. We provide a JavaScript reference implementation of a decoder for the data packages, which can be used directly for decoding in The Things Network . myDevices Cayenne format As an alternative for the Lobaro data format the tracker can be configured to send Cayenne LPP compatible LoRaWAN uploads. myDevices Cayenne allows you to quickly visualize the via LoRaWAN transmitted data of the Lobaro GPS-tracker. You can use Cayenne as a tool to visualize real-time and historical data, sent over The Things Network and various other LoRaWAN providers. To use the alternative upload format configuration parameter \"CayenneLPP\" must be set to \"true\" as described in section \"GPS configuration parameters\" The advantages of using the cayenne format is a quick device evaluation without programming some custom backend and/or front software. Disadvantages are bigger LoRaWAN message sizes due to the additional schema meta information overhead the format needs. The Lobaro GPS Trackers maps its data to cayenne channels as follows: description cayenne channel cayenne type Internal Temperature 0 Temperature Battery Voltage 1 AnalogOutput GPS data 2 GPS satellites found 3 Digital Output Legacy upload format (up to Firmware Version 4) This format is not supported any more since firmware version V5.0.0! Please consider updating your device firmware using the Lobaro maintenance tool. Only a single massage format is used by the GPS Tracker, it has a fixed length of 15 bytes. This format uses the degrees with decimal minutes notation for the location. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). The table underneath explains the message format used. name type description example/range flags uint8 Status flags, for internal use 0 temp int16 Temperature inside the device in 1/10\u00b0C 246 \u2259 24.6 \u00b0C v_bat uint16 Current battery voltage in mV 3547 \u2259 3:547 V latitude deg int8 Whole degrees of the latitude -90 to 90 Example As an illustration, if the received data would consist of the 15 bytes (hexencoded): 00 01 18 0D 69 35 1C 0F 71 09 38 02 4B 01 06 type example description flag 00 for internal use, ignore temp 01 18 0118 hex = 0280dec \u2259 280 d\u00b0C = 28.0 \u00b0C v_bat 0D 69 0D89 hex = 3465dec \u2259 3465mV = 3.465V latitude 35 1C 0F 71 35hex = 53dec \u2259 53\u00b0 1C hex = 28dec \u2259 28' 0F71 hex = 3953dec \u2259 0.3953' 351C0F71 \u2259 53\u00b028.3952' = 53.473255\u00b0 = 53\u00b028'23.718'' North longitude 09 38 02 4B 09 hex = 09dec \u2259 09\u00b0 38 hex = 56dec \u2259 56' 024B hex = 0587dec \u2259 0.0587' 0938024B \u2259 9\u00b056.0587' = 9.934 312\u00b0 = 9\u00b056'3.522'' East valid 01 01hex \u2259 valid measurement, could receive GPS signal sat 06 06hex = 06dec \u2259 Signal of 6 satellites received for measurement Technical characteristics Product Type name GPS-LoRaWAN Description LoRaWAN GPS Tracker RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with GPS standby and MEMS running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity PDF Documentation User Manual (en) CE Conformity Parser The Things Network For Version 4.x, 5.x and 6.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } }","title":"Manual"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-glonass-lorawan-tracker","text":"Hardware Revisions The picture above shows the tracker in hardware revision 2 with GPS and additional GLONASS support for best positioning. Hardware revision 1 with GPS only is no longer available. Show pictures of different hardware revisions","title":"GPS / GLONASS LoRaWAN Tracker"},{"location":"lorawan-sensors/gps-lorawan/index.html#overview","text":"The LoRaWAN GPS Tracker (GPS-LoRaWAN) is a battery powered tracking device, that uses the satellite based positioning services GPS and GLONASS to determine its location and transmits the obtained coordinates via LoRaWAN radio technology. Intervals between measurements can be freely configured, in order to adjust the device to individual needs. An integrated motion sensor detects changes in the device's movement (if it is picked up or transported in a vehicle). This allows the device to switch between an Active Mode in which frequent updates are uploaded during phases of movement and an Alive Mode that saves battery power by sending only few updates. While not sending updates, the device enters a sleep mode that only uses \u223c30 \u00b5A. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device.","title":"Overview"},{"location":"lorawan-sensors/gps-lorawan/index.html#operating-the-gps-tracker","text":"Once batteries are inserted into the device, it will start working. The Tracker will most likely need to be adjusted to your personal LoRaWAN configuration (see chapter \"Configuration\").","title":"Operating the GPS Tracker"},{"location":"lorawan-sensors/gps-lorawan/index.html#batteries","text":"The LoRaWAN GPS Tracker default power supply consists of two series connected off-theshelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium-Iron- Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB).","title":"Batteries"},{"location":"lorawan-sensors/gps-lorawan/index.html#installation","text":"The device can be fixed on a flat surface using the lateral mounting holes of the case, see Hardware Variations for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Note Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Installation"},{"location":"lorawan-sensors/gps-lorawan/index.html#work-cycle","text":"graph LR; GPS(GPS Collection) Data(Data Transfer) Active(Active Sleep) Alive(Alive Sleep) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>GPS(GPS Collect.); Data==>|recent movement|Active(Active Sleep); GPS==>Data(Data Transfer); Active==>|short time cron expression|GPS(GPS Collection); Data(Data Transfer)==>|no recent movement|Alive(Alive Sleep); Alive==>|movement or long time cron expression|GPS(GPS Collection); The GPS Tracker has a work cycle that adapts to detected motion of the device.","title":"Work Cycle"},{"location":"lorawan-sensors/gps-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan-join-phase","text":"If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-collection-phase","text":"During the GPS Collection Phase the device will try to determine its coordinates (latitude, longitude, and height) using GPS. You can identify this phase by the onboard LED flashing on and off in one second intervals. Once the position has been determined successfully (or the attempt timed out and failed, because of bad GPS reception), the device enters the Data Transfer Phase.","title":"GPS Collection Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Tracker uploads the GPS coordinates to the LoRaWAN network. The message contains the information if the measurement was successful. Some status information about the device are included as well. For a detailed description of the data sent refer to \"LoRaWAN Data Upload Formats\". After data transfer, the GPS Tracker enters a sleep state to save power. Depending on how much time passed since the last physical movement of the device (determined by the internal motion sensor), the Tracker enters diferent sleep phases. If the time since the last detected motion is less than a timeout value (configurable, standard value is 65 minutes), the device remains in Active mode enters only a short sleep phase ( Active Sleep ). If no motion was detected for a time longer than the timeout, the device enters the Alive Sleep Phase, which typically has a much longer sleeping time, but in which the device will also be activated through movement.","title":"Data Transfer Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#active-sleep-phase","text":"Even in Active Mode, the device spends most of its time in a deep sleep state to conserve energy. The frequency with which the Tracker wakes up in Active Mode can be configured using a Cron expression (see \"GPS configuration parameters\"). Typical values for active sleep time are 5 or 15 minutes. When in Active Sleep Phase, the device will not be triggered to gather more GPS positions through motion, but movement of the device will still be registered to keep the Tracker in Active Mode.","title":"Active Sleep Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#alive-sleep-phase","text":"When no movement has been detected for a long amount of time (configurable), the device stops sending updates, since there is not much point in sending frequent position information when the device does not change its position. In Alive Mode, only very few updates are sent to keep the network informed about the device's health. Typically one message is sent per day in this mode (frequency can be configured with a cron expression, see \"GPS configuration parameters\"). When physical movement is detected by the internal motion sensor during this phase, the GPS Tracker immediately wakes up and switches to Active Mode.","title":"Alive Sleep Phase"},{"location":"lorawan-sensors/gps-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/gps-lorawan/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration gets plugged/unplugged!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/gps-lorawan/index.html#connecting-the-usb-config-adapter","text":"For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. Hardware Revisions The picture above shows the tracker in hardware revision 1 with GPS only support. Hardware revision 1 with GPS only is no longer available.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/gps-lorawan/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System Parameters"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan-network-parameters","text":"A large part of the configuration parameters are used to control the device's usage of Lo- RaWAN. The table lists all of them. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The Lo-RaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR)","title":"LoRaWAN network parameters"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-configuration-parameters","text":"The behaviour of the GPS Tracker and how it switches between its two operation modes ('Active' and 'Alive') can be adjusted to your needs. The table explains the configuration parameters used for this. Name Type Description ActiveCron string Cron expression defining how often the device will take a measurement and send its position over LoRaWAN while the Tracker is in Active Mode. This expression should trigger much more frequent than the one for Alive Mode. The standard is 0 0/15 * * * *, which will trigger every 15 minutes. See chapter \"Cron expressions\" for an introduction to cron expressions. AliveCron string Cron expression defining how often the device will wake up when in Alive Mode. This should be less frequent than in Active Mode. The standard is 0 0 0/12 * * *, which translates to twice each day. See chapter \"Cron expressions\" for an introduction to cron expressions. gpsTO int Time in seconds to wait for GPS to get a fix before timing out. The standard value is 180 seconds. actTO int Time in minutes without movement after which the Tracker switches to Alive Mode. The standard value is 65 minutes. memsTh int Threshold for the internal motion detector to register movement. Values range from 2 to 255. A higher value makes the device less sensitive. 2 Environment (wind or steps) may trigger. 5 Standard, picking up the device will activate it. 20 Carefully picking it up will not trigger the device. 50 When carried, running will trigger, walking won't. 100+ Shaking will activate, dropping the device might not. CayenneLPP bool Use alternative Cayenne LPP upload format. Standard: false, e.g. use Lobaro Format. See chapter \"myDevices Cayenne format\" for an introduction to this format.","title":"GPS configuration parameters"},{"location":"lorawan-sensors/gps-lorawan/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/gps-lorawan/index.html#lorawan-data-upload-formats","text":"After reading GPS coordinates (either successfully or unsuccessfully), the Tracker uploads the data using LoRaWAN. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes, no keys or data types are included. The meaning of a byte is determined by its position within a message. The tracker supports two different upload formats as described in the following:","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/gps-lorawan/index.html#lobaro-upload-format-since-firmware-version-5","text":"Only a single massage format is used by the GPS Tracker, it has a fixed length of 17 bytes. The table explains the message format used. This format uses the decimal degrees notation for the location, e.g. 53.4724\u00b0 north and 9.9334\u00b0 east. Positive (+) values indicate north longitudes and east latitudes, negative (-) values indicate south longitudes and west latitudes. Both location values are transmitted as signed integers in big endian format and get multiplied by 100.000. So after receiving the location data must be divided by this factor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units, e.g. 1/100000 degree (as described before), to handle only with integers.","title":"Lobaro upload format (since Firmware Version 5)"},{"location":"lorawan-sensors/gps-lorawan/index.html#fields-data-packet","text":"name bytes type description example / range temp 0-1 int16 Temperature inside the device in 1/10\u00b0C 246 = 24.6 \u00b0C v_bat 2-3 uint16 Current battery voltage in mV 3547 = 3.547 V latitude deg 4-7 int32 int32 degrees of the latitude x 100 000 -9 000 000 to 9 000 000 longitude deg 8-11 int32 degrees of the longitude x 100 000 -18 000 000 to 18 000 000 altitude 12-14 int24 Altitude of the device in centimeters -8 388 607 to 8 388 606 flags 15 uint8 Status flag, refer to table below 00bin = invalid, alive 01bin = valid, alive 10bin = invalid, active 11bin = valid, active sat 16 uint8 GPS satellites found / in view 7","title":"Fields, Data Packet"},{"location":"lorawan-sensors/gps-lorawan/index.html#status-flag","text":"bit function not set set 1 Validity of last measurement invalid valid 2 Current operation mode alive active 3-8 reserved for future use If during some configurable period of time (see \"gpsTO\" parameter in table \"GPS configuration parameters\") no GPS location can be found the last known valid GPS location will be transmitted but with the valid flag set to false. We provide a JavaScript reference implementation of a decoder for the data packages, which can be used directly for decoding in The Things Network .","title":"Status flag"},{"location":"lorawan-sensors/gps-lorawan/index.html#mydevices-cayenne-format","text":"As an alternative for the Lobaro data format the tracker can be configured to send Cayenne LPP compatible LoRaWAN uploads. myDevices Cayenne allows you to quickly visualize the via LoRaWAN transmitted data of the Lobaro GPS-tracker. You can use Cayenne as a tool to visualize real-time and historical data, sent over The Things Network and various other LoRaWAN providers. To use the alternative upload format configuration parameter \"CayenneLPP\" must be set to \"true\" as described in section \"GPS configuration parameters\" The advantages of using the cayenne format is a quick device evaluation without programming some custom backend and/or front software. Disadvantages are bigger LoRaWAN message sizes due to the additional schema meta information overhead the format needs. The Lobaro GPS Trackers maps its data to cayenne channels as follows: description cayenne channel cayenne type Internal Temperature 0 Temperature Battery Voltage 1 AnalogOutput GPS data 2 GPS satellites found 3 Digital Output","title":"myDevices Cayenne format"},{"location":"lorawan-sensors/gps-lorawan/index.html#legacy-upload-format-up-to-firmware-version-4","text":"This format is not supported any more since firmware version V5.0.0! Please consider updating your device firmware using the Lobaro maintenance tool. Only a single massage format is used by the GPS Tracker, it has a fixed length of 15 bytes. This format uses the degrees with decimal minutes notation for the location. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). The table underneath explains the message format used. name type description example/range flags uint8 Status flags, for internal use 0 temp int16 Temperature inside the device in 1/10\u00b0C 246 \u2259 24.6 \u00b0C v_bat uint16 Current battery voltage in mV 3547 \u2259 3:547 V latitude deg int8 Whole degrees of the latitude -90 to 90","title":"Legacy upload format (up to Firmware Version 4)"},{"location":"lorawan-sensors/gps-lorawan/index.html#example","text":"As an illustration, if the received data would consist of the 15 bytes (hexencoded): 00 01 18 0D 69 35 1C 0F 71 09 38 02 4B 01 06 type example description flag 00 for internal use, ignore temp 01 18 0118 hex = 0280dec \u2259 280 d\u00b0C = 28.0 \u00b0C v_bat 0D 69 0D89 hex = 3465dec \u2259 3465mV = 3.465V latitude 35 1C 0F 71 35hex = 53dec \u2259 53\u00b0 1C hex = 28dec \u2259 28' 0F71 hex = 3953dec \u2259 0.3953' 351C0F71 \u2259 53\u00b028.3952' = 53.473255\u00b0 = 53\u00b028'23.718'' North longitude 09 38 02 4B 09 hex = 09dec \u2259 09\u00b0 38 hex = 56dec \u2259 56' 024B hex = 0587dec \u2259 0.0587' 0938024B \u2259 9\u00b056.0587' = 9.934 312\u00b0 = 9\u00b056'3.522'' East valid 01 01hex \u2259 valid measurement, could receive GPS signal sat 06 06hex = 06dec \u2259 Signal of 6 satellites received for measurement","title":"Example"},{"location":"lorawan-sensors/gps-lorawan/index.html#technical-characteristics","text":"Product Type name GPS-LoRaWAN Description LoRaWAN GPS Tracker RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with GPS standby and MEMS running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity","title":"Technical characteristics"},{"location":"lorawan-sensors/gps-lorawan/index.html#pdf-documentation","text":"User Manual (en) CE Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/gps-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/gps-lorawan/index.html#the-things-network","text":"For Version 4.x, 5.x and 6.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } }","title":"The Things Network"},{"location":"lorawan-sensors/gps-lorawan/firmware.html","text":"LoRaWAN GPS Tracker Firmware Downloads Hardware Revision 2.x Downloads : app-lorawan-gps-button-6.0.3.hex (hardware v2.x) Hardware Revision 1.x Downloads : app-lorawan-gps-button-5.0.5.hex (hardware v1.x) app-lorawan-gps-button-4.0.9.hex (hardware v1.x) Info The LoRaWAN GPS data uplink data encoding has been changed between firmware 4.x (\"legacy format\") and 5.x. See the manual for details. Warning This hardware revision is no longer available for sale! Consider using the improved HW Rev 2.x. Changelog v6.0.3 - 02.08.2019 fixed temperature sensor readout v6.0.2 - 22.07.2019 inverted powerpin for telit module (hardware v2.1) added nmea prefix GN ( Glonass+GPS ) to the parser v5.0.5 - 09.01.2019 Update LoRaWAN Stack Enable stepUp if needed by battery condition v5.0.4 - 15.11.2018 update board driver v5.0.3 - 15.11.2018 fix signed issue with longitude v5.0.0 - 26.10.2018 Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack v4.0.9 - 05.10.2018 Update LoRaWAN Stack v4.0.7 - 15.08.2018 Fixed bugs with some LoRaWAN Network providers v4.0.6 - 28.05.2018 Clear pending mems IRQ before sleep Updated internal state handling v4.0.4 - 20.03.2018 Disable mems in active mode v4.0.3 - 20.03.2018 compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm v4.0.2 - 23.02.2018 Fix lost GPS messages due to broken CRC checks v4.0.1 - 29.01.2018 Port to LoRa v3.2 Board v3.2 Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR v3.1 Enable buttons for sending (Reed contact connectors)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#lorawan-gps-tracker","text":"","title":"LoRaWAN GPS Tracker"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#firmware-downloads","text":"","title":"Firmware Downloads"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#hardware-revision-2x","text":"Downloads : app-lorawan-gps-button-6.0.3.hex (hardware v2.x)","title":"Hardware Revision 2.x"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#hardware-revision-1x","text":"Downloads : app-lorawan-gps-button-5.0.5.hex (hardware v1.x) app-lorawan-gps-button-4.0.9.hex (hardware v1.x) Info The LoRaWAN GPS data uplink data encoding has been changed between firmware 4.x (\"legacy format\") and 5.x. See the manual for details. Warning This hardware revision is no longer available for sale! Consider using the improved HW Rev 2.x.","title":"Hardware Revision 1.x"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v603-02082019","text":"fixed temperature sensor readout","title":"v6.0.3 - 02.08.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v602-22072019","text":"inverted powerpin for telit module (hardware v2.1) added nmea prefix GN ( Glonass+GPS ) to the parser","title":"v6.0.2 - 22.07.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v505-09012019","text":"Update LoRaWAN Stack Enable stepUp if needed by battery condition","title":"v5.0.5 - 09.01.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v504-15112018","text":"update board driver","title":"v5.0.4 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v503-15112018","text":"fix signed issue with longitude","title":"v5.0.3 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v500-26102018","text":"Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack","title":"v5.0.0 - 26.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v409-05102018","text":"Update LoRaWAN Stack","title":"v4.0.9 - 05.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v407-15082018","text":"Fixed bugs with some LoRaWAN Network providers","title":"v4.0.7 - 15.08.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v406-28052018","text":"Clear pending mems IRQ before sleep Updated internal state handling","title":"v4.0.6 - 28.05.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v404-20032018","text":"Disable mems in active mode","title":"v4.0.4 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v403-20032018","text":"compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm","title":"v4.0.3 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v402-23022018","text":"Fix lost GPS messages due to broken CRC checks","title":"v4.0.2 - 23.02.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v401-29012018","text":"Port to LoRa v3.2 Board","title":"v4.0.1 - 29.01.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v32","text":"Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR","title":"v3.2"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v31","text":"Enable buttons for sending (Reed contact connectors)","title":"v3.1"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html","text":"Humidity & Temperature LoRaWAN Sensor Overview The Lobaro LoRaWAN Humidity Sensor AM2305-LoRaWAN is a battery powered radio transmitting sensor device that takes measurements at configurable intervals. Because of its low power consumption it can operate for multiple years with standard AA batteries. The LoRa radio technology allows it to take measurements in places that are hard to reach, and in its water prove casing it can be installed outdoors. The device uses a AM2305 digital relative humidity and temperature sensor probe (also known as RHT05 or DHT44). It is powered by the base device and communicates via a one-wire connection. Note Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device. The Device Operating the Humidity Sensor The RHT05 sensor probe must be attached to the device on the external socket. Insert two 1.5V AA batteries into the slots. When the device starts, its LED flashes once. If it does not start, check that your batteries are still good and inserted the correct way. You can refer to the picture above to check that everything is connected as it should be. When the device is set up correctly and running, put the lid on the base and fasten it from the back using the supplied screws. Watch out that the cables are save inside the box and do not get stuck in the casing, or you might damage the cables and allow water to enter the casing. This can cause damage to the device! Always close the lid so that the socket for the probe is on the opposing side of the antenna (picture above, sensor probe on the left, antenna on the right). This way there will be less interference on the antenna and you will get the best connection possible. Batteries The LoRaWAN Humidity Sensor default power supply consists of two series connected off- the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and LithiumIron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request, we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Options with permanent external power supply (230V, 9-24V, 5V USB) are also available on request. Installation The device must be fixed on a flat surface using the lateral mounting holes of the case. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices Warning Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Work Cycle graph LR; init(Init)-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Initial Phase This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered. Data Collection Phase During the Data Collection Phase is the device activates the sensor probe and reads measured humidity and temperature. There will be up to three attempts to get a correct reading. The communication contains a checksum value to detect data corruption between the probe and the main device. After data collection, the probe is deactivated again to save power. The device then enters the Data Transfer Phase. Data Transfer Phase During the Data Transfer Phase the Bridge uploads the sensor values to the LoRaWAN network. The message contains the information if the measurement was successful. In addition to the register data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. Sleep Phase After transferring all data packets the device enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until the cron expression given in the configuration triggers. When that happens, it enters the Data Collection Phase again Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration has been changed! Connecting the USB config adapter For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. System Parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Sensor configuration parameters The only parameter outside of the LoRaWAN-configuration is a Cron expression used to control the frequency of how often the device takes measurements. Name Type Description MeasureCron string Expression defining how often the device executes a measurement. This parameter is set using a cron expression. Please refer to chapter Cron expressions for an introduction. Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00 Configuration and battery life The time the LoRaWAN Humidity Sensor can operate on one set of batteries depends on the configuration of the device. Most of the time, the sensor remains in a sleep state, during which a very small amount of power is consumed (a current of about 20\u03bcA). Most power is used for sending messages via LoRa. One set of batteries lasts for about 30000 messages (depending on details like spreading factor and transmission power), so you can estimate the battery life for your configuration using the formula in equation 1. For example, if the device is set to send hourly updates, it will send 25 messages per day (including the status message). As illustrated in equation 2, the device should have a battery life of slightly over 3 years. LoRaWAN Data Upload Formats After reading from the sensor probe, the device starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the Humidity Sensor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). Since data packets sent over LoRa can be lost, a timestamp is added to every data packet. Timestamps are encoded as signed 40 bit big endian integers and express the number of seconds passed since 00:00:00 January 1 st , 1970 (UNIX timestamp). Timestamps are according to the devices internal clock, which might be set to an incorrect value. The timestamp always indicates the begin of the corresponding measurement phase. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network . Status Packet Port 1 - In order to provide some information about the health of the device itself, the Modbus Bridge sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 14 bytes. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 0, 4 \u2261 v1.0.4 fl uint8 3 Status flags, for internal use 0 temp int16 4-5 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C v_bat uint16 6-7 Battery voltage in mV 3547 \u2261 3.547V timestamp int40 8-12 Internal date/time at creation of the packet 1533055905 mod uint8 13 Operation mode the device runs 1 Data Packet Port 2 - The data packet is used to transmit the measured environmental values. It includes a timestamp and the information if the measurement was successful. The data packet has a fixed length of 10 bytes. Please remember that the timestamp is always in reference to the devices internal clock, which normally does not know the real time it is still usable to put data points into real time context if you take one reference and calculate the offset of the devices clock to real time. Figure 6 explains the bytes in inside the data package, table 4 explains the fields. name type bytes description example timestamp int40 0-4 UNIX timestamp for measurement 1533055905 err uint8 5 Error indicator. 0=success, 1=error 0 \u2261 success humidity uint16 6-7 Rel. humidity 1/10 % 318 \u2261 31.8 % temperature int16 8-9 Temperature in 1/10 \u00b0C -105 \u2261 -10.5 \u00b0C Sensor Specification Technical characteristics Product Type name AM2305-LoRaWAN Description LoRaWAN Humidity Sensor RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Humidity Sensor (Probe) Range 0%rH to 100%rH Accuracy \u00b12%rH (max \u00b15%rH) Resolution 0.1%rH Temperature Sensor (Probe) Range -40\u00b0C to 80\u00b0C Accuracy \u00b10.3\u00b0C Resolution 0.1\u00b0C Mechanical dimensions Size (Box) 114.3 mm x 59.3 mm x 26.8 mm Size (Probe) 100mm x 16mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Temperature and relative humidity measurements with external probe and LoRaWAN. PDF Documentation User Manual (en) CE Conformity Parser The Things Network (JavaScript) /** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"Manual"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#overview","text":"The Lobaro LoRaWAN Humidity Sensor AM2305-LoRaWAN is a battery powered radio transmitting sensor device that takes measurements at configurable intervals. Because of its low power consumption it can operate for multiple years with standard AA batteries. The LoRa radio technology allows it to take measurements in places that are hard to reach, and in its water prove casing it can be installed outdoors. The device uses a AM2305 digital relative humidity and temperature sensor probe (also known as RHT05 or DHT44). It is powered by the base device and communicates via a one-wire connection. Note Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro my cause damage to people, the environment, or the device.","title":"Overview"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-device","text":"","title":"The Device"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#operating-the-humidity-sensor","text":"The RHT05 sensor probe must be attached to the device on the external socket. Insert two 1.5V AA batteries into the slots. When the device starts, its LED flashes once. If it does not start, check that your batteries are still good and inserted the correct way. You can refer to the picture above to check that everything is connected as it should be. When the device is set up correctly and running, put the lid on the base and fasten it from the back using the supplied screws. Watch out that the cables are save inside the box and do not get stuck in the casing, or you might damage the cables and allow water to enter the casing. This can cause damage to the device! Always close the lid so that the socket for the probe is on the opposing side of the antenna (picture above, sensor probe on the left, antenna on the right). This way there will be less interference on the antenna and you will get the best connection possible.","title":"Operating the Humidity Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#batteries","text":"The LoRaWAN Humidity Sensor default power supply consists of two series connected off- the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and LithiumIron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Warning Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request, we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Options with permanent external power supply (230V, 9-24V, 5V USB) are also available on request.","title":"Batteries"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#installation","text":"The device must be fixed on a flat surface using the lateral mounting holes of the case. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices Warning Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic standoffs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Installation"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#work-cycle","text":"graph LR; init(Init)-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read;","title":"Work Cycle"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The LED flashes once and the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-join-phase","text":"If the Device is configured to use over the air activation (OTAA), the OTAA Join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Device is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-collection-phase","text":"During the Data Collection Phase is the device activates the sensor probe and reads measured humidity and temperature. There will be up to three attempts to get a correct reading. The communication contains a checksum value to detect data corruption between the probe and the main device. After data collection, the probe is deactivated again to save power. The device then enters the Data Transfer Phase.","title":"Data Collection Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Bridge uploads the sensor values to the LoRaWAN network. The message contains the information if the measurement was successful. In addition to the register data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets.","title":"Data Transfer Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sleep-phase","text":"After transferring all data packets the device enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until the cron expression given in the configuration triggers. When that happens, it enters the Data Collection Phase again","title":"Sleep Phase"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 . Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Info Please note that the device might be restarted each time the configuration has been changed!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#connecting-the-usb-config-adapter","text":"For configuration and Firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture underneath. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System Parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN Parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sensor-configuration-parameters","text":"The only parameter outside of the LoRaWAN-configuration is a Cron expression used to control the frequency of how often the device takes measurements. Name Type Description MeasureCron string Expression defining how often the device executes a measurement. This parameter is set using a cron expression. Please refer to chapter Cron expressions for an introduction.","title":"Sensor configuration parameters"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Info Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the initial time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 **** hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#configuration-and-battery-life","text":"The time the LoRaWAN Humidity Sensor can operate on one set of batteries depends on the configuration of the device. Most of the time, the sensor remains in a sleep state, during which a very small amount of power is consumed (a current of about 20\u03bcA). Most power is used for sending messages via LoRa. One set of batteries lasts for about 30000 messages (depending on details like spreading factor and transmission power), so you can estimate the battery life for your configuration using the formula in equation 1. For example, if the device is set to send hourly updates, it will send 25 messages per day (including the status message). As illustrated in equation 2, the device should have a battery life of slightly over 3 years.","title":"Configuration and battery life"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#lorawan-data-upload-formats","text":"After reading from the sensor probe, the device starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the Humidity Sensor. Multi byte integers are transmitted as big endian. Values that would require decimal places are transmitted in smaller units (e.g. mV instead of V). Since data packets sent over LoRa can be lost, a timestamp is added to every data packet. Timestamps are encoded as signed 40 bit big endian integers and express the number of seconds passed since 00:00:00 January 1 st , 1970 (UNIX timestamp). Timestamps are according to the devices internal clock, which might be set to an incorrect value. The timestamp always indicates the begin of the corresponding measurement phase. We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network .","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#status-packet","text":"Port 1 - In order to provide some information about the health of the device itself, the Modbus Bridge sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 14 bytes. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 0, 4 \u2261 v1.0.4 fl uint8 3 Status flags, for internal use 0 temp int16 4-5 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C v_bat uint16 6-7 Battery voltage in mV 3547 \u2261 3.547V timestamp int40 8-12 Internal date/time at creation of the packet 1533055905 mod uint8 13 Operation mode the device runs 1","title":"Status Packet"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#data-packet","text":"Port 2 - The data packet is used to transmit the measured environmental values. It includes a timestamp and the information if the measurement was successful. The data packet has a fixed length of 10 bytes. Please remember that the timestamp is always in reference to the devices internal clock, which normally does not know the real time it is still usable to put data points into real time context if you take one reference and calculate the offset of the devices clock to real time. Figure 6 explains the bytes in inside the data package, table 4 explains the fields. name type bytes description example timestamp int40 0-4 UNIX timestamp for measurement 1533055905 err uint8 5 Error indicator. 0=success, 1=error 0 \u2261 success humidity uint16 6-7 Rel. humidity 1/10 % 318 \u2261 31.8 % temperature int16 8-9 Temperature in 1/10 \u00b0C -105 \u2261 -10.5 \u00b0C","title":"Data Packet"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sensor-specification","text":"","title":"Sensor Specification"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#technical-characteristics","text":"Product Type name AM2305-LoRaWAN Description LoRaWAN Humidity Sensor RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Power Power supply 2xAA sized battery, 1.5 V, LR6/FR6 Supply voltage UNom = 3.0V, UMin = 2.2V, UMax = 3.7V Capacity \u223c 30000 LoRaWAN messages @SF11 Humidity Sensor (Probe) Range 0%rH to 100%rH Accuracy \u00b12%rH (max \u00b15%rH) Resolution 0.1%rH Temperature Sensor (Probe) Range -40\u00b0C to 80\u00b0C Accuracy \u00b10.3\u00b0C Resolution 0.1\u00b0C Mechanical dimensions Size (Box) 114.3 mm x 59.3 mm x 26.8 mm Size (Probe) 100mm x 16mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Consider using the latest firmware on your hardware See available firmware downloads","title":"Technical characteristics"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#target-measurement-purpose","text":"Temperature and relative humidity measurements with external probe and LoRaWAN.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#pdf-documentation","text":"User Manual (en) CE Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-things-network-javascript","text":"/** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"The Things Network (JavaScript)"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html","text":"Humidity & Temperature LoRaWAN Sensor Firmware Downloads: app-lorawan-humidity-0.0.3.hex Changelog 0.0.3 Initial public release","title":"Firmware & Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-humidity-0.0.3.hex","title":"Firmware"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#003","text":"Initial public release","title":"0.0.3"},{"location":"lorawan-sensors/modbus-lorawan/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v0.3.0 This is the latest version. For older revisions please refer to the version overview . Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. PDF Download Data Sheet with dimensions Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD Operation Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes See also our Introduction to Cron expressions . Register/Coil definition Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration. Example register definition strings definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5. Payload formats The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ). Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1 Data messages The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined. Structure of a data pack name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document. Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Manual"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v0.3.0 This is the latest version. For older revisions please refer to the version overview . Consider using the latest firmware on your hardware See available firmware downloads","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. PDF Download Data Sheet with dimensions","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN Parameters"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes See also our Introduction to Cron expressions .","title":"Operation"},{"location":"lorawan-sensors/modbus-lorawan/index.html#registercoil-definition","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration.","title":"Register/Coil definition"},{"location":"lorawan-sensors/modbus-lorawan/index.html#example-register-definition-strings","text":"definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5.","title":"Example register definition strings"},{"location":"lorawan-sensors/modbus-lorawan/index.html#payload-formats","text":"The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ).","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#data-messages","text":"The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined.","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#structure-of-a-data-pack","text":"name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document.","title":"Structure of a data pack"},{"location":"lorawan-sensors/modbus-lorawan/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html","text":"Modbus LoRaWAN Bridge Firmware Downloads: app-modbus-lora-bridge-0.3.1.hex . Changelog [Unreleased] Added Remote configuration via LoRaWAN. Clock synchronisation via LoRaWAN. Changed Random delay before Uplink (to prevent persistent collisions when using multiple devices). [0.4.1] Fixed Changed error indication bit on error 11 from 0xf0 to 0x80 . Fixed issue when parsing multiple Modbus commands from config. [0.4.0] Added Writing values to holding registers and coils. Execution of arbitrary Modbus commands triggered by LoRaWAN Downlink messages. Support for LoRaWAN Operation Mode Class C (for short reaction time to Downlinks). Automated register writing and broadcasts possible through new configuration. Changed Automated reading (triggered by cron) is now configured by entering actual Modbus commands (more flexibility and usage of already existing Modbus syntax \u2013 this breaks old configurations ). Upload format changed to sending raw response to Modbus commands ( this breaks existing integrations ). Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again. [0.3.1] \u2013 2019-05-24 Fixed Increased robustness of data reception on higher Baud rates. [0.3.0] \u2013 2019-05-15 Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Changed Parity bit must not be substracted from Data bits anymore. 8E1 can now be confiured with 8 Data bits, EVEN parity, 1 Stop bit . [0.1.0] \u2013 2018-08-13 Added Original hardware release (with RS-485 on holding PCB).","title":"Firmware & Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#modbus-lorawan-bridge","text":"","title":"Modbus LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#firmware","text":"Downloads: app-modbus-lora-bridge-0.3.1.hex .","title":"Firmware"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#unreleased","text":"Added Remote configuration via LoRaWAN. Clock synchronisation via LoRaWAN. Changed Random delay before Uplink (to prevent persistent collisions when using multiple devices).","title":"[Unreleased]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#041","text":"Fixed Changed error indication bit on error 11 from 0xf0 to 0x80 . Fixed issue when parsing multiple Modbus commands from config.","title":"[0.4.1]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#040","text":"Added Writing values to holding registers and coils. Execution of arbitrary Modbus commands triggered by LoRaWAN Downlink messages. Support for LoRaWAN Operation Mode Class C (for short reaction time to Downlinks). Automated register writing and broadcasts possible through new configuration. Changed Automated reading (triggered by cron) is now configured by entering actual Modbus commands (more flexibility and usage of already existing Modbus syntax \u2013 this breaks old configurations ). Upload format changed to sending raw response to Modbus commands ( this breaks existing integrations ). Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again.","title":"[0.4.0]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#031-2019-05-24","text":"Fixed Increased robustness of data reception on higher Baud rates.","title":"[0.3.1] &ndash; 2019-05-24"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#030-2019-05-15","text":"Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Changed Parity bit must not be substracted from Data bits anymore. 8E1 can now be confiured with 8 Data bits, EVEN parity, 1 Stop bit .","title":"[0.3.0] &ndash; 2019-05-15"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#010-2018-08-13","text":"Added Original hardware release (with RS-485 on holding PCB).","title":"[0.1.0] &ndash; 2018-08-13"},{"location":"lorawan-sensors/modbus-lorawan/redirect-example.html","text":"latest version","title":"Redirect example"},{"location":"lorawan-sensors/modbus-lorawan/versions.html","text":"Versions of the Modbus LoRaWAN Bridge Our devices are developed further and improved continuously. This sometimes breaks backwards compatibility or leads to huge changes in the documentation. On order to provide documentation for existing older devices we provide the manuals for older versions. If you are looking for the manual for an older revision, choose the manual with the highest version number lower than the version number of your installed firmware. You can find out what firmware is installed on your hardware with our configuration adapter and configuration tool. The firmware version is printed in the log on device startup. For an overview over the changes between manual releases, please refer to the changelog . [0.4.x] (since 2019-07-29 \u2013 unreleased version) [0.3.x] (since 2019-05-15 \u2013 current version) [0.1.x] (since 2018-08-13 \u2013 pdf)","title":"Versions"},{"location":"lorawan-sensors/modbus-lorawan/versions.html#versions-of-the-modbus-lorawan-bridge","text":"Our devices are developed further and improved continuously. This sometimes breaks backwards compatibility or leads to huge changes in the documentation. On order to provide documentation for existing older devices we provide the manuals for older versions. If you are looking for the manual for an older revision, choose the manual with the highest version number lower than the version number of your installed firmware. You can find out what firmware is installed on your hardware with our configuration adapter and configuration tool. The firmware version is printed in the log on device startup. For an overview over the changes between manual releases, please refer to the changelog . [0.4.x] (since 2019-07-29 \u2013 unreleased version) [0.3.x] (since 2019-05-15 \u2013 current version) [0.1.x] (since 2018-08-13 \u2013 pdf)","title":"Versions of the Modbus LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v0.4.1 (since 2019-07-27) This the manual for an unreleased version of the firmware. For older revisions please refer to the version overview . Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via Uplink. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation. PDF Download Data Sheet with dimensions Modbus Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus . Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't OpMode both char LoRaWAN operation mode, A \u2261 Class A, C \u2261 Class C Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLength UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD ModbusCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes ModbusCommands List of Modbus Commands (see below). 010300010003 \u2020 See also our Introduction to Cron expressions . Modbus Commands Whenever the cron expression given in the configuration value ModbusCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter ModbusCommands ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set ModbusCommands to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 50 byte message limit this only leaves 38 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be dropped! To make sure your data can be uploaded on high spreading factors, do not read out more than 19 consecutive 16 bit registers in a single command. For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at examples . Payload formats The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document. Uplink Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C Data messages Data messages contain responses to Modbus Commands received by the Bridge. They are sent as Uplinks on two different ports, depending on how the command was triggered. The format of the messages is identical for both cases. Data messages on port 3 contain responses to the commands set in the configuration parameter ModbusCommands that are executed automatically every time the cron expression in ModbusCron activates. Data messages on port 4 contain responses to Modbus Commands that have been sent to the Bridge as Downlinks via LoRaWAN. Every Data message starts with 5 bytes containing an int40 timestamp. This is followed by zero or more Modbus Responses. Each Modbus Response is prefixed with a single byte indicating the length of the Response (as uint8 ). The timestamp indicates when the command that triggered the Responses were executed. For Messages on port 3 this is the time at which the Bridge was activated by the cron expression. For Messages on port 4 this is the time at which the received Downlink was executed. Please note our information on timestamps in our LoRaWAN devices . The Bridge tries to put as many Responses into a single message as possible, so depending on the current spreading factor, the number of Responses per message may vary. For a short introduction to Modbus Commands and Responses and some examples of configuration and payload refer to Examples . Downlink Modbus Commands Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length. The Responses to the Commands are sent as Uplink messages on port 4. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, create an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly, without the Bridge, to reduce possible error sources. Refer to Examples to see some Downlinks and their answers. Examples This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus . Uplinks triggered by configuration The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 ModbusCommands = '010300000003' # Example resulting Uplink after successful readout Up , Port 3 : '005d1698fd0c0103000000031234567890ab' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '0c' -> first Response is 12 bytes long '0103000000031234567890ab' 12 bytes modbus response : '01' -> slave device with address 1 '03' -> function 3 = read Holding Register , success '0000' -> start reading at register 0 '0003' -> read 3 consecutive registers '1234567890ab' -> 6 bytes of data # Example resulting Uplink after failing readout Up , Port 3 : '005d1698fd0301830b' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '03' -> first Response is 3 bytes long '01830b' 3 bytes modbus response : '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register , failed '0b' -> error code 11 : \"Gateway Target Device Failed to Respond\" Example A2: Read coils 1000-1019 of device 32 ModbusCommands = '200103e80014' # Example resulting Uplink Up , Port 3 : '005d1698fd09200103e80014f1041a' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '09' -> first Response is 9 bytes long '200103e80014f1041a' 9 bytes of modbus response : '20' -> slave device with address 32 '01' -> read coils , success '03e8' -> start reading at coil 1000 '0014' -> read 20 consecutive coils 'f1041a' -> 20 bits of data packed into 3 bytes Example A3: Read two devices ModbusCommands = '0a0300010005,3001ea600020' # Example resulting Uplink Up , Port 3 : '005d1698fd100a0300010005111122223333444455550a3001ea60002012345678' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '10' -> first Response is 16 bytes long '0a030001000511112222333344445555' 16 bytes of Modbus Response '0a' -> slave device with address 10 '03' -> read Holding Registers , success '0001' -> start reading at register 1 '0005' -> read 5 registers '11112222333344445555' 10 bytes of data '0a' -> second Response is 10 bytes long '30' -> slave device with address 48 '01' -> read Coils , success 'ea60' -> start at coil 60000 '0020' -> read 32 coils '12345678' -> 32 bits of data packed in 4 bytes Uplinks triggered by Downlinks Example B1: Read single Input Register by Downlink Down , Port 4 : '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4 , read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up , Port4 : '004b3dd67508180401000001abcd' '004b3dd675' -> timestamp = 1262343797 -> 2010 - 01 - 01 T11 : 03 : 17 UTC '08' -> first Response is 8 bytes long '180401000001abcd' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register , success '0100' -> start at register 256 '0001' -> read 1 register 'abcd' -> 2 bytes of data Example B2: Writing holding registers on multiple devices Down , Port 4 : '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6 , write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16 , write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up , Port 4 : '004b3dd67503a1860206a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010 - 01 - 01 T11 : 03 : 17 UTC '03' -> first Response is 3 bytes long 'a18602' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter , failed '02' -> error code 2 : \"Illegal Data Address\" '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> read multiple Holding Registers , success 'a001' -> start at register 40961 '0004' -> 4 registers to write Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } // TODO: Copyright Modbus Logo","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v0.4.1 (since 2019-07-27) This the manual for an unreleased version of the firmware. For older revisions please refer to the version overview .","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to communicate with Modbus Slave devices (ASCII/RTU) on a RS-485 bus over a LoRaWAN network. Modbus commands can be transmitted via Downlink message to the Bridge and are forwarded by the Bridge to the connected Slave Devices. Received responses are forwarded via LoRaWAN Uplink messages. The Modbus Bridge can also be configured to execute Modbus commands regularly and report the responses via Uplink. The Bridge supports LoRaWAN Operation Mode Class A for power efficient operation (for long operation periods powered by battery), as well as Class C to enable short reaction time to Downlink requests. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. It also supports writing values to both writable objects: Coils and Holding Registers. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. Typical applications for Modbus devices include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Industrial machines as well as solar panel installations often include a Modbus connection to supply supervision and automated operation. PDF Download Data Sheet with dimensions","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. Of those four, Coils and Holding Registers can also be written to. Coils and Discrete Inputs hold single bit values while Input Registers and Holding Registers hold 16 bit values. For values that cannot fit into 16 bit, it is customary to use multiple consecutive registers to hold the value. Modbus does not define what the bytes in the registers represent; it is up to the creator of the Modbus Slave Device to specify how to interpret the stored bits. A 16 bit register could be used to hold a single byte value, for example, or four consecutive registers could hold a double precision floating point number. Storing texts as ASCII characters is also possible. For integer numbers in particular it there is no defined byte order, nor signage definition. Because of those ambiguities it is not possible for the Lobaro LoRaWAN Bridge to understand the data read from/written to Slave Devices. All communications therefore simply forward raw Modbus Commands and Responses with their payload, as it communicated on the Bus. Any check sums (CRC16 for RTU, LRC for ASCII) are excluded from LoRaWAN communications or the Bridge's configuration, as there are other check sums in work their already. For a deeper introduction into Modbus please refer to https://en.wikipedia.org/wiki/Modbus .","title":"Modbus"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't OpMode both char LoRaWAN operation mode, A \u2261 Class A, C \u2261 Class C","title":"LoRaWAN"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLength UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD ModbusCron Cron expression \u2020 defining when to read. 0 0/15 * * * * for every 15 minutes ModbusCommands List of Modbus Commands (see below). 010300010003 \u2020 See also our Introduction to Cron expressions .","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-commands","text":"Whenever the cron expression given in the configuration value ModbusCron activates, the Modbus Bridge wakes up from hibernation (or listening mode, for Class C), a set of configured Modbus Commands (set in the configuration parameter ModbusCommands ) is executed over the RS-485 bus. Any responses received from the addressed Slave Device will be uploaded via LoRaWAN. The Modbus Commands to be executed must be entered in the config as hexencoded bytes, exactly the way they are to be sent over the bus. Checksums must not be included in the configuration. Multiple commands can be added to the configuration, separated by commas (no spaces). For example if you want the Bridge to read the Holding Registers 100, 101, and 102 on two separated Slave Devices with the addresses 9 and 10, you would need to set ModbusCommands to 090300640003,0a0300640003 . You can configure any byte sequence you want to be sent; not all will be valid Modbus Commands. This feature has been developed to execute register/coil reads and upload the values retrieved. It is possible to use it for writing values as well, but the usefulness of that is limited. If you configure register writes, be aware that the commands are also executed when the device boots! Keep in mind that the responses to your commands will be sent using LoRaWAN, which has only a very limited packet size! Modbus responses can be over 200 bytes long. For reading commands, the Modbus Response contains 6 bytes to repeat the command. The data format used by the Modbus Bridge adds another 6 bytes. On higher spreading factors with 50 byte message limit this only leaves 38 bytes for the actual read data (in EU LoRaWAN configuration, other areas might have a slightly different number). Responses that will not fit into a single LoRaWAN Uplink will be dropped! To make sure your data can be uploaded on high spreading factors, do not read out more than 19 consecutive 16 bit registers in a single command. For a short introduction into Modbus Commands and some examples of configurations and their created responses, please take a look at examples .","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#payload-formats","text":"The Modbus Bridge sends two different kinds of messages over three different LoRaWAN ports: Direction Port Message Uplink 1 Status messages. Uplink 3 Modbus Responses triggered by configuration. Uplink 4 Modbus Responses triggered by Downlinks. Downlink 4 Modbus Commands to be forwarded by the Bridge. In addition to the description we also supply a reference decoder usable in TTN at the end of this document.","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplink","text":"","title":"Uplink"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [0, 4, 1] \u2261 v0.4.1 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 opMode 13 1 char LoRaWAN Operation mode the device runs A or C","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#data-messages","text":"Data messages contain responses to Modbus Commands received by the Bridge. They are sent as Uplinks on two different ports, depending on how the command was triggered. The format of the messages is identical for both cases. Data messages on port 3 contain responses to the commands set in the configuration parameter ModbusCommands that are executed automatically every time the cron expression in ModbusCron activates. Data messages on port 4 contain responses to Modbus Commands that have been sent to the Bridge as Downlinks via LoRaWAN. Every Data message starts with 5 bytes containing an int40 timestamp. This is followed by zero or more Modbus Responses. Each Modbus Response is prefixed with a single byte indicating the length of the Response (as uint8 ). The timestamp indicates when the command that triggered the Responses were executed. For Messages on port 3 this is the time at which the Bridge was activated by the cron expression. For Messages on port 4 this is the time at which the received Downlink was executed. Please note our information on timestamps in our LoRaWAN devices . The Bridge tries to put as many Responses into a single message as possible, so depending on the current spreading factor, the number of Responses per message may vary. For a short introduction to Modbus Commands and Responses and some examples of configuration and payload refer to Examples .","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#downlink","text":"","title":"Downlink"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#modbus-commands_1","text":"Downlinks on port 4 contain one or more Modbus Commands that the Bridge should forward to the RS-485 bus. Every Command must be prefixed by a single byte defining the Command's length. The Responses to the Commands are sent as Uplink messages on port 4. Any byte sequence can transmitted this way and will be forwarded to the bus. If the Bridge does not receive a Response by the addressed Slave Device, create an error Response with the exception code 11 \"Gateway Target Device Failed to Respond\". This only makes sense if the Downlink did contain a Modbus Command. Please be advised that not all Modbus Slave devices send Responses in all cases. If you receive the exception code 11 it is possible that the Slave device was reached but was not addressed correctly. It might even be possible, that a Command was executed successfully, but that the device does not send confirmations. When in doubt, refer to the documentation of your connected devices or try communicating with it directly, without the Bridge, to reduce possible error sources. Refer to Examples to see some Downlinks and their answers.","title":"Modbus Commands"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#examples","text":"This chapter illustrates with some examples, how working with the Modbus Bridge looks like. The bytes that are sent via LoRaWAN are presented here as hex strings. Modbus Commands and Responses are broken down to their parts in the explanations, but explaining the format used by Modbus in detail is beyond the scope of this manual. You can find a short explanation on Modbus on Wikipedia: https://en.wikipedia.org/wiki/Modbus .","title":"Examples"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplinks-triggered-by-configuration","text":"The following shows some examples of configuration for the automated reading and what the generated Uplinks for that could look like. Example A1: Read Holding Registers 0, 1, and 2 of device with address 1 ModbusCommands = '010300000003' # Example resulting Uplink after successful readout Up , Port 3 : '005d1698fd0c0103000000031234567890ab' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '0c' -> first Response is 12 bytes long '0103000000031234567890ab' 12 bytes modbus response : '01' -> slave device with address 1 '03' -> function 3 = read Holding Register , success '0000' -> start reading at register 0 '0003' -> read 3 consecutive registers '1234567890ab' -> 6 bytes of data # Example resulting Uplink after failing readout Up , Port 3 : '005d1698fd0301830b' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '03' -> first Response is 3 bytes long '01830b' 3 bytes modbus response : '01' -> slave device with address 1 '83' -> function 3 with error indicator 80 = read Holding Register , failed '0b' -> error code 11 : \"Gateway Target Device Failed to Respond\" Example A2: Read coils 1000-1019 of device 32 ModbusCommands = '200103e80014' # Example resulting Uplink Up , Port 3 : '005d1698fd09200103e80014f1041a' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '09' -> first Response is 9 bytes long '200103e80014f1041a' 9 bytes of modbus response : '20' -> slave device with address 32 '01' -> read coils , success '03e8' -> start reading at coil 1000 '0014' -> read 20 consecutive coils 'f1041a' -> 20 bits of data packed into 3 bytes Example A3: Read two devices ModbusCommands = '0a0300010005,3001ea600020' # Example resulting Uplink Up , Port 3 : '005d1698fd100a0300010005111122223333444455550a3001ea60002012345678' '005d1698fd' -> timestamp = 1561762045 -> 2019 - 06 - 28 T22 : 47 : 25 UTC '10' -> first Response is 16 bytes long '0a030001000511112222333344445555' 16 bytes of Modbus Response '0a' -> slave device with address 10 '03' -> read Holding Registers , success '0001' -> start reading at register 1 '0005' -> read 5 registers '11112222333344445555' 10 bytes of data '0a' -> second Response is 10 bytes long '30' -> slave device with address 48 '01' -> read Coils , success 'ea60' -> start at coil 60000 '0020' -> read 32 coils '12345678' -> 32 bits of data packed in 4 bytes","title":"Uplinks triggered by configuration"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#uplinks-triggered-by-downlinks","text":"Example B1: Read single Input Register by Downlink Down , Port 4 : '06180401000001' '06' -> first Command is 6 bytes long '180401000001' 6 bytes of Modbus Command '18' -> slave device with address 24 '04' -> function 4 , read Input Register '0100' -> start at register 256 '0001' -> read 1 register # Example resulting Uplink Up , Port4 : '004b3dd67508180401000001abcd' '004b3dd675' -> timestamp = 1262343797 -> 2010 - 01 - 01 T11 : 03 : 17 UTC '08' -> first Response is 8 bytes long '180401000001abcd' 8 bytes of Response '18' -> slave device with address 24 '04' -> read Input Register , success '0100' -> start at register 256 '0001' -> read 1 register 'abcd' -> 2 bytes of data Example B2: Writing holding registers on multiple devices Down , Port 4 : '06a106aabb12340fa210a0010004081122334455667788' '06' -> first Command is 6 bytes long 'a106aabb1234' 6 bytes of Modbus Command 'a1' -> slave device with address 161 '06' -> function 6 , write single Holding Register 'aabb' -> address of Register to write = 43707 '1234' -> two bytes of data '0f' -> second Command is 15 byts long 'a210a0010004081122334455667788' 15 byte of Modbus Command 'a2' -> slave device with address 162 '10' -> function 16 , write multiple Holding Registers 'a001' -> start at register 40961 '0004' -> 4 registers to write '08' -> 8 bytes of data follow '1122334455667788' -> 8 bytes of data # Example resulting Uplink Up , Port 4 : '004b3dd67503a1860206a210a0010004' '004b3dd675' -> timestamp = 1262343797 -> 2010 - 01 - 01 T11 : 03 : 17 UTC '03' -> first Response is 3 bytes long 'a18602' 3 bytes of Modbus Response 'a1' -> slave device address 161 '86' -> write single Holding Regsiter , failed '02' -> error code 2 : \"Illegal Data Address\" '06' - second Response is 6 byts long 'a210a0010004' 6 bytes od Modbus Response 'a2' -> slave device address 162 '10' -> read multiple Holding Registers , success 'a001' -> start at register 40961 '0004' -> 4 registers to write","title":"Uplinks triggered by Downlinks"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A / Class C LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/0.4.0/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } // TODO: Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/pressure-lorawan/index.html","text":"Pressure Sensor LoRaWAN Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Precise liquid level measurement, e.g. for tanks, via LoRaWAN. Features Cable length 1-15m 0..1,5 Bar (15m water level) Waterproof IP66 Housing Multi-year Battery life, ultra low power (< 10\u00b5A) Payload Format Port: 1 Payload: 8 Bytes Temperature is transmitted in 1/100\u00b0C, battery voltage in Millivolt and pressure in Bar. PRESSURE PRESSURE PRESSURE PRESSURE TEMP TEMP V_BATT V_BATT flaot32 float32 float32 float32 int16 int16 int16 int16 Byte 0 Byte 1 Byte 2 Byte 3 LSB MSB LSB MSB Parser: The Things Network function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , v_batt : decodeInt16 ( int16_LE ( bytes , 6 )) / 1000 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Manual"},{"location":"lorawan-sensors/pressure-lorawan/index.html#pressure-sensor-lorawan","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/index.html#target-measurement-purpose","text":"Precise liquid level measurement, e.g. for tanks, via LoRaWAN. Features Cable length 1-15m 0..1,5 Bar (15m water level) Waterproof IP66 Housing Multi-year Battery life, ultra low power (< 10\u00b5A)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/pressure-lorawan/index.html#payload-format","text":"Port: 1 Payload: 8 Bytes Temperature is transmitted in 1/100\u00b0C, battery voltage in Millivolt and pressure in Bar. PRESSURE PRESSURE PRESSURE PRESSURE TEMP TEMP V_BATT V_BATT flaot32 float32 float32 float32 int16 int16 int16 int16 Byte 0 Byte 1 Byte 2 Byte 3 LSB MSB LSB MSB","title":"Payload Format"},{"location":"lorawan-sensors/pressure-lorawan/index.html#parser-the-things-network","text":"function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , v_batt : decodeInt16 ( int16_LE ( bytes , 6 )) / 1000 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Parser: The Things Network"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html","text":"Pressure Sensor LoRaWAN Firmware Downloads : app-keller-pressure-0.2.0.hex app-keller-pressure-0.0.3.hex Changelog v0.2.0 (22.07.2019) Added Battery Voltage to payload v0.0.3 (14.02.2019) Reduce I2C speed from 10kHz to 1kHz for 10m cable v0.0.2 Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz v0.0.1 inital version","title":"Firmware & Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#pressure-sensor-lorawan","text":"","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#firmware","text":"Downloads : app-keller-pressure-0.2.0.hex app-keller-pressure-0.0.3.hex","title":"Firmware"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v020-22072019","text":"Added Battery Voltage to payload","title":"v0.2.0 (22.07.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v003-14022019","text":"Reduce I2C speed from 10kHz to 1kHz for 10m cable","title":"v0.0.3 (14.02.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v002","text":"Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz","title":"v0.0.2"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v001","text":"inital version","title":"v0.0.1"},{"location":"lorawan-sensors/usonic-lorawan/index.html","text":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\") Consider using the latest firmware on your hardware See available firmware downloads Target Measurement / Purpose Distance measurements via ultrasound. Features 30cm to 3m detection range up to 8 detected objects Technical description The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match. Open Top vs. Closed Top As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts. Configuration LoRaWAN Parameters The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Ultrasonic Parameters Parameters specific to the sensor. name type description ReadDistCron String Cron to start the Distrance readout, blank=DISABLE (See: CRON Expressions ) UsonicPreset Int Preset for Ultrasonic UsonicTest Bool Enables Test-Mode, Measurement is executed and logged permanently LogDump Bool Also log the Raw Data Dump of the Ultrasonic sensor Parser The Things Network (TTN) This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold. Encoder Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; }","title":"Manual"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ultrasonic-lorawan-sensor-aka-oscar","text":"Consider using the latest firmware on your hardware See available firmware downloads","title":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\")"},{"location":"lorawan-sensors/usonic-lorawan/index.html#target-measurement-purpose","text":"Distance measurements via ultrasound. Features 30cm to 3m detection range up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/usonic-lorawan/index.html#technical-description","text":"The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match.","title":"Technical description"},{"location":"lorawan-sensors/usonic-lorawan/index.html#open-top-vs-closed-top","text":"As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts.","title":"Open Top vs. Closed Top"},{"location":"lorawan-sensors/usonic-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/usonic-lorawan/index.html#lorawan-parameters","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN Parameters"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ultrasonic-parameters","text":"Parameters specific to the sensor. name type description ReadDistCron String Cron to start the Distrance readout, blank=DISABLE (See: CRON Expressions ) UsonicPreset Int Preset for Ultrasonic UsonicTest Bool Enables Test-Mode, Measurement is executed and logged permanently LogDump Bool Also log the Raw Data Dump of the Ultrasonic sensor","title":"Ultrasonic Parameters"},{"location":"lorawan-sensors/usonic-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/usonic-lorawan/index.html#the-things-network-ttn","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold.","title":"The Things Network (TTN)"},{"location":"lorawan-sensors/usonic-lorawan/index.html#encoder","text":"Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; }","title":"Encoder"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html","text":"USonic LoRaWAN Firmware Downloads: app-lorawan-usonic-0.1.1.hex Changelog Firmware: app-lorawan-usonic v0.1.1 Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"Firmware & Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#usonic-lorawan","text":"","title":"USonic LoRaWAN"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-usonic-0.1.1.hex","title":"Firmware"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#changelog","text":"Firmware: app-lorawan-usonic","title":"Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#v011","text":"Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"v0.1.1"},{"location":"lorawan-sensors/wmbus-lorawan/index.html","text":"Wireless mBUS over LoRaWAN Bridge Overview The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energye efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 consumption meters via any LoRaWAN network onto the Internet. Many gas, water, electricity and heat meters can be read wirelessly today using the common short range Wireless M-Bus standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is often limited to less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is such a key technology. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. This often results in much lower operational costs with the Lobaro wMBUS bridge compared to conventional remote meter reading via LTE networks. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Initial configuration, firmware updates & status readouts are done user-friendly via USB on the PC with the Lobaro Tool (Windows, Linux, Mac). An additional possibility of configuration in the field \"over the air\" by means of LoRaWAN downlinks will soon also be available via firmware update. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro may cause damage to people, the environment, or the device. Consider using the latest firmware on your hardware See available firmware downloads The Device Example without Power Addon Example with Power Addon Device installation The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic stando\u001bs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection. Power Supply The wMBUS over LoRaWAN Bridge default power supply consists of two series connected off-the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium- Iron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB). Battery life time The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to info@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity. Example calculation In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. This behavior is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"wMBUS bridge parameters\"). This will ensure that all meters of interest sent their consumption telegrams at least onces during the configured listen period of the bridge. For a worst-case battery-lifetime calculation the weakest possible LoRaWAN connectivity has been selected. That means to reach a LoRaWAN Gateway the Lobaro hardware has to send out its Uplink data very slowly (\u2265 2 seconds) and redundant by using a LoRa spreading factor of 12. Beside this the actual usable battery capacity has been set to 80% of the nominal value. The resulting worst-case minimal battery-life times are presented below. Battery life for daily LoRaWAN uploads with SF12 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 10.7 32.0 5 7.0 21.1 10 4.9 14.8 20 3.1 9.3 40 1.8 5.3 80 1.0 2.9 Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 are presented below. In real world installations the possible spreading factor may be optimized anytime by setting up additional LoRaWAN Gateways near the meters of interest. Battery life for daily LoRaWAN uploads with SF7 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 12.1 36.4 5 11.8 35.4 10 11.4 34.4 20 10.6 31.9 40 9.4 28.3 80 7.7 23.0 Usage scenario recommendations As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transfered by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT) or classical 4G/LTE. Contact us if you need such a alternative solution by sending your request to info@lobaro.com - either English or German is fine. Work Cycle graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases. Initial Phase This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next. LoRaWAN Join Phase If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration. Data Collection Phase During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered. Data Transfer Phase During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\". Sleep Phase After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again. Configuration The Lobaro Maintenance Tool The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 (picture above). Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Please note that the device is automatically restarted each time the configuration has been changed! Connecting the USB config adapter For configuration and firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture below. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART Bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply. System parameters After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following. LoRaWAN network parameters A large part of the configuration parameters are used to control the device's usage of LoRaWAN. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The LoRaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR) wMBUS bridge parameters Name Type Description loraMaxMsgSize int Received wireless M-Bus telegrams might have a byte size bigger than a single LoRaWAN message can hold. This parameter defines the bytes per LoRaWAN message before a partition over multiple LoRaWAN Uplink msg appears. (Range 10-50 bytes) resetHours int Hours after which the firmware will reset and rejoin the network. Can support the change of LoRaWAN network providers with already deployed devices. (0 = never) cmodeCron string Cron Expression defining when the device starts wMBUS T1/C1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no T1/C1 receive) cmodeDurSec int Duration in seconds for each C1/T1-mode wMBUS receive phase, if cmodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. smodeCron string Cron Expression defining when the device starts wMBUS S1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no S1 receive) smodeDurSec int Duration in seconds for each S1-mode wMBUS receive phase, if smodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. devFilter string wMBUS device id white-list filter using 8 digits with leading zeros list separated by ','. Example '88009035,06198833'. (blank = filter inactive) mFilter string wMBUS manufacturer white-list filter separated by ',' . Example: 'DME,QDS' for receiving just telegrams from Diehl Metering GmbH and Qundis GmbH meters. Telegrams with different 3 character wMBUS manufacturer id will not be uploaded via LoRaWAN. (blank = filter inactive) typFilter string wMBUS device type white-list filter list separated by ','. Example: '08,07' for Heat-Cost and Water meters. Please refer to appendix B.1 for a list of possible values. (blank = filter inactive) Cron expressions Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the random time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 * * * * Hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * Daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * Every month daily from day 1 till 5 at 9:00:00 LoRaWAN Data Upload Formats After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge. Status Packet Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network . Data Packet After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before. Examples Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend. Upload Rate The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which de\u001cnes how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured cmodeCron or smodeCron, whichever is earlier. Because of this it is advisable to define the cron parameters with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a wireless M-Bus solution that uses alternate data transmission technologies, for example GSM/LTE or NarrowBand-IoT. Find our contact information under https://www.lobaro.com/contact/ , or simple send us an email to info@lobaro.com - either English or German is fine. Decoding wireless M-Bus After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided (see picture above). This REST API returns a JSON object including all encapsulated fields, e.g. the actual metering values. This greatly simplifies the bridge integration into your web based service or application. A 12 months period of free access to this API is included in our 'wmbus bridge testpacket' offer for quick device evaluation. API Integration into production systems is also possible, but in this case a separate agreement about a royalty fee must be achieved up front. For more information on licensing our wireless M-Bus parsing API plase send us your request via email to info@lobaro.com - either English or German is fine. Technical characteristics Product Type name wMBUS-LoRaWAN Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory up to 500 telegrams (on request: 1.500) Power Supply Nominal Supply Voltage 3V Supply Voltage Range 2.2V - 3.7V Power supply 2xAA battery, 1.5V (LR6/FR6) 5V USB powered over Lobaro Adapter On Request: 230V mains adapter, 3.6V Battery Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity Housing Dimensions Target Measurement / Purpose Forwarding of wireless M-BUS messages via LoRaWAN. Features wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request) PDF Documentation PDF Manual (en) for firmware V1.5.1 Product Flyer Declaration of Conformity Parser TTN function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"Manual"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#wireless-mbus-over-lorawan-bridge","text":"","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#overview","text":"The Lobaro wireless M-Bus (wMBUS) to LoRaWAN Bridge is a cost-effective & energye efficient device that receives, caches and transparently forwards wireless M-Bus metering data from up to 500 consumption meters via any LoRaWAN network onto the Internet. Many gas, water, electricity and heat meters can be read wirelessly today using the common short range Wireless M-Bus standard. Because such wMBUS enabled meters use the classical energy saving FSK radio modulation, the wireless range is often limited to less than 50m and therefore requires the use of additional longer-range radio technologies to forward the metering data onto the Internet. The advanced LoRa radio modulation used inside the Lobaro wMBUS to LoRaWAN Bridge is such a key technology. LoRaWAN based LPWANs (Low Power wide area networks) allow connections to the Internet from small battery powered devices with wireless ranges of up to 5 kilometers between the transmitter and receiving gateway antenna - without the usual cellular network costs in classical M2M or smart metering solutions. Also - unlike with cellular networks - it's possible to setup own gateways if needed. This often results in much lower operational costs with the Lobaro wMBUS bridge compared to conventional remote meter reading via LTE networks. The metering data will not be decrypted by the LoRaWAN Bridge, instead an unchanged 1:1 forwarding takes place via one or more LoRaWAN packets (depending on the wMBUS telegram byte size). Thus the end-to-end encryption of sensitive wireless MBUS consumption data is preserved. Initial configuration, firmware updates & status readouts are done user-friendly via USB on the PC with the Lobaro Tool (Windows, Linux, Mac). An additional possibility of configuration in the field \"over the air\" by means of LoRaWAN downlinks will soon also be available via firmware update. Please read the manual carefully before operating the device. A safe operation of the device is only possible if you follow the guides provided in this manual. Using the device differently than intended by Lobaro may cause damage to people, the environment, or the device. Consider using the latest firmware on your hardware See available firmware downloads","title":"Overview"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#the-device","text":"","title":"The Device"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#example-without-power-addon","text":"","title":"Example without Power Addon"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#example-with-power-addon","text":"","title":"Example with Power Addon"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#device-installation","text":"The device must be fixed on a flat surface using the lateral mounting holes of the case, see chapter \"Housing Dimensions\" for a detailed description of all housing dimensions. Alternatively we offer as accessory a mounting clip for a standard 35mm DIN rail. The device can then easily snapped on a such rails. It can therefore be added to a variety of racks alongside other devices. Under any circumstances the device must not be mounted higher than 2 meters above ground to avoid any risks in case of falling down! For optimal RF performance (e.g. LoRa range) any metal obstacles near the internal antenna should be avoided. In this case 'near' is defined as keep-out distance of about 3-5 centimeters around the antenna. The internal helix antenna can be identified by the winding pcb traces near the white printed encircled 'connectivity' symbol. In any case a device mounting directly on top of a metal surface is not advisable since it will degrade the possible RF range. Stone walls, wood or plastic stando\u001bs are perfectly ok. In case of challenging installation locations (e.g. in basements) or unavoidable long distances to the next LoRaWAN gateway, Lobaro offers on request custom product variant equipped with a 'SMA' connector to support a external antenna connection.","title":"Device installation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#power-supply","text":"The wMBUS over LoRaWAN Bridge default power supply consists of two series connected off-the-shelf 1.5V 'AA' sized batteries. Be sure to get the polarity right, see the '+'-Symbol on the board. In general only AA cells of the types Alkali-Manganese (1.5V, LR6) and Lithium- Iron-Sulphide (1.5V, FR6) are allowed to be inserted in the device. Lobaro recommends the use of FR6 batteries like the Energizer Ultimate Lithium over LR6 types because of the higher capacity and better discharge properties. Other Batteries or accumulators with a nominal voltage of more than 1.5V must not inserted into the device under any circumstances. In particular, lithium based cells with a nominal voltage of 3.6V or 3.7V must not be used on the AA battery slots! On request we can supply custom product variants with special housings powered by even bigger batteries. For example a 3.6V C sized mono cell typically has a capacity of 9Ah with leads to a 3x increased battery life compared to the standard AA-cells. With D sized cells of typically 19Ah capacity this value can be doubled once again (6x). Also available on request are options with permanent external power supply (230V, 9-24V, 5V USB).","title":"Power Supply"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#battery-life-time","text":"The battery life time of the wireless M-Bus to LoRaWAN Bridge can not be specifed trustworthy without knowledge of the detailed installation scenario. At least estimations for the following custom project based parameters have to be known: Meter count per single wMBUS bridge, e.g. 10 different meters. Needed LoRaWAN transmission interval, e.g. daily uploads. Average wireless M-Bus telegram size in bytes, e.g. 35 byte. Wireless M-Bus telegram transmission interval of the meter, e.g. every 10 seconds. Typically used LoRa Spreading Factor / LoRa link quality, e.g. SF10. Depending on these parameters battery life times from a few months to over 15 years can be achieved. You may send us your use-case details as described above to info@lobaro.com and we will return to you a custom battery lifetime calculation, a recommendation for the best power supply scheme and the needed minimal battery capacity.","title":"Battery life time"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#example-calculation","text":"In this battery lifetime calculation scenario the target meters send a 35 byte long ('L-Field') wireless M-Bus telegram constantly every 10 seconds. This behavior is for example very similar to a 'Hydrus' ultrasonic water meter of Diehl Metering . The Diehl meter itself has a specified battery life time of 12 years. Because of the mentioned 10 second send interval it is sufficient to configure the bridge for a wireless M-Bus listen period of 20 seconds by setting the bridge configuration parameter cmodeDurSec to a value of 20 (refer to section \"wMBUS bridge parameters\"). This will ensure that all meters of interest sent their consumption telegrams at least onces during the configured listen period of the bridge. For a worst-case battery-lifetime calculation the weakest possible LoRaWAN connectivity has been selected. That means to reach a LoRaWAN Gateway the Lobaro hardware has to send out its Uplink data very slowly (\u2265 2 seconds) and redundant by using a LoRa spreading factor of 12. Beside this the actual usable battery capacity has been set to 80% of the nominal value. The resulting worst-case minimal battery-life times are presented below. Battery life for daily LoRaWAN uploads with SF12 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 10.7 32.0 5 7.0 21.1 10 4.9 14.8 20 3.1 9.3 40 1.8 5.3 80 1.0 2.9 Estimations for the opposite situation with a excellent LoRa link quality and thus the possible usage of SF7 are presented below. In real world installations the possible spreading factor may be optimized anytime by setting up additional LoRaWAN Gateways near the meters of interest. Battery life for daily LoRaWAN uploads with SF7 Collected meters Battery Life (years) AA cell (3Ah) Battery Life (years) Baby cell(9Ah) 1 12.1 36.4 5 11.8 35.4 10 11.4 34.4 20 10.6 31.9 40 9.4 28.3 80 7.7 23.0","title":"Example calculation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#usage-scenario-recommendations","text":"As a simple rule of thumb using the Lobaro wireless M-Bus over LoRaWAN bridge is a good fit in applications that require daily (or less often) consumption values of 1 to 40 installed wireless M-Bus meters. For installations with a higher meter count simply more Lobaro bridges may be used. Another key factor for high battery lifetime is to select or configure your wireless M-Bus meters in a way that they send short telegrams very frequently, proven good values are periods smaller than 30 seconds and telegram sizes smaller 50 bytes. This helps to minimize the needed wMBus listening time period and avoids the need for multiple LoRaWAN packets per single telegram (data splitting). Beside this the bridge is naturally most economical when multiple meters per single bridge can be collected and forwarded via LoRWAN. Although for some applications a 1:1 setup, e.g. one bridge per meter, may deliver enough benefits to justify the invest. For hourly or even more frequent meter data uploads, as requested by some of our customers, LoRaWAN isn't the perfect match from a technology point of view. The same holds for scenarios where hundreds of meters are expected to be transfered by a single bridge, e.g. in 'sub-metering' applications with tons of installed heat cost allocators. For such more demanding cases Lobaro can offer better solutions using higher bandwidth transmission techniques like NB-IoT (Narrowband IoT) or classical 4G/LTE. Contact us if you need such a alternative solution by sending your request to info@lobaro.com - either English or German is fine.","title":"Usage scenario recommendations"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#work-cycle","text":"graph LR; wmbus(wMBUS Collection) init(Initial)==>check(LoRaWAN Join); check(LoRaWAN Join)==>wmbus(wMBUS Collection); wmbus(wMBUS Collection)==>trans(LoRaWAN Transfer); trans(LoRaWAN Transfer)==>sleep(Sleep); sleep(Sleep)==>|Cron expression|wmbus(wMBUS Collection) The Bridge has a simple work cycle that consists of five phases.","title":"Work Cycle"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#initial-phase","text":"This is the phase that is executed after the device is started of restarted. The Bridge performs a quick self test which you can easily spot by the green internal LED flashing. After that, the configuration is evaluated. If successful, the LoRaWAN Join phase is executed next.","title":"Initial Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#lorawan-join-phase","text":"If the Bridge is configured to use over the air activation (OTAA), the OTAA join is performed at this point. The device will repeatedly try to join its LoRaWAN network until the process is successful. It then enters the Data Collection Phase. If the Bridge is configured to use ABP instead of OTAA, this phase is left immediately and the Data Collection Phase is entered according to the cron configuration.","title":"LoRaWAN Join Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-collection-phase","text":"During the wMBUS collection phase the device receives any wireless M-Bus data with valid CRC and stores it for the following LoRaWAN upload phase but only if the received telegram passes the user defined white list filters. Similar telegrams of one identical meter may be received multiple times during this phase. In this case the newest telegram with the same id, type and length will replace the previously received one. Only the latest telegram will be uploaded via LoRaWAN. After the configured amount of time for collecting data the LoRaWAN data transfer phase is entered.","title":"Data Collection Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-transfer-phase","text":"During the Data Transfer Phase the Bridge uploads all previously stored wMBUS data using LoRaWAN. Depending on original wMBUS telegram byte sitze this can require multiple LoRaWAN messages to be sent. Since LoRa requires any device to respect a strict duty cycle, it is possible, that the Bridge will need to wait before sending its messages. If this happens, the device will enter a power saving modus while waiting for the next message. It is possible that transferring all data will take several minutes. In addition to the wireless M-Bus data, the Bridge sends a status packet once a day during this phase. The status packet will always be transmitted prior to any data packets. For a detailed description of the data sent refer to chapter \"Data Packet\".","title":"Data Transfer Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#sleep-phase","text":"After transferring all data packets the Bridge enters the Sleep Phase. During this it is completely inactive to avoid wasting power. It remains sleeping until one of the cron expressions given in the configuration triggers. When that happens, it enters the Data Collection Phase again.","title":"Sleep Phase"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#configuration","text":"","title":"Configuration"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#the-lobaro-maintenance-tool","text":"The initial device configuration can be done very comfortably from your PC via the serial configuration interface. Beside the needed Lobaro USB to UART adapter the Lobaro Maintenance Tool needs to be installed. This tool is freely available for various operating systems including Windows, Linux, Mac and Linux-ARM (e.g. Raspberry-PI) on and works with all Lobaro sensors. Technically this software opens a webserver on port 8585 that runs in a background console window. The actual user interface can be accessed normally using a standard web browser at address http://localhost:8585 (picture above). Normally your default browser should be opened with this URL automatically after tool startup . Even remote configuration and logobservation over the Internet is possible, e.g. having a Raspberry PI via USB connected to the Lobaro device and accessing the maintenance tool from a remote machines browser over the Internet. Additionally to the device setup the tool can also be used for firmware updates ('Firmware Tab') , watching real-time device diagnostic output ('Logs Tab') and initiating device restarts. Please note that the device is automatically restarted each time the configuration has been changed!","title":"The Lobaro Maintenance Tool"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#connecting-the-usb-config-adapter","text":"For configuration and firmware updates we provide a special serial-USB adapter that can be connected as shown in the picture below. The corresponding connector on the PCB is marked with the word 'Config'. The USB-adapter will add a virtual serial 'COM' Port to your system. Your operating system needs the CP210x USB to UART Bridge driver installed. A download link is provided next to the 'Connect' button when you start the Maintenance Tool. While the config adapter is connected, the device will be powered from the USB port with a regulated voltage of 3.3V. It is not necessary - although it would be no problem - having batteries inserted or a different supply connected while using the config adapter. All configuration parameters will be kept non-volatile regardless of the power supply.","title":"Connecting the USB config adapter"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#system-parameters","text":"After being successfully connected to the hardware using the Lobaro Maintenance Tool you can press 'Reload Config' in the 'Configuration' tab to read the current configuration from the device. For every parameter a default value is stored non volatile inside the hardware to which you can revert using the 'Restore default' button in case anything got miss configured. All LoRaWAN & other firmware parameters are explained in the following.","title":"System parameters"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#lorawan-network-parameters","text":"A large part of the configuration parameters are used to control the device's usage of LoRaWAN. There are two different ways to use LoRaWAN: over-the-air activation (OTAA) and activation by personalization (ABP). Some configuration parameters are only used with one of those methods, others are used for both. Name Type Used Description OTAA bool both true: use over-the-air activation (OTAA) false: use activation by personalization (ABP) DevEUI bytes[8] OTAA the 8 byte long DevEUI is used with OTAA to identify the device on join. The default is predefined in the hardware and guarantees an ID that is unique world wide. Should not be changed unless required by the network provider. Hex format without 0x prefix. AppEUI bytes[8] OTAA ID defining the application used in the LoRaWAN network. Hex format without 0x prefix. AppKey bytes[16] OTAA Application Key as defined by the LoRaWAN network operator. This is used to encrypt communication, so keep it secret. Hex format without 0x prefix. OTAADelay int OTAA Seconds to wait for a new attempt after an unsuccessful OTAA join. The actual waiting time will be randomly increased by up to a third of that amount, in order to avoid devices repeatedly interfering with each other through bad timing. The default value is 300, which means the timeout between attempts is 300-400 seconds. AppSKey bytes[16] ABP App Session Key as defined by the LoRaWAN network operator. Hex format without 0x prefix. NetSKey bytes[16] ABP Network Session Key ad defined by the LoRaWAN network operator. Hex format without 0x prefix. DevAdr bytes[4] ABP Device Address as defined by the LoRaWAN network operator. Hex format without 0x prefix. SF int both Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used might change during operation of the device if Adaptive Data Rate (ADR) is used. TxPower int both Initial transmission output power in dBm. The LoRaWAN protocol allows only specific values: 2, 5, 8, 11, 14. The actual power used might change during operation if Adaptive Data Rate (ADR) is used. ADR bool both true: use adaptive data rate (ADR) false: don't use adaptive data rate (ADR)","title":"LoRaWAN network parameters"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#wmbus-bridge-parameters","text":"Name Type Description loraMaxMsgSize int Received wireless M-Bus telegrams might have a byte size bigger than a single LoRaWAN message can hold. This parameter defines the bytes per LoRaWAN message before a partition over multiple LoRaWAN Uplink msg appears. (Range 10-50 bytes) resetHours int Hours after which the firmware will reset and rejoin the network. Can support the change of LoRaWAN network providers with already deployed devices. (0 = never) cmodeCron string Cron Expression defining when the device starts wMBUS T1/C1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no T1/C1 receive) cmodeDurSec int Duration in seconds for each C1/T1-mode wMBUS receive phase, if cmodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. smodeCron string Cron Expression defining when the device starts wMBUS S1 mode receive phases. Please refer to chapter \"Cron expression\" for an introduction. (blank = no S1 receive) smodeDurSec int Duration in seconds for each S1-mode wMBUS receive phase, if smodeCron != blank. Should be chosen in relation the wMBUS sendout interval of the target meter. devFilter string wMBUS device id white-list filter using 8 digits with leading zeros list separated by ','. Example '88009035,06198833'. (blank = filter inactive) mFilter string wMBUS manufacturer white-list filter separated by ',' . Example: 'DME,QDS' for receiving just telegrams from Diehl Metering GmbH and Qundis GmbH meters. Telegrams with different 3 character wMBUS manufacturer id will not be uploaded via LoRaWAN. (blank = filter inactive) typFilter string wMBUS device type white-list filter list separated by ','. Example: '08,07' for Heat-Cost and Water meters. Please refer to appendix B.1 for a list of possible values. (blank = filter inactive)","title":"wMBUS bridge parameters"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#cron-expressions","text":"Cron expressions are used to define specific points in time and regular repetitions of them. The schedule for data collecting phases is defined using the CRON format which is very powerful format to define repeatedly occurring events. Standard Lobaro devices typically do not need to know the real time for proper operation. All times are relative to the random time when batteries are inserted. If needed by the target application Lobaro can deliver on request special hardware support for keeping data acquisition intervals based on a real time clock which stays in sync with the real time. Please contact Lobaro directly if you need such a custom product variant. A cron expression consists of 6 values separated by spaces: Seconds (0-59) Minutes (0-59) Hours (0-23) Days (1-31) Month (1-12) Day of Week (SUN-SAT b= [0,6]) Examples of CRON definitions: 0 5 * * * * Hourly at minute 5, second 0 (at 00:05:00, 01:05:00, ...) 0 1/10 * * * * every 10 minutes from minute 1, second 0 (minutes 1, 11, 21, ...) 0 0 6 * * * Daily at 6:00:00 0 0 13 1,15 * * 1 st and 15 th day of every month at 13:00:00 0 0 9 1-5 * * Every month daily from day 1 till 5 at 9:00:00","title":"Cron expressions"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#lorawan-data-upload-formats","text":"After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two data formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the message formats contain only data bytes. The meaning of a byte is determined by its position within a message. The following describes the package formats used by the wireless M-Bus Bridge.","title":"LoRaWAN Data Upload Formats"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#status-packet","text":"Port 1 - In order to provide some information about the health & connectivity state of the device itself, the device sends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the device (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous status packet. It has a fixed length of 7 bytes. The battery voltages and ambient temperature are encodes as 16 bit integer using little endian encoding. name type bytes description example version uint8[3] 0-2 Version of the firmware running on the device 1, 5, 1 \u2261 v1.5.1 v_bat uint16 3-4 Battery voltage in mV 2947 \u2261 2:947V temp int16 5-6 Temperature measured inside the device in 1/10 \u00b0C 246 \u2261 24.6\u00b0C We provide a JavaScript reference implementation of a decoder for this status packet on GitHub , which can be used directly for decoding in The Things Network .","title":"Status Packet"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#data-packet","text":"After each wMBUS collecting phase, all saved telegrams (up to 500 can be stored) will be uploaded via LoRaWAN uplink messages as fast as possible. The received wMBUS telegrams that did pass the configured white list filters will be uploaded without any modification in one or more LoRaWAN messages. If a wMBUS telegram is bigger than the bridge configuration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is limited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the receiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the meter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes identifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using the LoRaWAN Port: 10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts) Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a ALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend noticed a missing packet the wMBUS telegram can't be assembled anymore as described before.","title":"Data Packet"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#examples","text":"Examples (with loraMaxMsgSize = 50): A 48 Byte wMBUS telegram will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting). A 75 byte wMBUS telegram will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got splitted into two LoRaWAN messages. Port 22 means that this data is the 2 nd part of the original wMBUS data. Both parts have to been concatenated in the order of receive by the backend. A 101 byte wMBUS telegram will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got splitted into three LoRaWAN messages. Port 23 means that this data is the 2 nd part of the original wMBUS data. Port 33 means that this data is the 3 rd part of the original wMBUS data. All three parts have to been concatenated in the order of receive by the backend.","title":"Examples"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#upload-rate","text":"The bridge has to work in compliance with the European SRD 868 1% duty-cycle regulations. This implies as a rule of thumb the device can upload at most wMBUS telegrams for 36 seconds every hour. The actual transmit time ('ToA: time on air') for each LoRaWAN message depends on the byte size and the used LoRa spreading factor (SF) which de\u001cnes how redundant LoRa data is send. This means a device with good connectivity and consequently using LoRa SF7 (ToA \u2264 0,050s) can upload much faster more data than a node using LoRa SF11 (ToA \u2265 1s) due to a hard to reach LoRaWAN gateway. The bridge will upload in conformity with the regulations automatically as fast as possible. When it has to wait it enters a low power sleep mode until the next transmission is possible again. The next data collection phase will be started only after completion of the previous upload phase in respect to the configured cmodeCron or smodeCron, whichever is earlier. Because of this it is advisable to define the cron parameters with an estimation of the upload duration in mind. This will avoid unexpected 'skipping' of data collection phases. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a wireless M-Bus solution that uses alternate data transmission technologies, for example GSM/LTE or NarrowBand-IoT. Find our contact information under https://www.lobaro.com/contact/ , or simple send us an email to info@lobaro.com - either English or German is fine.","title":"Upload Rate"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#decoding-wireless-m-bus","text":"After receiving the raw wireless M-Bus telegrams from your LoRaWAN network provider the actual metering data has to be decrypted and decoded by a backend service for further processing. The details of this are described in the EN 13757 norm and the newer OMS specification, which is a clarification of the original underlying norm. A universal wireless M-Bus decoder is a relatively complicated piece of software if you start implementing it from scratch since the norm covers many different use cases, units, meter types and data formats. If you know in advance the exact telegram format of the deployed meters in your setup a hard coded data decoding may be a feasible approach. This is because wireless M-Bus devices often send the same telegram format in every transmission. Please contact the manufacturer of your meters for the needed telegram format details. An an alternative to support a quick evaluation of our hardware Lobaro offers a easy to use webservice which is designed to decode all sorts of wMBUS input data including decryption if the correct key has been provided (see picture above). This REST API returns a JSON object including all encapsulated fields, e.g. the actual metering values. This greatly simplifies the bridge integration into your web based service or application. A 12 months period of free access to this API is included in our 'wmbus bridge testpacket' offer for quick device evaluation. API Integration into production systems is also possible, but in this case a separate agreement about a royalty fee must be achieved up front. For more information on licensing our wireless M-Bus parsing API plase send us your request via email to info@lobaro.com - either English or German is fine.","title":"Decoding wireless M-Bus"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#technical-characteristics","text":"Product Type name wMBUS-LoRaWAN Description wMBUS over LoRaWAN Bridge RF transceiver Chipset Semtech SX1272 Frequency Range 863 to 870 MHz TX Power \u2264 14 dBm LoRa communication LoRaWAN Protocol LoRaWAN 1.0.1, Class A, EU868 Activation method Over-the-air activation (OTAA) Activation by personalization (ABP) Encryption AES128 Typically RF range \u2264 2km Ideal RF range \u2264 10km (free line of sight) Wireless M-BUS communication Supported Modes (EN13757-4) S1, C1, T1 Frequencies 868.3 MHz, 868.95 MHz RF Range \u2264 30m Telegram memory up to 500 telegrams (on request: 1.500) Power Supply Nominal Supply Voltage 3V Supply Voltage Range 2.2V - 3.7V Power supply 2xAA battery, 1.5V (LR6/FR6) 5V USB powered over Lobaro Adapter On Request: 230V mains adapter, 3.6V Battery Current consumption @3V Normal \u22643 mA Wireless M-BUS RX \u226414 mA LoRa RX \u226414 mA LoRa TX \u226480 mA Sleep with RTC running \u226420 \u00b5A Mechanical dimensions Size 114.3 mm x 59.3 mm x 26.8 mm Housing Material ABS plastic Environmental Requirements Operating temperature range -20\u00b0C to +55\u00b0C Max. Installation height 2m Conformity","title":"Technical characteristics"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#housing-dimensions","text":"","title":"Housing Dimensions"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#target-measurement-purpose","text":"Forwarding of wireless M-BUS messages via LoRaWAN. Features wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#pdf-documentation","text":"PDF Manual (en) for firmware V1.5.1 Product Flyer Declaration of Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#ttn","text":"function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"TTN"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html","text":"Wireless mBUS over LoRaWAN Bridge Firmware Downloads: Stable Release V1.6 Current stable release for production environments: Download: app-wMbusLoraBridge-1.6.0.hex Experimental Release V2.x Experimental firmware which adds new features like a \"Learning Mode\" and uses a different LoRaWAN upload format. For production environments consider using the stable release V1.6 instead! Download: app-wmbus-bridge-2.1.3+LoRa.hex Changelogs v2.1.3 (11.03.2019) New Parameter: learnedListenSec to define how long to listen when meters was learned v2.1.2 (11.03.2019) Packet size depending on SF with payloadFormat = 1 v2.1.1 (20.02.2019) New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN framecounter, a whole message can be reconstructed in the backend. v2.0.0 (12.02.2019) Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received. v1.6.0 (20.05.2019) Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters v1.5.8 (18.02.2019) Reduce chance to miss wMbus packet when there is a lot of traffic v1.5.7 (07.01.2019) Fix issue with very large T1 mode telegrams v1.5.6 (20.11.2018) Support new FRAM memory type Improve random generator behaviour v1.5.5 (14.11.2018) internal use only v1.5.4 (25.10.2018) Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR v1.5.3 (18.10.2018) Fix bug with not working deduplication of same wMBUS messages during listen intervals v1.5.2 Support LoRaWAN Rx1 DataRate Offset v1.5.1 New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never) v1.5.0 Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack v1.4.1 Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output v1.4.0 New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration v1.3.1 Fix ADR Bugs v1.3.0 Allow to enable ADR (default: enabled) v1.2.0 Increase config version (Config will be reset) Introduce LoRaWAN default parameter v1.1.0 New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#wireless-mbus-over-lorawan-bridge","text":"","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#firmware","text":"Downloads: Stable Release V1.6 Current stable release for production environments: Download: app-wMbusLoraBridge-1.6.0.hex Experimental Release V2.x Experimental firmware which adds new features like a \"Learning Mode\" and uses a different LoRaWAN upload format. For production environments consider using the stable release V1.6 instead! Download: app-wmbus-bridge-2.1.3+LoRa.hex","title":"Firmware"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#changelogs","text":"","title":"Changelogs"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v213-11032019","text":"New Parameter: learnedListenSec to define how long to listen when meters was learned","title":"v2.1.3 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v212-11032019","text":"Packet size depending on SF with payloadFormat = 1","title":"v2.1.2 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v211-20022019","text":"New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN framecounter, a whole message can be reconstructed in the backend.","title":"v2.1.1 (20.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v200-12022019","text":"Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received.","title":"v2.0.0 (12.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v160-20052019","text":"Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters","title":"v1.6.0 (20.05.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v158-18022019","text":"Reduce chance to miss wMbus packet when there is a lot of traffic","title":"v1.5.8 (18.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v157-07012019","text":"Fix issue with very large T1 mode telegrams","title":"v1.5.7 (07.01.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v156-20112018","text":"Support new FRAM memory type Improve random generator behaviour","title":"v1.5.6 (20.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v155-14112018","text":"internal use only","title":"v1.5.5 (14.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v154-25102018","text":"Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR","title":"v1.5.4 (25.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v153-18102018","text":"Fix bug with not working deduplication of same wMBUS messages during listen intervals","title":"v1.5.3 (18.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v152","text":"Support LoRaWAN Rx1 DataRate Offset","title":"v1.5.2"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v151","text":"New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never)","title":"v1.5.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v150","text":"Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack","title":"v1.5.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v141","text":"Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output","title":"v1.4.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v140","text":"New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration","title":"v1.4.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v131","text":"Fix ADR Bugs","title":"v1.3.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v130","text":"Allow to enable ADR (default: enabled)","title":"v1.3.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v120","text":"Increase config version (Config will be reset) Introduce LoRaWAN default parameter","title":"v1.2.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v110","text":"New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter)","title":"v1.1.0"},{"location":"tools/lobaro-tool.html","text":"Lobaro Maintenance Tool Downloads Lobaro Maintenance Tool Download (v1.4.3 Windows) Lobaro Maintenance Tool Download (v1.4.3 Linux) Lobaro Maintenance Tool Download (v1.4.3 Mac) CP2102 Driver Download Supports the PC based configuration of all Lobaro IoT sensors. It is intend to be used in conjunction with our USB configuration adapter . Features Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file System Requirements Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge USB Driver The CP2102 USB driver MUST to be installed before using the Lobaro-tool. CP2102 Driver Download Download & Installation macOS / Linux After downloading the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then make the tool file executable: cd ~/lobaro chmod +x lobaro-tool ./lobaro-tool Windows After downloading simply start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway. This is behavior is normal. Changelog 1.4.3 - 30.07.2019 Fix a bug where writing the config does not work. 1.4.2 - 29.07.2019 Fix a bug where the program hangs up while connecting to a wrong serial port in \"auto\" mode. Fix a bug where the tool crashes when flashing the firmware while not connected. 1.4.0 - 10.08.2018 Log Tool events like Connect, Disconnect, Read Config, etc. to UART Log Switch to firmware mode after connecting with \"auto\" port 1.3.4 - 09.08.2018 Always switch to Firmware run mode after: Connect, Load Config, Restore Config. 1.3.3 Internet Explorer support 1.3.2 - 09.07.2018 Fix reading configs bigger than 256 Bytes (needed for wMbus Bridge) 1.3.0 - 21.03.2018 Improve connection detection Allow to connect to specific serial port Do not reset to boot mode when connecting to selected serial port 1.2.5 - 07.03.2018 Fix issues with loading a configuration file. Default is now \"config.yaml\" Remove horizontal scrollbars in tabs Add \"Set Time\" button to send \"time= \" via UART Add send UART input below Log Display if Firmware or Booloader is running Add success message when loading config 1.2.4 - 07.03.2018 Allow to replace assets e.g. the logo by placing /assets/logo.png next to the executable 1.2.3 - 05.03.2018 Log Timestamp in UART log file on disk Allow to set http server ip and port to allow remote access 1.2.2 - 19.02.2018 Fix CBOR decoding error that was introduced in 1.2.0 (see: https://github.com/ugorji/go/issues/232 ) 1.2.0 - 16.02.2018 Fix Serial port issues that appear on MAC, Linux and in rare cases on Windows 1.2.0 - 15.02.2018 Log UART output to file in $HOME/.lobaro/ 1.1.x Restore Default Config Close button Closing the browser window now also shut down the server","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#lobaro-maintenance-tool","text":"Downloads Lobaro Maintenance Tool Download (v1.4.3 Windows) Lobaro Maintenance Tool Download (v1.4.3 Linux) Lobaro Maintenance Tool Download (v1.4.3 Mac) CP2102 Driver Download Supports the PC based configuration of all Lobaro IoT sensors. It is intend to be used in conjunction with our USB configuration adapter .","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#features","text":"Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file","title":"Features"},{"location":"tools/lobaro-tool.html#system-requirements","text":"Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge USB Driver The CP2102 USB driver MUST to be installed before using the Lobaro-tool. CP2102 Driver Download","title":"System Requirements"},{"location":"tools/lobaro-tool.html#download-installation","text":"","title":"Download &amp; Installation"},{"location":"tools/lobaro-tool.html#macos-linux","text":"After downloading the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then make the tool file executable: cd ~/lobaro chmod +x lobaro-tool ./lobaro-tool","title":"macOS / Linux"},{"location":"tools/lobaro-tool.html#windows","text":"After downloading simply start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway. This is behavior is normal.","title":"Windows"},{"location":"tools/lobaro-tool.html#changelog","text":"","title":"Changelog"},{"location":"tools/lobaro-tool.html#143-30072019","text":"Fix a bug where writing the config does not work.","title":"1.4.3 - 30.07.2019"},{"location":"tools/lobaro-tool.html#142-29072019","text":"Fix a bug where the program hangs up while connecting to a wrong serial port in \"auto\" mode. Fix a bug where the tool crashes when flashing the firmware while not connected.","title":"1.4.2 - 29.07.2019"},{"location":"tools/lobaro-tool.html#140-10082018","text":"Log Tool events like Connect, Disconnect, Read Config, etc. to UART Log Switch to firmware mode after connecting with \"auto\" port","title":"1.4.0 - 10.08.2018"},{"location":"tools/lobaro-tool.html#134-09082018","text":"Always switch to Firmware run mode after: Connect, Load Config, Restore Config.","title":"1.3.4 - 09.08.2018"},{"location":"tools/lobaro-tool.html#133","text":"Internet Explorer support","title":"1.3.3"},{"location":"tools/lobaro-tool.html#132-09072018","text":"Fix reading configs bigger than 256 Bytes (needed for wMbus Bridge)","title":"1.3.2 - 09.07.2018"},{"location":"tools/lobaro-tool.html#130-21032018","text":"Improve connection detection Allow to connect to specific serial port Do not reset to boot mode when connecting to selected serial port","title":"1.3.0 - 21.03.2018"},{"location":"tools/lobaro-tool.html#125-07032018","text":"Fix issues with loading a configuration file. Default is now \"config.yaml\" Remove horizontal scrollbars in tabs Add \"Set Time\" button to send \"time= \" via UART Add send UART input below Log Display if Firmware or Booloader is running Add success message when loading config","title":"1.2.5 - 07.03.2018"},{"location":"tools/lobaro-tool.html#124-07032018","text":"Allow to replace assets e.g. the logo by placing /assets/logo.png next to the executable","title":"1.2.4 - 07.03.2018"},{"location":"tools/lobaro-tool.html#123-05032018","text":"Log Timestamp in UART log file on disk Allow to set http server ip and port to allow remote access","title":"1.2.3 - 05.03.2018"},{"location":"tools/lobaro-tool.html#122-19022018","text":"Fix CBOR decoding error that was introduced in 1.2.0 (see: https://github.com/ugorji/go/issues/232 )","title":"1.2.2 - 19.02.2018"},{"location":"tools/lobaro-tool.html#120-16022018","text":"Fix Serial port issues that appear on MAC, Linux and in rare cases on Windows","title":"1.2.0 - 16.02.2018"},{"location":"tools/lobaro-tool.html#120-15022018","text":"Log UART output to file in $HOME/.lobaro/","title":"1.2.0 - 15.02.2018"},{"location":"tools/lobaro-tool.html#11x","text":"Restore Default Config Close button Closing the browser window now also shut down the server","title":"1.1.x"},{"location":"tools/usb-config-adapter.html","text":"Lobaro USB configuration adapter The Lobaro USB configuration adapter connects the configuration serial uart of our hardware to a PC. It is useful for: Sensor initial configuration, e.g. network parameters Viewing firmware log/debug diagnostic output Firmware updates using our free Lobaro Maintenance Tool PC software. Wire orientation The blue wire is not consistent the RST/RTS pin(1) and may be inverted on some adapters, e.g. being the GND wire pin(6). Check the orientation of the adapter with the picture above to determinate the actual pin ordering and do not simply rely on the the wire color coding alone! USB Driver The CP2102 USB driver needs to be installed before using it. Download CP2102 Driver Download Hardware Connection (LoRaWAN Sensors) The adapter uses a six-wire JST-ZH series connector for attaching Lobaro hardware. Boot0 of Lobaro sensors is connected to DTR line of the PC uart Reset (active low) of Lobaro sensors is connected to RTS line of the PC uart Note Normally the handling of these uart control is done automatically by the Lobaro PC tool . When using an alternative uart terminal tool (e.g. HTERM ) make sure you setup the RTS and DTR lines correctly or simply cut the DTR/RTS wires from the USB adapter if the reset and/or bootloader functions are not needed. Default UART Configuration The default 8N1 UART configuration that is used by all Lobaro devices on the \"Config\" port: BaudRate 115200 Parity No Parity StopBits OneStopBit DataBits 8 DTR control line Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset RTS control line High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running) Adapter Schematic Picture USB Config Adapter","title":"USB Config Adapter"},{"location":"tools/usb-config-adapter.html#lobaro-usb-configuration-adapter","text":"The Lobaro USB configuration adapter connects the configuration serial uart of our hardware to a PC. It is useful for: Sensor initial configuration, e.g. network parameters Viewing firmware log/debug diagnostic output Firmware updates using our free Lobaro Maintenance Tool PC software. Wire orientation The blue wire is not consistent the RST/RTS pin(1) and may be inverted on some adapters, e.g. being the GND wire pin(6). Check the orientation of the adapter with the picture above to determinate the actual pin ordering and do not simply rely on the the wire color coding alone! USB Driver The CP2102 USB driver needs to be installed before using it. Download CP2102 Driver Download","title":"Lobaro USB configuration adapter"},{"location":"tools/usb-config-adapter.html#hardware-connection-lorawan-sensors","text":"The adapter uses a six-wire JST-ZH series connector for attaching Lobaro hardware. Boot0 of Lobaro sensors is connected to DTR line of the PC uart Reset (active low) of Lobaro sensors is connected to RTS line of the PC uart Note Normally the handling of these uart control is done automatically by the Lobaro PC tool . When using an alternative uart terminal tool (e.g. HTERM ) make sure you setup the RTS and DTR lines correctly or simply cut the DTR/RTS wires from the USB adapter if the reset and/or bootloader functions are not needed.","title":"Hardware Connection (LoRaWAN Sensors)"},{"location":"tools/usb-config-adapter.html#default-uart-configuration","text":"The default 8N1 UART configuration that is used by all Lobaro devices on the \"Config\" port: BaudRate 115200 Parity No Parity StopBits OneStopBit DataBits 8","title":"Default UART Configuration"},{"location":"tools/usb-config-adapter.html#dtr-control-line","text":"Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset","title":"DTR control line"},{"location":"tools/usb-config-adapter.html#rts-control-line","text":"High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running)","title":"RTS control line"},{"location":"tools/usb-config-adapter.html#adapter-schematic","text":"Picture USB Config Adapter","title":"Adapter Schematic"}]}