{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lobaro Documentation This site is the new upcoming central documentation for products of Lobaro GmbH . As of now it is highly experimental and heavily WIP. The supplied information here might be incomplete but should be, as far as it has been added, correct. Hardware Lobaro IoT Sensoren Sensor Technologie Modbus LoRaWAN Bridge LoRaWAN Ultraschall LoRaWAN Sensor LoRaWAN 1-Wire LoRaWAN Bridge LoRaWAN Tools Lobaro-Tool TBD","title":"Lobaro Documentation"},{"location":"#lobaro-documentation","text":"This site is the new upcoming central documentation for products of Lobaro GmbH . As of now it is highly experimental and heavily WIP. The supplied information here might be incomplete but should be, as far as it has been added, correct.","title":"Lobaro Documentation"},{"location":"#hardware","text":"","title":"Hardware"},{"location":"#lobaro-iot-sensoren","text":"Sensor Technologie Modbus LoRaWAN Bridge LoRaWAN Ultraschall LoRaWAN Sensor LoRaWAN 1-Wire LoRaWAN Bridge LoRaWAN","title":"Lobaro IoT Sensoren"},{"location":"#tools","text":"","title":"Tools"},{"location":"#lobaro-tool","text":"TBD","title":"Lobaro-Tool"},{"location":"background/cron-expressions/","text":"Cron Expressions We use CRON expressions configure the timing of our hardware. All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html The CRON expressions consists of 6 fields, separated by space: e.g. \" * * \" Meaning of the fields from left to right: Second (0-59) allowed special chars: \", - * /\" Minute (0-59) allowed special chars: \", - * /\" Hour (0-23) allowed special chars: \", - * /\" Day of Month (1-31) allowed special chars: \", - * / ?\" Month of Year (1-12 or JAN-DEC) allowed special chars: \", - * /\" Day of Week (1-7 or SUN-SAT) allowed special chars: \", - * /\" Special Characters: * (star, asterisk) \u2013 used to select all values within a field. For example, \"*\" in the minute field means \"every minute\". ? (question mark) \u2013 useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10th), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification. - (dash, minus) \u2013 used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d. , (comma) \u2013 used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d. / (slash) \u2013 used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u20181/3\u2019 in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d. A good website to test our CRON expressions is: https://www.freeformatter.com/cron-expression-generator-quartz.html Other Online CRON Generators and Tester: https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field.","title":"Cron Expressions"},{"location":"background/cron-expressions/#cron-expressions","text":"We use CRON expressions configure the timing of our hardware. All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html The CRON expressions consists of 6 fields, separated by space: e.g. \" * * \" Meaning of the fields from left to right: Second (0-59) allowed special chars: \", - * /\" Minute (0-59) allowed special chars: \", - * /\" Hour (0-23) allowed special chars: \", - * /\" Day of Month (1-31) allowed special chars: \", - * / ?\" Month of Year (1-12 or JAN-DEC) allowed special chars: \", - * /\" Day of Week (1-7 or SUN-SAT) allowed special chars: \", - * /\" Special Characters: * (star, asterisk) \u2013 used to select all values within a field. For example, \"*\" in the minute field means \"every minute\". ? (question mark) \u2013 useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10th), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification. - (dash, minus) \u2013 used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d. , (comma) \u2013 used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d. / (slash) \u2013 used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u20181/3\u2019 in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d. A good website to test our CRON expressions is: https://www.freeformatter.com/cron-expression-generator-quartz.html Other Online CRON Generators and Tester: https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field.","title":"Cron Expressions"},{"location":"background/lorawan/","text":"LoRaWAN LoRaWAN stands Lo ng Ra nge W ide A rea N etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. TODO: basics OTAA, ABP, SF, ADR, ...","title":"LoRaWAN"},{"location":"background/lorawan/#lorawan","text":"LoRaWAN stands Lo ng Ra nge W ide A rea N etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. TODO: basics OTAA, ABP, SF, ADR, ...","title":"LoRaWAN"},{"location":"iot-devices/1-wire-lorawan/","text":"1-Wire LoRaWAN Bridge Supports up to 20 DS18x20 1-Wire Temperature Sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks. Firmware Download Firmware Payload Example payloads for each port: Status Message (Port 1) Payload: (No Example yet) Decoded: { \"temp\": 20.4, \"vBat\": 1.35, \"version\": \"v0.2.0\" } Data Message (Port 2) Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\": [ { \"id\": \"551e46920d02\", \"temp\": 21.8 }, { \"id\": \"96b446920c02\", \"temp\": 21.5 }, { \"id\": \"dafc46920d02\", \"temp\": 21.3 }, { \"id\": \"202e46920502\", \"temp\": 22 } ], \"success\": true } Parser: TheThingsNetwork (TTN) function readVersion(bytes) { if (bytes.length<3) { return null; } return \"v\" + bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; } function parse_sint16(bytes, idx) { bytes = bytes.slice(idx || 0); var t = bytes[0] << 8 | bytes[1] << 0; if( (t & 1<<15) > 0){ // temp is negative (16bit 2's complement) t = ((~t)& 0xffff)+1; // invert 16bits & add 1 => now positive value t=t*-1; } return t; } function parse_uint16(bytes, idx) { bytes = bytes.slice(idx || 0); var t = bytes[0] << 8 | bytes[1] << 0; return t; } function parse_hex(bytes, idx, end) { var chars = \"0123456789abcdef\"; bytes = bytes.slice(idx || 0, end || null); var s = \"\"; for (var i=0; i<bytes.length; i++) { var byte = bytes[i]; s += chars.charAt(byte>>4); s += chars.charAt(byte & 0xf); } return s; } function DecoderPort1(bytes) { return { \"version\":readVersion(bytes), \"temp\": parse_sint16(bytes, 3) / 10, \"vBat\": parse_uint16(bytes, 5) / 1000, }; } function DecoderPort2(bytes) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false; var pos = 0; if ( bytes.length ) { pos+=1; success = bytes[0] !== 0; } var left = bytes.length - pos; while (left>=8) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id': parse_hex(bytes, pos, pos+6), 'temp': parse_sint16(bytes, pos+6) / 10.0 }; sensors.push(sensor); pos += 8; left = bytes.length - pos; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded['success'] = success; decoded['sensors'] = sensors; return decoded; } function Decoder(bytes, port) { switch (port) { case 1: return DecoderPort1(bytes); case 2: return DecoderPort2(bytes); } return { \"error\": \"Invalid port\", \"port\": port }; }","title":"1-Wire LoRaWAN Bridge"},{"location":"iot-devices/1-wire-lorawan/#1-wire-lorawan-bridge","text":"Supports up to 20 DS18x20 1-Wire Temperature Sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks.","title":"1-Wire LoRaWAN Bridge"},{"location":"iot-devices/1-wire-lorawan/#firmware","text":"Download Firmware","title":"Firmware"},{"location":"iot-devices/1-wire-lorawan/#payload","text":"Example payloads for each port:","title":"Payload"},{"location":"iot-devices/1-wire-lorawan/#status-message-port-1","text":"Payload: (No Example yet) Decoded: { \"temp\": 20.4, \"vBat\": 1.35, \"version\": \"v0.2.0\" }","title":"Status Message (Port 1)"},{"location":"iot-devices/1-wire-lorawan/#data-message-port-2","text":"Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 []byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\": [ { \"id\": \"551e46920d02\", \"temp\": 21.8 }, { \"id\": \"96b446920c02\", \"temp\": 21.5 }, { \"id\": \"dafc46920d02\", \"temp\": 21.3 }, { \"id\": \"202e46920502\", \"temp\": 22 } ], \"success\": true }","title":"Data Message (Port 2)"},{"location":"iot-devices/1-wire-lorawan/#parser-thethingsnetwork-ttn","text":"function readVersion(bytes) { if (bytes.length<3) { return null; } return \"v\" + bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; } function parse_sint16(bytes, idx) { bytes = bytes.slice(idx || 0); var t = bytes[0] << 8 | bytes[1] << 0; if( (t & 1<<15) > 0){ // temp is negative (16bit 2's complement) t = ((~t)& 0xffff)+1; // invert 16bits & add 1 => now positive value t=t*-1; } return t; } function parse_uint16(bytes, idx) { bytes = bytes.slice(idx || 0); var t = bytes[0] << 8 | bytes[1] << 0; return t; } function parse_hex(bytes, idx, end) { var chars = \"0123456789abcdef\"; bytes = bytes.slice(idx || 0, end || null); var s = \"\"; for (var i=0; i<bytes.length; i++) { var byte = bytes[i]; s += chars.charAt(byte>>4); s += chars.charAt(byte & 0xf); } return s; } function DecoderPort1(bytes) { return { \"version\":readVersion(bytes), \"temp\": parse_sint16(bytes, 3) / 10, \"vBat\": parse_uint16(bytes, 5) / 1000, }; } function DecoderPort2(bytes) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false; var pos = 0; if ( bytes.length ) { pos+=1; success = bytes[0] !== 0; } var left = bytes.length - pos; while (left>=8) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id': parse_hex(bytes, pos, pos+6), 'temp': parse_sint16(bytes, pos+6) / 10.0 }; sensors.push(sensor); pos += 8; left = bytes.length - pos; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded['success'] = success; decoded['sensors'] = sensors; return decoded; } function Decoder(bytes, port) { switch (port) { case 1: return DecoderPort1(bytes); case 2: return DecoderPort2(bytes); } return { \"error\": \"Invalid port\", \"port\": port }; }","title":"Parser: TheThingsNetwork (TTN)"},{"location":"iot-devices/modbus-lorawan/","text":"Modbus LoRaWAN Bridge The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. Configuration LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD Operation Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes Register/Coil definition Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration. Example register definition strings definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5. Payload formats The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ). Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1 Data messages The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined. Structure of a data pack name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document. Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion(bytes) { if (bytes.length<3) { return null; } return \"v\" + bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; } function int40_BE(bytes, idx) { bytes = bytes.slice(idx || 0); return bytes[0] << 32 | bytes[1] << 24 | bytes[2] << 16 | bytes[3] << 8 | bytes[4] << 0; } function int16_BE(bytes, idx) { bytes = bytes.slice(idx || 0); return bytes[0] << 8 | bytes[1] << 0; } function decode_status(bytes) { return { \"port\":1, \"version\":readVersion(bytes), \"flags\":bytes[3], \"temp\": int16_BE(bytes, 4) / 10, \"vBat\": int16_BE(bytes, 6) / 1000, \"timestamp\": int40_BE(bytes, 8), \"operationMode\": bytes[13] }; } function decode_data(bytes, port) { var fun = port - 10; var regs = []; if (bytes.length > 5) { var b = bytes.slice(5); while (b.length>=4) { var r = { \"device\":b[0], \"start\":int16_BE(b, 1), \"count\":b[3] & 0x7f, \"error\":!!(b[3]>>7), \"data\":null }; var dataLen = 0; if (fun<=2) { // coils, one bit per address dataLen = Math.ceil(r.count/8.0); } else { // registers, 16 bits per address dataLen = r.count*2; } if (b.length >= dataLen+4) { r.data = b.slice(4, 4 + dataLen); } regs.push(r); b = b.slice(4+dataLen); } } return decoded = { \"port\": port, \"function\": fun, \"timestamp\": int40_BE(bytes, 0), \"values\": regs }; } function Decoder(bytes, port) { switch (port) { case 1: return decode_status(bytes); case 11: case 12: case 13: case 14: return decode_data(bytes, port); } return {\"error\":\"invalid port\", \"port\":port}; }","title":"Modbus LoRaWAN Bridge"},{"location":"iot-devices/modbus-lorawan/#modbus-lorawan-bridge","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity.","title":"Modbus LoRaWAN Bridge"},{"location":"iot-devices/modbus-lorawan/#configuration","text":"","title":"Configuration"},{"location":"iot-devices/modbus-lorawan/#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN"},{"location":"iot-devices/modbus-lorawan/#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0.5 , 1 , 1.5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD","title":"Modbus/UART"},{"location":"iot-devices/modbus-lorawan/#operation","text":"Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0/15 * * * * for every 15 minutes","title":"Operation"},{"location":"iot-devices/modbus-lorawan/#registercoil-definition","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0x03 InputRegisters Input Register to read (2 byte read/write values) 0x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration.","title":"Register/Coil definition"},{"location":"iot-devices/modbus-lorawan/#example-register-definition-strings","text":"definition explanation 1:0:3 Read first three registers of device with address 1. 2:40001:1,2:2000:10 Read registers 40001 and 2000 to 2009 of device 2. 4:0:2,5:0:2,5:20:1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5.","title":"Example register definition strings"},{"location":"iot-devices/modbus-lorawan/#payload-formats","text":"The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0x01 ). 12 Data from reading Discrete Inputs (function 0x02 ). 13 Data from reading Holding Registers (function 0x03 ). 14 Data from reading Input Registers (function 0x04 ).","title":"Payload formats"},{"location":"iot-devices/modbus-lorawan/#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8[3] Version of firmware running on the device [1, 0, 4] \u2261 v1.0.4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24.6\u00b0C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3.547V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1","title":"Status messages"},{"location":"iot-devices/modbus-lorawan/#data-messages","text":"The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined.","title":"Data messages"},{"location":"iot-devices/modbus-lorawan/#structure-of-a-data-pack","text":"name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8[n] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data[3] & 0x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document.","title":"Structure of a data pack"},{"location":"iot-devices/modbus-lorawan/#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"iot-devices/modbus-lorawan/#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion(bytes) { if (bytes.length<3) { return null; } return \"v\" + bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; } function int40_BE(bytes, idx) { bytes = bytes.slice(idx || 0); return bytes[0] << 32 | bytes[1] << 24 | bytes[2] << 16 | bytes[3] << 8 | bytes[4] << 0; } function int16_BE(bytes, idx) { bytes = bytes.slice(idx || 0); return bytes[0] << 8 | bytes[1] << 0; } function decode_status(bytes) { return { \"port\":1, \"version\":readVersion(bytes), \"flags\":bytes[3], \"temp\": int16_BE(bytes, 4) / 10, \"vBat\": int16_BE(bytes, 6) / 1000, \"timestamp\": int40_BE(bytes, 8), \"operationMode\": bytes[13] }; } function decode_data(bytes, port) { var fun = port - 10; var regs = []; if (bytes.length > 5) { var b = bytes.slice(5); while (b.length>=4) { var r = { \"device\":b[0], \"start\":int16_BE(b, 1), \"count\":b[3] & 0x7f, \"error\":!!(b[3]>>7), \"data\":null }; var dataLen = 0; if (fun<=2) { // coils, one bit per address dataLen = Math.ceil(r.count/8.0); } else { // registers, 16 bits per address dataLen = r.count*2; } if (b.length >= dataLen+4) { r.data = b.slice(4, 4 + dataLen); } regs.push(r); b = b.slice(4+dataLen); } } return decoded = { \"port\": port, \"function\": fun, \"timestamp\": int40_BE(bytes, 0), \"values\": regs }; } function Decoder(bytes, port) { switch (port) { case 1: return decode_status(bytes); case 11: case 12: case 13: case 14: return decode_data(bytes, port); } return {\"error\":\"invalid port\", \"port\":port}; }","title":"Reference decoder"},{"location":"iot-devices/usonic-lorawan/","text":"USonic LoRaWAN Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16(byte1, byte2) { var decoded = byte1 | byte2 << 8; if ((decoded & 1 << 15) > 0) { // value is negative (16bit 2's complement) decoded = ((~decoded) & 0xffff) + 1; // invert 16bits & add 1 => now positive value decoded = decoded * -1; } return decoded; } function Decoder(bytes, port) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if (port === 2) { // Payload decoded.vBat = (bytes[0] | bytes[1] << 8) / 1000.0; // byte 6-7 (originally in mV) decoded.temp = decodeUInt16(bytes[2], bytes[3]) / 10.0; decoded.numResults = bytes[4]; var idx = 5; decoded.results = []; for (var i = 0; i < decoded.numResults; i++) { var result = {}; result.distance_mm = bytes[idx] | bytes[idx + 1] << 8 | bytes[idx + 2] << 16 | bytes[idx + 3] << 24; result.distance_m = result.distance_mm / 1000; result.tof_us = bytes[idx + 4] | bytes[idx + 5] << 8; result.width = bytes[idx + 6]; result.amplitude = bytes[idx + 7]; decoded.results[i] = result; idx += 8; } } // example decoder for status packet by lobaro if (port === 1) { // status packet decoded.firmwareVersion = bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; // byte 0-3 decoded.vBat = (bytes[4] | bytes[5] << 8) / 1000.0; // byte 6-7 (originally in mV) decoded.temp = decodeUInt16(bytes[6], bytes[7]) / 10.0; // byte 8-9 (originally in 10th degree C) decoded.msg = \"Firmware Version: v\" + decoded.firmwareVersion + \" Battery: \" + decoded.vBat + \"V Temperature: \" + decoded.temp + \"\u00b0C\"; } return decoded; } Example parser result { \"numResults\": 1, \"results\": [ { \"amplitude\": 215, \"distance_m\": 0.761, \"distance_mm\": 761, \"tof_us\": 4539, \"width\": 122 } ], \"temp\": 21.8, \"vBat\": 2.779 } Meaning of Payload parameters You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold.","title":"USonic LoRaWAN"},{"location":"iot-devices/usonic-lorawan/#usonic-lorawan","text":"","title":"USonic LoRaWAN"},{"location":"iot-devices/usonic-lorawan/#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16(byte1, byte2) { var decoded = byte1 | byte2 << 8; if ((decoded & 1 << 15) > 0) { // value is negative (16bit 2's complement) decoded = ((~decoded) & 0xffff) + 1; // invert 16bits & add 1 => now positive value decoded = decoded * -1; } return decoded; } function Decoder(bytes, port) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if (port === 2) { // Payload decoded.vBat = (bytes[0] | bytes[1] << 8) / 1000.0; // byte 6-7 (originally in mV) decoded.temp = decodeUInt16(bytes[2], bytes[3]) / 10.0; decoded.numResults = bytes[4]; var idx = 5; decoded.results = []; for (var i = 0; i < decoded.numResults; i++) { var result = {}; result.distance_mm = bytes[idx] | bytes[idx + 1] << 8 | bytes[idx + 2] << 16 | bytes[idx + 3] << 24; result.distance_m = result.distance_mm / 1000; result.tof_us = bytes[idx + 4] | bytes[idx + 5] << 8; result.width = bytes[idx + 6]; result.amplitude = bytes[idx + 7]; decoded.results[i] = result; idx += 8; } } // example decoder for status packet by lobaro if (port === 1) { // status packet decoded.firmwareVersion = bytes[0] + \".\" + bytes[1] + \".\" + bytes[2]; // byte 0-3 decoded.vBat = (bytes[4] | bytes[5] << 8) / 1000.0; // byte 6-7 (originally in mV) decoded.temp = decodeUInt16(bytes[6], bytes[7]) / 10.0; // byte 8-9 (originally in 10th degree C) decoded.msg = \"Firmware Version: v\" + decoded.firmwareVersion + \" Battery: \" + decoded.vBat + \"V Temperature: \" + decoded.temp + \"\u00b0C\"; } return decoded; }","title":"Reference decoder"},{"location":"iot-devices/usonic-lorawan/#example-parser-result","text":"{ \"numResults\": 1, \"results\": [ { \"amplitude\": 215, \"distance_m\": 0.761, \"distance_mm\": 761, \"tof_us\": 4539, \"width\": 122 } ], \"temp\": 21.8, \"vBat\": 2.779 }","title":"Example parser result"},{"location":"iot-devices/usonic-lorawan/#meaning-of-payload-parameters","text":"You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold.","title":"Meaning of Payload parameters"}]}