{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview This site is the new upcoming central documentation for IoT products of Lobaro GmbH . Hardware Lobaro IoT Sensoren Sensor Name RF-Technology Target Measurement / Purpose Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout wMBUS LoRaWAN Bridge LoRaWAN wMBUS enabled meter reading Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level Tools Configuration / Setup Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices Background Knowledge Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Home"},{"location":"index.html#overview","text":"This site is the new upcoming central documentation for IoT products of Lobaro GmbH .","title":"Overview"},{"location":"index.html#hardware","text":"","title":"Hardware"},{"location":"index.html#lobaro-iot-sensoren","text":"Sensor Name RF-Technology Target Measurement / Purpose Modbus LoRaWAN Bridge LoRaWAN RS485 ModBus readout Usonic LoRaWAN Sensor LoRaWAN Ultrasonic object / distance detection 1-Wire LoRaWAN Bridge LoRaWAN Read multiple temperature sensors EDL21 Electricity meter LoRaWAN Bridge LoRaWAN Electricity meter readout wMBUS LoRaWAN Bridge LoRaWAN wMBUS enabled meter reading Humidity & Temperature LoRaWAN Sensor LoRaWAN Humidity and Temperature probe GPS Tracker LoRaWAN LoRaWAN GPS Tracker with motion detection Pressure LoRaWAN Sensor LoRaWAN Measurement of liquid / water level","title":"Lobaro IoT Sensoren"},{"location":"index.html#tools","text":"","title":"Tools"},{"location":"index.html#configuration-setup","text":"Tool Name Technology Purpose Lobaro USB config adapter USB Sensor USB interface Lobaro Maintenance Tool Win, Mac, Linux Device configuration & diagnostics for all Lobaro devices","title":"Configuration / Setup"},{"location":"index.html#background-knowledge","text":"Introduction to CRON expressions Introduction to LoRaWAN Disposal of Lobaro devices Entsorgung von Ger\u00e4ten von Lobaro (German) OBIS-Codes","title":"Background Knowledge"},{"location":"background/cron-expressions.html","text":"Cron Expressions We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0 / 15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed. Meaning of the six fields: 0 0 / 15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range ( 0 - 59 ) ( 0 - 59 ) ( 0 - 23 ) ( 1 - 31 ) ( 1 - 12 ) ( 1 - 7 ) Alternative JAN - DEC SUN - SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * / Examples Cron definition Description Trigger time point(s) (hh ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1 / 10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1 , 15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1 - 5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist. Special Characters: star, asterisk ( * ) Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\". question mark ( ? ) Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification. dash, minus ( - ) Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d. comma ( , ) Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d. slash ( / ) Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u2018\u2153\u2019 in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d. Online CRON Generators and Tester: https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html Further Reading All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"CRON Expressions"},{"location":"background/cron-expressions.html#cron-expressions","text":"We use CRON expressions setup the timing of our hardware during device configuration using the Lobaro Maintenance Tool or remotely over the air. The CRON expressions consists of 6 fields, separated by space: e.g. 0 0 / 15 * * * * , which describes time points every 15 minutes starting from minute 0. CRON expression allow you define specific POINTS in time they are NOT helpful to define time durations. They can be seen has the start time to trigger an action, for example initiating the sensor measurement or wireless sendout. The duration of an action is defined by a separate configuration parameter if needed.","title":"Cron Expressions"},{"location":"background/cron-expressions.html#meaning-of-the-six-fields","text":"0 0 / 15 * * * * Second Minute Hour Day of Month Month of year Day of Week Range ( 0 - 59 ) ( 0 - 59 ) ( 0 - 23 ) ( 1 - 31 ) ( 1 - 12 ) ( 1 - 7 ) Alternative JAN - DEC SUN - SAT Allowed special chars , - * / , - * / , - * / , - * / ? , - * / , - * /","title":"Meaning of the six fields:"},{"location":"background/cron-expressions.html#examples","text":"Cron definition Description Trigger time point(s) (hh ss) 0 5 * * * * Hourly at minute 5, second 0 00:05:00, 01:05:00, 02:05:00... 0 1 / 10 * * * * Every 10 minutes starting from minute 1, second 0 00:01:00, 00:11:00, 00:21:00, [...], 01:01:00, [...] 0 0 6 * * * Daily on hour 6, minute 0, second 0 06:00:00 0 0 13 1 , 15 * * Hour 13, minute 0, second 0 on day 1 and 15 13:00:00 at 1 st and 15 th of month 0 15 9 1 - 5 * * Hour 9, minute 15, second 0 on day 1 to 5 09:15:00 at 1 st to 5 th of month Note Some Lobaro nodes do not keep the real time internally since for many sensor applications it is enough to configure repetition intervals. For example it may be a important configuration parameter that a specific sensor data gets transmitted every 15 minutes, but it does not matter if the send out takes place on [12:00h,12:15h...] or [12:05h, 12:20h...]. Times are relative to the random time when the device (re)starts or the batteries are inserted. If needed by your target application Lobaro can deliver on request special firmware support for keeping data acquisition intervals based on a real time clock (RTC) which stays in sync with the real time on your wrist.","title":"Examples"},{"location":"background/cron-expressions.html#special-characters","text":"","title":"Special Characters:"},{"location":"background/cron-expressions.html#star-asterisk","text":"Used to select all values within a field. For example, \"*\" in the minute field means \"every minute\".","title":"star, asterisk (*)"},{"location":"background/cron-expressions.html#question-mark","text":"Useful when you need to specify something in one of the two fields in which the character is allowed, but not the other. For example, if I want my trigger to fire on a particular day of the month (say, the 10 th ), but don\u2019t care what day of the week that happens to be, I would put \u201c10\u201d in the day-of-month field, and \u201c?\u201d in the day-of-week field. See the examples below for clarification.","title":"question mark (?)"},{"location":"background/cron-expressions.html#dash-minus-","text":"Used to specify ranges. For example, \u201c10-12\u201d in the hour field means \u201cthe hours 10, 11 and 12\u201d.","title":"dash, minus (-)"},{"location":"background/cron-expressions.html#comma","text":"Used to specify additional values. For example, \u201cMON,WED,FRI\u201d in the day-of-week field means \u201cthe days Monday, Wednesday, and Friday\u201d.","title":"comma (,)"},{"location":"background/cron-expressions.html#slash","text":"Used to specify increments. For example, \u201c0/15\u201d in the seconds field means \u201cthe seconds 0, 15, 30, and 45\u201d. And \u201c5/15\u201d in the seconds field means \u201cthe seconds 5, 20, 35, and 50\u201d. You can also specify \u2018/\u2019 after the \u2018\u2019 character - in this case \u2018\u2019 is equivalent to having \u20180\u2019 before the \u2018/\u2019. \u2018\u2153\u2019 in the day-of-month field means \u201cfire every 3 days starting on the first day of the month\u201d.","title":"slash (/)"},{"location":"background/cron-expressions.html#online-cron-generators-and-tester","text":"https://crontab-generator.org/ - \"command\" need to be set to some random string. The generated CRON has no \"seconds\". https://crontab.guru/ - Also without \"seconds\" field. https://www.freeformatter.com/cron-expression-generator-quartz.html","title":"Online CRON Generators and Tester:"},{"location":"background/cron-expressions.html#further-reading","text":"All our CRON expressions are in the same format as the Java Quarz scheduler, without the optional \"year\" field. A good documentation including examples can be found here: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html","title":"Further Reading"},{"location":"background/lorawan.html","text":"LoRaWAN LoRaWAN stands for **Lo**ng **Ra**nge **W**ide **A**rea **N**etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network. They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN) Parser LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"LoRaWAN"},{"location":"background/lorawan.html#lorawan","text":"LoRaWAN stands for **Lo**ng **Ra**nge **W**ide **A**rea **N**etwork and is a low power wireless network protocol. It uses the wireless transmission technology LoRa , owned by Semtech Corporation. Although LoRa is a proprietary and patented LoRaWAN can is openly specified by the LoRa Alliance and can be used freely if you have the necessary hardware. It is using publicly available frequencies to transmit its data. To operate LoRaWAN Sensors you need a LoRaWAN Network Server . A free to use, open source network server is The Things Network. They provide a very good documentation about the overall architecture and features of LoRaWAN: LoRaWAN Documentation (by TTN)","title":"LoRaWAN"},{"location":"background/lorawan.html#parser","text":"LoRaWAN Application Servers need to decode sensor payloads. This is done with custom parser code. We provide TTN compatible JavaScript parsers as reference implementation for all our devices. Some common help functions for this parsers can be found in the following example: function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 16 ); } function int24_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 24 ); } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function int64_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 7 ] << 56 | bytes [ 6 ] << 48 | bytes [ 5 ] << 40 | bytes [ 4 ] << 32 | bytes [ 3 ] << 24 | bytes [ 2 ] << 16 | bytes [ 1 ] << 8 | bytes [ 0 ] << 0 , 32 ); } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function bit ( byte , idx ) { return ( byte & ( 0x01 << idx )) != 0 ; } function readVersion ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } // EXAMPLE PARSER: // 0001000566566D38000000000600E600EA0C02400040E740C7 // 00 01 00 05 66 56 6D 38 00 00 00 00 06 00 E6 00 EA 0C 02 400040E740C7 /* Alarm ---------- reason: Button 2 (5) sensorTime: 946689638 vBat: 3306 temperature: 230 mems: <64,-6336,-14528> button1State: 0 button2State: 1 alarmAgeSec: 6 */ function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { \"version\" : readVersion ( bytes , 0 ), \"reason\" : bytes [ 3 ], \"sensorTime\" : int64_LE ( bytes , 4 ), \"alarmAgeSec\" : int16_LE ( bytes , 12 ), \"temperature\" : int16_LE ( bytes , 14 ) / 10 , \"vBat\" : int16_LE ( bytes , 16 ) / 1000 , \"button1State\" : bit ( bytes [ 18 ], 0 ), \"button2State\" : bit ( bytes [ 18 ], 1 ), \"memsX\" : int16_LE ( bytes , 19 ), \"memsY\" : int16_LE ( bytes , 21 ), \"memsZ\" : int16_LE ( bytes , 23 ), }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Parser"},{"location":"background/obis-codes.html","text":"OBIS-Codes Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61. Structure Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used Examples 1 . 0 : 1 . 8 . 0 * 255 Positive active energy (A+) total [kWh] 1 . 0 : 3 . 8 . 1 * 255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"OBIS Codes"},{"location":"background/obis-codes.html#obis-codes","text":"Object identification system (OBIS) Codes are used to identify the different readings of a smart meter transferred in Smart Message Language (SML). They are described in the international standard IEC 62056-61.","title":"OBIS-Codes"},{"location":"background/obis-codes.html#structure","text":"Every code consists of 6 separated group sub-identifiers. In general some of these identifiers may be omitted but our products require the full code. The basic pattern is: A-B:C.D.E*F group description examples A medium 1 = electricity, 8 = water B channel 0 = no channel available C physical unit, depends on A power, current, voltage... D measurement type, depends on A and C maximum, current value, energy... E tariff 0 = total, 1 = tariff 1, 2 = tariff 2 ... F separate values defined by A - E billing periods, 255 if not used","title":"Structure"},{"location":"background/obis-codes.html#examples","text":"1 . 0 : 1 . 8 . 0 * 255 Positive active energy (A+) total [kWh] 1 . 0 : 3 . 8 . 1 * 255 Positive reactive energy (Q+) in tariff T1 [kvarh]","title":"Examples"},{"location":"background/weee-disposal.html","text":"Disposal of Lobaro Devices Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash. WEEE The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility. Proper disposal of Lobaro B2B devices Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\". RoHS As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU. Batteries Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"WEEE Disposal"},{"location":"background/weee-disposal.html#disposal-of-lobaro-devices","text":"Deutsche Version: Entsorgung von Ger\u00e4ten von Lobaro . This page informs you on our policy in respect to EU \"Waste electrical and electronic equipment Directive\" 2002/96/EC, implemented in German law by the \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\" The following statements about the disposal of retired Lobaro devices are binding for customers in Germany. Customers in other countries should contact there local authorities in order to acquire equivalent information for their respective country. It is a major goal of EU directive 2002/96/EC reduce the amount of retired electronic devices disposed in household waste, but have them gathered in special facilities instead for recycling and orderly disposal. Electronic devices often contain hazardous substances which are harmful to the environment as well as to human health. Under no circumstances should they be disposed in household trash.","title":"Disposal of Lobaro Devices"},{"location":"background/weee-disposal.html#weee","text":"The WEEE-directive is the EU-directive \"Waste of Electrical and Electronic Equipment\" (2002/96/EC). It aims to reduce the growing amount of electrical and electronic waste created by disposed electronic devices. The goal is to avoid and reduce disposal, and to make the disposal more friendly for the environment, by including the manufacturer in a broader responsibility.","title":"WEEE"},{"location":"background/weee-disposal.html#proper-disposal-of-lobaro-b2b-devices","text":"Lobaro develops and manufactures devices for professional use. Because of this, our products have been recognised by the responsible agency \"Stiftung EAR\" (Elektro-Altger\u00e4te Register) as B2B (business to business) products. Lobaro GmbH is registered under DE18824018. Classification as B2B implies that Lobaro is not required to pick up disposed electronic devices from local recycling points, as the law \"ElektroG\" dictates manufacturers of consumer electronics to do. Consequently, our products may not be disposed in this way. Instead, we offer our customers to take back retired Lobaro devices and dispose them properly free of charge. Devices to be disposed must be sent to Lobaro GmbH postpaid and marked with the words \"ZUR ENTSORGUNG\".","title":"Proper disposal of Lobaro B2B devices"},{"location":"background/weee-disposal.html#rohs","text":"As a manufacturer of industrial devices of information and telecommunication technology we are producing conforming to RoHS as specified in the EU-directive 2011/65/EU.","title":"RoHS"},{"location":"background/weee-disposal.html#batteries","text":"Conforming to the German law about the disposal of used batteries (\u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658))), we as the manufacturer advise you, that the customer and end-consumer is required by law to return used batteries for a proper disposal. After usage, batteries can be returned to the vendor or at a place close proximity free of charge. If used batteries are sent to the vendor, parcels must be sent fully postpaid. The following symbol indicates, that a battery contains heavy metal or other hazardous substances, and that it must not be disposed in common household or industrial waste. The abbreviations under the symbol stand for: Cd Cadmium Hg Mercury Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metal Hydride Pb Lead Zi Zinc","title":"Batteries"},{"location":"background/weee-entsorgung.html","text":"Entsorgung von Ger\u00e4ten von Lobaro English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten. WEEE Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung. Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein. RoHS Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU. Batteriegesetz Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#entsorgung-von-geraten-von-lobaro","text":"English version: Disposal of Lobaro devices . Diese Seite informiert Sie \u00fcber das Vorgehen der Lobaro GmbH in Bezug auf die EU Richtlinie 2002/96/EC \u00fcber Elektro- und Elektronikaltger\u00e4te (engl. WEEE), umgesetzt in deutsches Recht durch das \"Gesetz \u00fcber das Inverkehrbringen, die R\u00fccknahme und die umweltvertr\u00e4gliche Entsorgung von Elektro- und Elektronikger\u00e4ten (Elektro- und Elektronikger\u00e4tegesetz \u2013 ElektroG)\". Die nachfolgend gemachten Aussagen \u00fcber die Entsorgung von au\u00dfer Gebrauch genommenen Lobaro Ger\u00e4ten gelten verbindlich nur f\u00fcr Kunden innerhalb Deutschlands. Kunden in anderen L\u00e4ndern sollten ihre \u00f6rtlichen Beh\u00f6rden kontaktieren, um entsprechende Informationen zu erhalten. Ein vordringliches Ziel der EU Richtlinie 2002/96/EC ist es, die Entsorgung von Elektro-/Elektronikaltger\u00e4ten zusammen mit dem unsortierten Hausm\u00fcll zu minimieren und einen hohen Grad an getrennter Sammlung und Verwertung von Elektro-/Elektronikaltger\u00e4ten zu erreichen. Elektronische Ger\u00e4te k\u00f6nnen Stoffe enthalten, die sch\u00e4dlich f\u00fcr die Umwelt und die menschliche Gesundheit sind und auf keinen Fall zusammen mit dem Hausm\u00fcll entsorgt werden sollten.","title":"Entsorgung von Ger\u00e4ten von Lobaro"},{"location":"background/weee-entsorgung.html#weee","text":"Die WEEE-Richtlinie (von engl.: Waste of Electrical and Electronic Equipment; deutsch: Elektro- und Elektronikger\u00e4te-Abfall) ist die EU-Richtlinie 2002/96/EC zur Reduktion der zunehmenden Menge an Elektronikschrott aus nicht mehr benutzten Elektro- und Elektronikger\u00e4ten. Ziel ist das Vermeiden, Verringern sowie umweltvertr\u00e4gliche Entsorgen der zunehmenden Mengen an Elektronikschrott durch eine erweiterte Herstellerverantwortung.","title":"WEEE"},{"location":"background/weee-entsorgung.html#ordnungsgemae-entsorgung-von-b2b-lobaro-geraten","text":"Lobaro Ger\u00e4te werden f\u00fcr den professionellen Gebrauch entwickelt und vermarktet. Dementsprechend sind sie von der zust\u00e4ndigen deutschen Agentur Stiftung EAR (Elektro- Altger\u00e4te Register) als B2B (business to business) Produkte anerkannt worden. Die Lobaro GmbH ist dort unter der Nr. DE18824018 registriert. Die B2B Klassifizierung bedeutet, dass Lobaro nicht zur Abholung von Elektro-/Elektronikaltger\u00e4ten bei den kommunalen Sammelstellen verpflichtet ist, wie es das ElektroG den Produzenten von f\u00fcr den Konsumenten-Markt bestimmten Elektro-/Elektronikger\u00e4ten vorschreibt. Folglich d\u00fcrfen unsere Produkte auch nicht auf diesem Wege entsorgt werden. Stattdessen bieten wir unseren Kunden an, nicht mehr gebrauchte Lobaro Ger\u00e4te zur\u00fcckzunehmen und auf unsere Kosten ordnungsgem\u00e4\u00df zu entsorgen. Ger\u00e4te zur Entsorgung m\u00fcssen mit bezahltem Porto an die Lobaro GmbH eingesendet werden und mit der Kennzeichnung \"ZUR ENTSORGUNG\" versehen sein.","title":"Ordnungsgem\u00e4\u00dfe Entsorgung von B2B Lobaro Ger\u00e4ten"},{"location":"background/weee-entsorgung.html#rohs","text":"Als Hersteller von industriellen Ger\u00e4ten der Informations- und Telekommunikationstechnik produzieren wir RoHS konform, gem\u00e4\u00df den Inhalten der EU-Richtlinie 2011/65/EU.","title":"RoHS"},{"location":"background/weee-entsorgung.html#batteriegesetz","text":"Gem\u00e4\u00df \u00a7 12 Satz 1 Nr. 1-3 BattV (Verordnung \u00fcber die R\u00fccknahme und Entsorgung gebrauchter Batterien und Akkumulatoren (BattVO) vom 27. M\u00e4rz 1998 (BGBl. I S. 658)) weisen wir als Verk\u00e4ufer darauf hin, dass der Kunde als Endverbraucher zur R\u00fcckgabe gebrauchter Batterien gesetzlich verpflichtet ist. Batterien k\u00f6nnen nach Gebrauch beim Verk\u00e4ufer oder in dessen unmittelbarer N\u00e4he unentgeltlich zur\u00fcckgegeben werden. Werden Batterien an den Verk\u00e4ufer \u00fcbersandt, ist das Paket ausreichend zu frankieren. Das nachfolgende Symbol bedeutet, dass es sich um schwermetallhaltige, schadstoffhaltige Batterien handelt, die nicht mit dem einfachen Haus- oder Gewerbeabfall entsorgt werden d\u00fcrfen. Die unter dem Symbol befindlichen Abk\u00fcrzungen bedeuten: Cd Cadmium Hg Quecksilber Li Lithium Li-Ion Lithium-Ion Ni Nickel Mh Metalhydride Pb Blei Zi Zink","title":"Batteriegesetz"},{"location":"dashboard/index.html","text":"Lobaro Dashboard The Lobaro Dashboard can be found at dashboard.lobaro.com Overview The Dashboard shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. Incoming data from a connected Sensor received by a Datasource and mapped to a single Device where the Raw Data is saved and a Parser gets executed. The result of the parser is saved as Device Data used for visualization inside the dashboard. graph LR; data>Sensor Data]-->ds(Datasource) device(device) ds-->device device-->parser(Parser) device-->raw[Raw Data] parser-->parsed[Device Data] Parser A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; } JS Parser API All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \" value ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ());","title":"Lobaro Dashboard"},{"location":"dashboard/index.html#lobaro-dashboard","text":"The Lobaro Dashboard can be found at dashboard.lobaro.com","title":"Lobaro Dashboard"},{"location":"dashboard/index.html#overview","text":"The Dashboard shows device data received via various data sources like LoRaWAN, NB.IoT, GSM, etc.. Incoming data from a connected Sensor received by a Datasource and mapped to a single Device where the Raw Data is saved and a Parser gets executed. The result of the parser is saved as Device Data used for visualization inside the dashboard. graph LR; data>Sensor Data]-->ds(Datasource) device(device) ds-->device device-->parser(Parser) device-->raw[Raw Data] parser-->parsed[Device Data]","title":"Overview"},{"location":"dashboard/index.html#parser","text":"A Parser takes raw input from the Sensor API and converts the data into a unified format used by the Dashboard. In addition the parser can access an API to set device level properties and additional meta information outside of the actual data record. Parsers are organized in 3 levels: Hardcoded default parser DeviceType parser Device parser When no parser on device level is defined, the parser for the device type will be executed. When no parser for the device type is defined, a hardcoded default parser will be executed. Parsers are written in JavaScript. Example function Parse ( input ) { // Decode an incoming message to an object of fields. var decoded = { input : input }; return decoded ; }","title":"Parser"},{"location":"dashboard/index.html#js-parser-api","text":"All functions are optional. Not calling them will not change any data. Update the physical location of the sensor Device . setLocation ( lon , lat ) Set an arbitary device property, displayed on the \"Overview\" tab of the device Device . setProperty ( \"key\" , \" value ); Set the Sensor time of the current data record. Used for display, filter, sorting Record . setTime ( new Date ());","title":"JS Parser API"},{"location":"lorawan-sensors/1-wire-lorawan/index.html","text":"1-Wire LoRaWAN Bridge Target Measurement / Purpose Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks. Payload Example payloads for each port: Status Message (Port 1) Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" } Data Message (Port 2) Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 [] byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551 e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true } Parser TheThingsNetwork (TTN) function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; }","title":"Manual"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#1-wire-lorawan-bridge","text":"","title":"1-Wire LoRaWAN Bridge"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#target-measurement-purpose","text":"Supports up to 20 DS18x20 1-Wire temperature sensors. The temperature form all sensors in read regualarly and send via LoRaWAN uplink. When the payload gets too big for a single LoRaWAN message, it is split into multiple uplinks.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#payload","text":"Example payloads for each port:","title":"Payload"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#status-message-port-1","text":"Payload: (No Example yet) Decoded: { \"temp\" : 20.4 , \"vBat\" : 3.0 , \"version\" : \"v0.2.0\" }","title":"Status Message (Port 1)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#data-message-port-2","text":"Structure: name pos len type description success 0 1 uint8 0 = Read error, 1 = Success sensor id 1 6 [] byte 6-Byte 1-Wire Sensor Id temperature 3 2 int16 BE Temperature in 1/10 \u00b0C ... ... sensor id and temperature fields repeat ... Example Payload: 01551 e46920d0200da96b446920c0200d7dafc46920d0200d5202e4692050200dc Decoded: { \"sensors\" : [ { \"id\" : \"551e46920d02\" , \"temp\" : 21.8 }, { \"id\" : \"96b446920c02\" , \"temp\" : 21.5 }, { \"id\" : \"dafc46920d02\" , \"temp\" : 21.3 }, { \"id\" : \"202e46920502\" , \"temp\" : 22 } ], \"success\" : true }","title":"Data Message (Port 2)"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/1-wire-lorawan/index.html#thethingsnetwork-ttn","text":"function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function parse_sint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function parse_hex ( bytes , idx , end ) { var chars = \"0123456789abcdef\" ; bytes = bytes . slice ( idx || 0 , end || null ); var s = \"\" ; for ( var i = 0 ; i < bytes . length ; i ++ ) { var byte = bytes [ i ]; s += chars . charAt ( byte >> 4 ); s += chars . charAt ( byte & 0xf ); } return s ; } function DecoderPort1 ( bytes ) { return { \"version\" : readVersion ( bytes ), \"temp\" : parse_sint16 ( bytes , 3 ) / 10 , \"vBat\" : parse_uint16 ( bytes , 5 ) / 1000 , }; } function DecoderPort2 ( bytes ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var sensors = []; var success = false ; var pos = 0 ; if ( bytes . length ) { pos += 1 ; success = bytes [ 0 ] !== 0 ; } var left = bytes . length - pos ; while ( left >= 8 ) { var sensor = { //'id_': bytes.slice(pos, pos+6), 'id' : parse_hex ( bytes , pos , pos + 6 ), 'temp' : parse_sint16 ( bytes , pos + 6 ) / 10.0 }; sensors . push ( sensor ); pos += 8 ; left = bytes . length - pos ; } // if (port === 1) decoded.led = bytes[0]; var decoded = {}; decoded [ 'success' ] = success ; decoded [ 'sensors' ] = sensors ; return decoded ; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); } return { \"error\" : \"Invalid port\" , \"port\" : port }; }","title":"TheThingsNetwork (TTN)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html","text":"1-Wire LoRaWAN Bridge (Temperature Sensors) Firmware Downloads: app-lorawan-onewire-bridge-0.2.0.hex Changelog v0.2.0 (15.02.2019) Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload v0.0.3 Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset v0.0.2 Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"Firmware & Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#1-wire-lorawan-bridge-temperature-sensors","text":"","title":"1-Wire LoRaWAN Bridge (Temperature Sensors)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-onewire-bridge-0.2.0.hex","title":"Firmware"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v020-15022019","text":"Add parameter \"SendSensorId\" to allow skipping sensor IDs in payload","title":"v0.2.0 (15.02.2019)"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v003","text":"Bugfixes in LoraWAN stack LoRaWAN Support for RX1 DataRate Offset","title":"v0.0.3"},{"location":"lorawan-sensors/1-wire-lorawan/firmware.html#v002","text":"Don't send sensor type with ID (support 6 sensors in 50 bytes) Add TestMode config value Add SendInternalTemp config value Internal sensor is send first if SendInternalTemp = true","title":"v0.0.2"},{"location":"lorawan-sensors/_template/index.html","text":"Name of Sensor Target Measurement / Purpose xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#name-of-sensor","text":"","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/index.html#target-measurement-purpose","text":"xxxx ** Features ** * 30cm to 3m detection range * up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/_template/firmware.html","text":"Name of Sensor Firmware Downloads : firmware.hex Changelog v0.0.1 Initial release","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#name-of-sensor","text":"","title":"Name of Sensor"},{"location":"lorawan-sensors/_template/firmware.html#firmware","text":"Downloads : firmware.hex","title":"Firmware"},{"location":"lorawan-sensors/_template/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/_template/firmware.html#v001","text":"Initial release","title":"v0.0.1"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html","text":"EDL21 Electricity meter LoRaWAN Bridge Target Measurement / Purpose Readout of EDL21 electricity meter with optical infrared \"INFO\" interface. Quickstart Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0 x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789 abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Operation Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0 / 15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1 - 0 : 1 . 7 . 255 * 255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes . LED blinking patterns The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red / green / blue 300ms each initial pattern after reset red short, blinking trying to receive meter optical data for the first time after reset green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once. Appendices Technical characteristics Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } } Example parser result Test input: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u20007B\u20007D\u200023\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 232588.30000000002 , \"valueHex\" : \"7b7d230000000000\" } ] }","title":"Manual"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#edl21-electricity-meter-lorawan-bridge","text":"","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#target-measurement-purpose","text":"Readout of EDL21 electricity meter with optical infrared \"INFO\" interface.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#quickstart","text":"Connect to the device with the Lobaro Tool using the Lobaro Config Adapter Under Configuration click \"Reload Config\" and change the fields ReadCron and ObisCode as you need followed by clicking on \"Write to Device\" click here for a configuration example Register the device in your LoRaWAN network Insert 2 batteries ('AA' size, 1.5V) / Connect external powersupply If not connected to anything the red LED will start blinking as long as no data is received, after 1 minute it will sleep for 15 seconds after every 5 retries Tighten the screws and install the bridge beside your electric meter Place the EDL21 opto head on the \"Info\" interface As soon as the EDL21 receives data its green LED will light up for 5 seconds, when connected to a LoRa Network its blue LED will light up for 5 seconds Check the sent data (port 3), if payload is zero the EDL21 was not able to read data, recheck proper alignment","title":"Quickstart"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0 x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789 abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ReadCron Cron expression defining when to read 0 0 / 15 * * * * for every 15 minutes ObisCode Comma separated list of ObisCodes to select a subset of the available information 1 - 0 : 1 . 7 . 255 * 255 = Leistung (Momentan) See also our Introduction to Cron expressions and our Introduction to Obis Codes .","title":"Operation"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#led-blinking-patterns","text":"The following pattery are explained in the order in which they appear after initial power on / reset of the device. color duration description red / green / blue 300ms each initial pattern after reset red short, blinking trying to receive meter optical data for the first time after reset green 5 seconds successfully received meter optical data blue 5 seconds LoRaWAN network join blue short sending LoRaWAN data uplink off - low-power mode until next sendout cycle As you can see by this the device will start the LoRaWAN join only after receiving optical data at least once.","title":"LED blinking patterns"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#technical-characteristics","text":"Product Type name EDL21-LoRaWAN Description Electricity meter over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readName ( bytes , i ) { return bytes . slice ( i , i + 6 ); } function readValue ( len , bytes , i ) { if ( len <= 0 ) { return []; } return bytes . slice ( i , i + len ); } function toHexString ( byteArray ) { var s = '' ; byteArray . forEach ( function ( byte ) { s += ( '0' + ( byte & 0xFF ). toString ( 16 )). slice ( - 2 ); }); return s ; } function parse_int8 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ]; if (( t & 1 << 7 ) > 0 ) { // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xff ) + 1 ; // invert 16bits & add 1 => now positive value t = t * - 1 ; } return t ; } function parse_int16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; if ( ( t & 1 << 15 ) > 0 ){ // temp is negative (16bit 2's complement) t = (( ~ t ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value t = t *- 1 ; } return t ; } function parse_uint16 ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var t = bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; return t ; } function toNumber ( bytes ) { var res = 0 ; for ( var i = 0 , s = 0 ; i < bytes . length ; i ++ ) { res |= bytes [ i ] << s ; s += 8 ; } return res ; } function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function decodeStatus ( bytes ) { var decoded = { \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"vBat\" : parse_uint16 ( bytes , 4 ) / 1000 , \"temp\" : parse_int16 ( bytes , 6 ) / 10 , }; return decoded ; } function decodeSmlValuesV1 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ) }; decoded . values . push ( val ); } return decoded ; } function decodeSmlValuesV2 ( bytes ) { var decoded = { values : [], }; if ( bytes . length === 1 ) { // No Data! Read error? return decoded ; } var pos = 0 ; while ( pos < bytes . length ) { var name = readName ( bytes , pos ); pos += 6 ; var len = bytes [ pos ]; pos += 1 ; var value = readValue ( len , bytes , pos ); pos += len ; if ( len > 0 ) { var exponent = parse_int8 ( bytes , pos ); pos += 1 ; } if ( len > 0 ) { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ) * Math . pow ( 10 , exponent ), valueHex : toHexString ( value ), } } else { var val = { nameHex : toHexString ( name ), len : len , value : toNumber ( value ), valueHex : toHexString ( value ), } } decoded . values . push ( val ); } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. if ( port === 1 ) { return decodeStatus ( bytes ); } if ( port === 2 ) { return decodeSmlValuesV1 ( bytes ); } if ( port == 3 ) { return decodeSmlValuesV2 ( bytes ); } }","title":"Reference decoder"},{"location":"lorawan-sensors/edl21-opto-lorawan/index.html#example-parser-result","text":"Test input: 01\u200000\u200001\u200008\u200000\u2000FE\u200008\u20007B\u20007D\u200023\u200000\u200000\u200000\u200000\u200000\u2000FF { \"values\" : [ { \"len\" : 8 , \"nameHex\" : \"0100010800fe\" , \"value\" : 232588.30000000002 , \"valueHex\" : \"7b7d230000000000\" } ] }","title":"Example parser result"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html","text":"EDL21 Electricity meter LoRaWAN Bridge Firmware Downloads: app-edl21-opto-0.2.0+LoRa.hex Changelog Firmware: app-edl21-opto v0.2.0 Initial release for new round Opto-Head","title":"Firmware & Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#edl21-electricity-meter-lorawan-bridge","text":"","title":"EDL21 Electricity meter LoRaWAN Bridge"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#firmware","text":"Downloads: app-edl21-opto-0.2.0+LoRa.hex","title":"Firmware"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#changelog","text":"Firmware: app-edl21-opto","title":"Changelog"},{"location":"lorawan-sensors/edl21-opto-lorawan/firmware.html#v020","text":"Initial release for new round Opto-Head","title":"v0.2.0"},{"location":"lorawan-sensors/gps-lorawan/index.html","text":"GPS LoRaWAN Tracker Target Measurement / Purpose GPS position tracking via LoRaWAN. PDF Documentation User Manual (en) CE Conformity Parser The Things Network For Version 4.x and 5.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } }","title":"Manual"},{"location":"lorawan-sensors/gps-lorawan/index.html#gps-lorawan-tracker","text":"","title":"GPS LoRaWAN Tracker"},{"location":"lorawan-sensors/gps-lorawan/index.html#target-measurement-purpose","text":"GPS position tracking via LoRaWAN.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/gps-lorawan/index.html#pdf-documentation","text":"User Manual (en) CE Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/gps-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/gps-lorawan/index.html#the-things-network","text":"For Version 4.x and 5.x function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int24_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 16 | bytes [ 1 ] << 8 | bytes [ 2 ] << 0 , 24 ); } function int32_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 24 | bytes [ 1 ] << 16 | bytes [ 2 ] << 8 | bytes [ 3 ] << 0 , 32 ); } function DecoderPort2 ( bytes ) { // Format for firmware 5.0.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var Temp = int16_BE ( bytes , 0 ) / 10 ; var VBat = int16_BE ( bytes , 2 ) / 1000 ; var Lat = int32_BE ( bytes , 4 ) / 100000 ; var Lon = int32_BE ( bytes , 8 ) / 100000 ; var Alt = int24_BE ( bytes , 12 ) / 100 ; var Valid = bytes [ 15 ] & 0x01 ; var Active = bytes [ 15 ] & 0x02 ; var SatCnt = bytes [ 16 ]; return { Temp : Temp || 0 , VBat : VBat || 0 , Lat : Lat || 0 , Lon : Lon || 0 , Alt : Alt || 0 , Valid : Valid , Active : Active , SatCnt : SatCnt }; } function DecoderPort1 ( bytes ) { // legacy format, firmware 4.x // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var button_number = bytes [ 0 ]; var Temp10tel = ( bytes [ 1 ] << 8 ) | ( bytes [ 2 ] << 0 ); var VBat1000tel = ( bytes [ 3 ] << 8 ) | ( bytes [ 4 ] << 0 ); var lat_deg = bytes [ 5 ]; var lat_min = bytes [ 6 ]; var lat_10000min = ( bytes [ 7 ] << 8 ) | ( bytes [ 8 ] << 0 ); var long_deg = bytes [ 9 ]; var long_min = bytes [ 10 ]; var long_10000min = ( bytes [ 11 ] << 8 ) | ( bytes [ 12 ] << 0 ); var gpsValid = ( bytes [ 13 ] !== 0 ); // Missing byte = true return { button_number : button_number || 0 , Temp10tel : Temp10tel || 0 , VBat1000tel : VBat1000tel || 0 , lat_deg : lat_deg || 0 , lat_min : lat_min || 0 , lat_10000min : lat_10000min || 0 , long_deg : long_deg || 0 , long_min : long_min || 0 , long_10000min : long_10000min || 0 , gps_valid : gpsValid || false }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return DecoderPort1 ( bytes ); case 2 : return DecoderPort2 ( bytes ); default : return { \"error\" : \"Unsupported port\" , \"port\" : port }; } }","title":"The Things Network"},{"location":"lorawan-sensors/gps-lorawan/firmware.html","text":"Name of Sensor Firmware Downloads : app-lorawan-gps-button-5.0.5.hex app-lorawan-gps-button-4.0.9.hex Changelog v5.0.5 - 09.01.2019 Update LoRaWAN Stack Enable stepUp if needed by battery condition v5.0.4 - 15.11.2018 update board driver v5.0.3 - 15.11.2018 fix signed issue with longitude v5.0.0 - 26.10.2018 Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack v4.0.9 - 05.10.2018 Update LoRaWAN Stack v4.0.7 - 15.08.2018 Fixed bugs with some LoRaWAN Network providers v4.0.6 - 28.05.2018 Clear pending mems IRQ before sleep Updated internal state handling v4.0.4 - 20.03.2018 Disable mems in active mode v4.0.3 - 20.03.2018 compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm v4.0.2 - 23.02.2018 Fix lost GPS messages due to broken CRC checks v4.0.1 - 29.01.2018 Port to LoRa v3.2 Board v3.2 Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR v3.1 Enable buttons for sending (Reed contact connectors)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#name-of-sensor","text":"","title":"Name of Sensor"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#firmware","text":"Downloads : app-lorawan-gps-button-5.0.5.hex app-lorawan-gps-button-4.0.9.hex","title":"Firmware"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v505-09012019","text":"Update LoRaWAN Stack Enable stepUp if needed by battery condition","title":"v5.0.5 - 09.01.2019"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v504-15112018","text":"update board driver","title":"v5.0.4 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v503-15112018","text":"fix signed issue with longitude","title":"v5.0.3 - 15.11.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v500-26102018","text":"Add option for Cayenne LLP Payload format Adjust payload format to support neagtive values Add Altitude Send GPS coordinates in Lat/Lon Format Update LoRaWAN Stack","title":"v5.0.0 - 26.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v409-05102018","text":"Update LoRaWAN Stack","title":"v4.0.9 - 05.10.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v407-15082018","text":"Fixed bugs with some LoRaWAN Network providers","title":"v4.0.7 - 15.08.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v406-28052018","text":"Clear pending mems IRQ before sleep Updated internal state handling","title":"v4.0.6 - 28.05.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v404-20032018","text":"Disable mems in active mode","title":"v4.0.4 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v403-20032018","text":"compile against new board revision (lower power in sleep) disable external rtc default tx power to 14dBm","title":"v4.0.3 - 20.03.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v402-23022018","text":"Fix lost GPS messages due to broken CRC checks","title":"v4.0.2 - 23.02.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v401-29012018","text":"Port to LoRa v3.2 Board","title":"v4.0.1 - 29.01.2018"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v32","text":"Measure vBat when 3.3V Step Up is off Add config parameter gps timeout Add config parameter LoRaWAN ADR","title":"v3.2"},{"location":"lorawan-sensors/gps-lorawan/firmware.html#v31","text":"Enable buttons for sending (Reed contact connectors)","title":"v3.1"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html","text":"Humidity & Temperature LoRaWAN Sensor Target Measurement / Purpose Temperature and relative humidity measurements with external probe and LoRaWAN. PDF Documentation User Manual (en) CE Conformity Sensor Specification Parser The Things Network (JavaScript) /** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"Manual"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#target-measurement-purpose","text":"Temperature and relative humidity measurements with external probe and LoRaWAN.","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#pdf-documentation","text":"User Manual (en) CE Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#sensor-specification","text":"","title":"Sensor Specification"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/humidity-temp-lorawan/index.html#the-things-network-javascript","text":"/** * TTN-compatible data decoder for the Lobaro LoRaWAN Humidity Sensor. */ function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function signed ( val , bits ) { if (( val & 1 << ( bits - 1 )) > 0 ) { // value is negative (16bit 2's complement) var mask = Math . pow ( 2 , bits ) - 1 ; val = ( ~ val & mask ) + 1 ; // invert all bits & add 1 => now positive value val = val * - 1 ; } return val ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return signed ( bytes [ 0 ] << 8 | bytes [ 1 ] << 0 , 16 ); } function int16_BE_1c ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); var v = ( bytes [ 0 ] & 0x7f ) << 8 | bytes [ 1 ] << 0 ; if ( bytes [ 0 ] & 0x80 ) { return - v ; } else { return v ; } } function port1 ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function port2 ( bytes ) { return { \"port\" : 2 , \"timestamp\" : int40_BE ( bytes , 0 ), \"error\" :!! ( bytes [ 1 ] & 0x01 ), \"humidity\" : int16_BE ( bytes , 6 ) / 10.0 , \"temperature\" : int16_BE_1c ( bytes , 8 ) / 10.0 }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return port1 ( bytes ); case 2 : return port2 ( bytes ); } return { \"error\" : \"invalid port\" , \"port\" : port }; }","title":"The Things Network (JavaScript)"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html","text":"Humidity & Temperature LoRaWAN Sensor Firmware Downloads: app-lorawan-humidity-0.0.3.hex Changelog 0.0.3 Initial public release","title":"Firmware & Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#humidity-temperature-lorawan-sensor","text":"","title":"Humidity &amp; Temperature LoRaWAN Sensor"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-humidity-0.0.3.hex","title":"Firmware"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/humidity-temp-lorawan/firmware.html#003","text":"Initial public release","title":"0.0.3"},{"location":"lorawan-sensors/modbus-lorawan/index.html","text":"Modbus (ASCII / RTU) over LoRaWAN Bridge Version v0.3.0 Target Measurement / Purpose The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. ** PDF Download:** Data Sheet with dimensions Work Cycle The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading Configuration The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter. LoRaWAN The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0 x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789 abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't Modbus/UART There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0 . 5 , 1 , 1 . 5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD Operation Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0 / 15 * * * * for every 15 minutes See also our Introduction to Cron expressions . Register/Coil definition Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0 x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0 x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0 x03 InputRegisters Input Register to read (2 byte read/write values) 0 x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration. Example register definition strings definition explanation 1 : 0 : 3 Read first three registers of device with address 1. 2 : 40001 : 1 , 2 : 2000 : 10 Read registers 40001 and 2000 to 2009 of device 2. 4 : 0 : 2 , 5 : 0 : 2 , 5 : 20 : 1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5. Payload formats The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0 x01 ). 12 Data from reading Discrete Inputs (function 0 x02 ). 13 Data from reading Holding Registers (function 0 x03 ). 14 Data from reading Input Registers (function 0 x04 ). Status messages The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8 [ 3 ] Version of firmware running on the device [ 1 , 0 , 4 ] \u2261 v1 . 0 . 4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24 . 6 \u00b0 C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3 . 547 V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1 Data messages The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined. Structure of a data pack name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8 [ n ] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data [ 3 ] & 0 x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document. Complex setups The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT. Appendices Technical characteristics Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards CE Declaration of Conformity CE Declaration of Conformity (pdf). Disposal / WEEE / Entsorgung Information about the disposal of the Device . Reference decoder This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Manual"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbus-ascii-rtu-over-lorawan-bridge","text":"Version v0.3.0","title":"Modbus (ASCII / RTU) over LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/index.html#target-measurement-purpose","text":"The Lobaro Modbus LoRaWAN Bridge is a low power device that can be used to read values out of a variety of other devices via Modbus (ASCII/RTU) over a RS-485 interface and forward them over LoRaWAN, so that they can be accessed from an attached system. Typical applications include reading out electric and water meters or retrieving data from environmental sensors like temperature and humidity. The Modbus Bridge supports reading of all four object types that can be provided by Modbus slave devices: Coil, Discrete Input, Input Register, and Holding Register. Multiple different slave devices on the Bus can be accessed individually by a single Bridge device. Reading intervals and register definitions can be configured very flexibly to suit individual requirements. ** PDF Download:** Data Sheet with dimensions","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/modbus-lorawan/index.html#work-cycle","text":"The Modbus LoRaWAN Bridge has a simple work cycle. It spends most of the time in a deep sleep state, to conserve energy. For every reading it wakes up for a few seconds, requests values from the connected slave devices, uploads the data via LoRaWAN, and then goes to sleep again. The following flowchart illustrates the work cycle: graph LR; init(Init)-->check(Test Reading); check-->join(LoRaWAN Join); join-->read(Data Collection); read-->send(Data Transfer); send-->sleep(\"Sleep\"); sleep-->|Cron expression| read; Init When the device starts (because it has just been connected to a power source, or after a reboot) it begins in the Init state. A quick self-check is executed; if that succeeds, the green on-board LED blinks once, slowly. After that the configuration is evaluated and checked for invalid values. If any problems are detected during Init , the device's LED will light up for three times, and the device will then reboot. If everything is okay, the device will continue with the Test Reading . Test Reading","title":"Work Cycle"},{"location":"lorawan-sensors/modbus-lorawan/index.html#configuration","text":"The configuration is done using Lobaro Maintenance Tool and the Lobaro USB PC adapter.","title":"Configuration"},{"location":"lorawan-sensors/modbus-lorawan/index.html#lorawan","text":"The connection to the LoRaWAN network is defined by multiple configuration parameters. This need to be set according to your LoRaWAN network and the way your device is supposed to be attached to it, or the device will not be able to send any data. There are two different methods to attach a device to a LoRaWAN network: Over-the-air-activation (OTAA) and Activation-by-personalisation (ABP). Depending on which method you are using you will have to set different values. Several values are a number of bytes, that need to be entered as hexstrings (without 0 x -prefix). So e.g. the DevEUI is a value of 8 bytes encoded in hex will be 16 hexdigits long. A sample value would be 0123456789 abcdef . name used type description OTAA both bool true \u2261 use OTAA, false \u2261 use ABP DevEUI OTAA hexbyte[8] the 8 byte DevEUI identifies the hardware on the join operation. The default value is a world wide unique value predefined in the hardware. Should not be changed unless required by the network provider. AppEUI OTAA hexbyte[8] ID defining the application used in the LoRaWAN network. AppKey OTAA hexbyte[16] Key used to encrypt communication with the LoRaWAN network. AppSKey ABP hexbyte[16] Application Session Key to be synced with the LoRaWAN network. NetSKey ABP hexbyte[16] Network Session Key to be synced with the LoRaWAN network. DevAdr ABP hexbyte[4] Device Address used to identify device in the LoRaWAN network. SF both int Initial LoRa spreading factor used for transmissions. Valid range is 7-12. The actual spreading factor used by change during operation if ADR is used. ADR both bool Should adaptive data rate be used? true \u2261 use ADR, false \u2261 don't","title":"LoRaWAN"},{"location":"lorawan-sensors/modbus-lorawan/index.html#modbusuart","text":"There are several values that define the configuration via Modbus. These values depend on the Slave devices that you want to read out. Please refer to your Modbus Devices's manual to find out the correct configuration. name description values ModbusProtocol Which Modbus-Protocol to use RTU . ASCII ModbusBaud UART Baud rate 9600 , 19200 , 38400 , ... ModbusDataLendth UART data length 7 , 8 , 9 ModbusStopBits UART stop bits 0 . 5 , 1 , 1 . 5 , 2 (written exactly like this) ModbusParity UART parity NONE , EVEN , ODD","title":"Modbus/UART"},{"location":"lorawan-sensors/modbus-lorawan/index.html#operation","text":"Configuration values defining the behaviour of the device. name description example value ModbusCron Cron expression defining when to read 0 0 / 15 * * * * for every 15 minutes See also our Introduction to Cron expressions .","title":"Operation"},{"location":"lorawan-sensors/modbus-lorawan/index.html#registercoil-definition","text":"Modbus defines four different object types form which values can be read: Coils, Discrete Inputs, Input Registers, and Holding Registers. For an introduction please refer to https://en.wikipedia.org/wiki/Modbus . There are four configuration values to define which values should be read by the Modbus Bridge, one for each of the types. name description Modbus Function Coils Coils to read (single bit read-only values) 0 x01 DiscreteInputs Discrete Inputs to read (single bit read/write values) 0 x02 HoldingRegisters Holding Registers to read (2 byte read-only values) 0 x03 InputRegisters Input Register to read (2 byte read/write values) 0 x04 Each value can define multiple different registers/coils to be read on one or multiple devices connected via Modbus. The format is identical for all four types. Each single definition consists of three values separated by colons ( : ). The address of the Modbus device that should be read from. Valid device addresses range from 1 to 247; with a single slave device on your bus this is often 1. The address of the first register/coil to be read on the device. Register addresses are uint16 values and range from 0 to 65535. The number of consecutive registers/coils to be read. This value is limited to 127, because longer answers cannot be encoded. Be aware that for registers a value higher than 22 leads to problems on high spreading factors so that the data will not be transferred completely via LoRaWAN. Multiple of these register definitions can be used if they are separated by commas ( , no spaces after the comma). You can use one or multiple of the register/coil types. If you do not want to use a type e.g. Coils , set that definition to an empty string. The device will parse the four register strings on startup and reports invalid definitions. The device will not work while there are invalid definitions but will reboot repeatedly until you fix the configuration.","title":"Register/Coil definition"},{"location":"lorawan-sensors/modbus-lorawan/index.html#example-register-definition-strings","text":"definition explanation 1 : 0 : 3 Read first three registers of device with address 1. 2 : 40001 : 1 , 2 : 2000 : 10 Read registers 40001 and 2000 to 2009 of device 2. 4 : 0 : 2 , 5 : 0 : 2 , 5 : 20 : 1 Read registers 0 and 1 of device 4 as well as registers 0, 1, and register 20 of device 5.","title":"Example register definition strings"},{"location":"lorawan-sensors/modbus-lorawan/index.html#payload-formats","text":"The Modbus Bridge sends different kinds of messages over different LoRaWAN ports: Port Message 1 Status messages. 11 Data from reading Coils (function 0 x01 ). 12 Data from reading Discrete Inputs (function 0 x02 ). 13 Data from reading Holding Registers (function 0 x03 ). 14 Data from reading Input Registers (function 0 x04 ).","title":"Payload formats"},{"location":"lorawan-sensors/modbus-lorawan/index.html#status-messages","text":"The Modbus Bridge sends a status messages report on the health of the device itself. This messages are sent along when the device is sending data packages with a maximum of one status message per day. Status messages are transmitted on port 1 and have a fixed length of 14 bytes. name pos len type description example version 0 3 uint8 [ 3 ] Version of firmware running on the device [ 1 , 0 , 4 ] \u2261 v1 . 0 . 4 flag 3 1 uint8 Status flag, for internal use 0 temperature 4 2 int16 Device's internal temperature in tenth \u00b0C 246 \u2261 24 . 6 \u00b0 C voltage 6 2 int16 Voltage supplied by power source in mV 3547 \u2261 3 . 547 V timestamp 8 5 int40 Internal date/time at creation of the status packet as UNIX timestamp 1533055905 mode 13 1 uint8 Operation mode the device runs 1","title":"Status messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#data-messages","text":"The principle message format is equal for all four types of registers/coils. The port used defines what kind of register/coil was read (see table \"Payload formats\" above). The format slightly differs for coils versus registers, since the amount of data per coil (1 bit) is different than the amount per register (16 bits). Each data message is starts with a 40 bit timestamp followed by one or more data packs. Each pack represents a single read operation caused by a single register definition in your configuration. The pack starts with 4 bytes repeating the information of the register definition extended by a single bit reporting errors on reading letting you know what data you are presented with and if it was read successfully). That information is followed by the raw data bytes as they where given by the slave device (as the Bridge cannot know how the data is presented in those bytes). The length of the data is dependent on the register definition and on the type (registers versus coils). The length is not explicitly stated, as it can be determined from the definition. The data bytes are also included when an error has occurred, however in this case the content of those bytes is undefined.","title":"Data messages"},{"location":"lorawan-sensors/modbus-lorawan/index.html#structure-of-a-data-pack","text":"name pos len type description addr 0 1 uint8 Modbus address of slave device. start 1 2 uint16 Address of first coil/register read. cnt+err 3 1 uint8 Highest bit: error indicator, 7 lower bits: number of consecutive coils/registers read. data 4 n uint8 [ n ] Raw data bytes as sent by the slave device. To get cnt , the number of coils/registers read, you need to only read the lower 7 bits of the fourth byte (e.g. by using something like data [ 3 ] & 0 x7f ). The highest bit is 0 on successful reads and 1 if an error occurred. See our reference decoder if you have trouble reading the format. The length of the data n for Coils and Discrete Inputs (Ports 11 and 12) the value of cnt divided by 8 rounded up (that is the minimal number of bytes needed to store cnt bits). For Registers (Ports 13 and 14) the data length is cnt * 2 , since registers contain two bytes of data. Please refer to the reference decoder usable in TTN at the end of this document.","title":"Structure of a data pack"},{"location":"lorawan-sensors/modbus-lorawan/index.html#complex-setups","text":"The Modbus Bridge as described in this manual can be individually configured to read out any registers and coils. For some setups, this is not enough. There can be situations in which you want to read registers at different intervals, e.g. you might need some values with hourly updates and others only every other day. For measuring values with high variance it can be necessary to take multiple reads over a period of time and create an average value. Maybe you need to read a status register first and depending on its value you want to decide which registers to read and transmit the values of. You could also want to write values into registers with the Bridge. All this scenarios are possible to solve using the Modbus Bridge, but their complexity leave the scope of our standard firmware. If you need any special processing for your Modbus setup, please contact us with your requirements, and we will make you an offer for an individual firmware that processes data the way you need. If you find that the data rate LoRaWAN offers is a limitation for your setup, we could also provide you with a Modbus solution that uses alternate data transmission technologies, for example NarrowBand-IoT.","title":"Complex setups"},{"location":"lorawan-sensors/modbus-lorawan/index.html#appendices","text":"","title":"Appendices"},{"location":"lorawan-sensors/modbus-lorawan/index.html#technical-characteristics","text":"Product Type name Modbus485-LoRaWAN Description Modbus over LoRaWAN Bridge RF tranceiver Type Semtech SX1272 Frequency 863 MHz to 870 MHz Max. TX Power max. +14 dBm Typical RF Range \u22642km Ideal RF Range \u226410km (free line of sight) LoRa communication Protocol Class A LoRaWAN 1.0.1 EU868 Activation method Over-the-air-activation (OTAA) Activation by personalization (ABP) Encryption AES128 Modbus communication Bus RS-485 twisted pair wires (with optional GND) Protocol RTU/ASCII Environmental Requirements Operating temperature -20\u00b0C \u2013 55\u00b0C Max installation height 2m Standards","title":"Technical characteristics"},{"location":"lorawan-sensors/modbus-lorawan/index.html#ce-declaration-of-conformity","text":"CE Declaration of Conformity (pdf).","title":"CE Declaration of Conformity"},{"location":"lorawan-sensors/modbus-lorawan/index.html#disposal-weee-entsorgung","text":"Information about the disposal of the Device .","title":"Disposal / WEEE / Entsorgung"},{"location":"lorawan-sensors/modbus-lorawan/index.html#reference-decoder","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function readVersion ( bytes ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; } function int40_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 32 | bytes [ 1 ] << 24 | bytes [ 2 ] << 16 | bytes [ 3 ] << 8 | bytes [ 4 ] << 0 ; } function int16_BE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 8 | bytes [ 1 ] << 0 ; } function decode_status ( bytes ) { return { \"port\" : 1 , \"version\" : readVersion ( bytes ), \"flags\" : bytes [ 3 ], \"temp\" : int16_BE ( bytes , 4 ) / 10 , \"vBat\" : int16_BE ( bytes , 6 ) / 1000 , \"timestamp\" : int40_BE ( bytes , 8 ), \"operationMode\" : bytes [ 13 ] }; } function decode_data ( bytes , port ) { var fun = port - 10 ; var regs = []; if ( bytes . length > 5 ) { var b = bytes . slice ( 5 ); while ( b . length >= 4 ) { var r = { \"device\" : b [ 0 ], \"start\" : int16_BE ( b , 1 ), \"count\" : b [ 3 ] & 0x7f , \"error\" :!! ( b [ 3 ] >> 7 ), \"data\" : null }; var dataLen = 0 ; if ( fun <= 2 ) { // coils, one bit per address dataLen = Math . ceil ( r . count / 8.0 ); } else { // registers, 16 bits per address dataLen = r . count * 2 ; } if ( b . length >= dataLen + 4 ) { r . data = b . slice ( 4 , 4 + dataLen ); } regs . push ( r ); b = b . slice ( 4 + dataLen ); } } return decoded = { \"port\" : port , \"function\" : fun , \"timestamp\" : int40_BE ( bytes , 0 ), \"values\" : regs }; } function Decoder ( bytes , port ) { switch ( port ) { case 1 : return decode_status ( bytes ); case 11 : case 12 : case 13 : case 14 : return decode_data ( bytes , port ); } return { \"error\" : \"invalid port\" , \"port\" : port }; } Copyright Modbus Logo","title":"Reference decoder"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html","text":"Modbus LoRaWAN Bridge Firmware Downloads: app-modbus-lora-bridge-0.3.1.hex . Changelog [Unreleased] Added Writing values to holding registers and coils. Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again. [0.3.1] \u2013 2019-05-24 Fixed Increased robustness of data reception on higher Baud rates. [0.3.0] \u2013 2019-05-15 Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Parity bit must not be substracted from Data bits anymore. 8 E1 can now be confiured with 8 Data bits , EVEN parity , 1 Stop bit .","title":"Firmware & Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#modbus-lorawan-bridge","text":"","title":"Modbus LoRaWAN Bridge"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#firmware","text":"Downloads: app-modbus-lora-bridge-0.3.1.hex .","title":"Firmware"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#unreleased","text":"Added Writing values to holding registers and coils. Fixed Flushing to avoid invalid byte received from switching from TX to RX. Modbus mode ASCII now counts received bytes correctly. DataLength of 7 bits can now correctly be set in config again.","title":"[Unreleased]"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#031-2019-05-24","text":"Fixed Increased robustness of data reception on higher Baud rates.","title":"[0.3.1] &ndash; 2019-05-24"},{"location":"lorawan-sensors/modbus-lorawan/firmware.html#030-2019-05-15","text":"Added Initial release of Firmware for new Hardware revision (with RS485-addon). Update Modbus to support all 4 types of registers. Parity bit must not be substracted from Data bits anymore. 8 E1 can now be confiured with 8 Data bits , EVEN parity , 1 Stop bit .","title":"[0.3.0] &ndash; 2019-05-15"},{"location":"lorawan-sensors/modbus-lorawan/redirect-example.html","text":"latest version","title":"Redirect example"},{"location":"lorawan-sensors/pressure-lorawan/index.html","text":"Pressure Sensor LoRaWAN Target Measurement / Purpose Precise liquid level measurement, e.g. for tanks, via LoRaWAN. ** Features ** Cable length 1-15m 0..1 Bar (10m water level) Waterproof IP67 Housing Multi-year Battery life, ultra low power (< 10\u00b5A) Payload Format Parser: The Things Network function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Manual"},{"location":"lorawan-sensors/pressure-lorawan/index.html#pressure-sensor-lorawan","text":"","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/index.html#target-measurement-purpose","text":"Precise liquid level measurement, e.g. for tanks, via LoRaWAN. ** Features ** Cable length 1-15m 0..1 Bar (10m water level) Waterproof IP67 Housing Multi-year Battery life, ultra low power (< 10\u00b5A)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/pressure-lorawan/index.html#payload-format","text":"","title":"Payload Format"},{"location":"lorawan-sensors/pressure-lorawan/index.html#parser-the-things-network","text":"function decodeFloat32 ( bytes ) { var sign = ( bytes & 0x80000000 ) ? - 1 : 1 ; var exponent = (( bytes >> 23 ) & 0xFF ) - 127 ; var significand = ( bytes & ~ ( - 1 << 23 )); if ( exponent == 128 ) return sign * (( significand ) ? Number . NaN : Number . POSITIVE_INFINITY ); if ( exponent == - 127 ) { if ( significand == 0 ) return sign * 0.0 ; exponent = - 126 ; significand /= ( 1 << 22 ); } else significand = ( significand | ( 1 << 23 )) / ( 1 << 23 ); return sign * significand * Math . pow ( 2 , exponent ); } function decodeInt16 ( bytes ) { if (( bytes & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) bytes = (( ~ bytes ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value bytes = bytes * - 1 ; } return bytes ; } function int16_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 ; } function int32_LE ( bytes , idx ) { bytes = bytes . slice ( idx || 0 ); return bytes [ 0 ] << 0 | bytes [ 1 ] << 8 | bytes [ 2 ] << 16 | bytes [ 3 ] << 24 ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = { pressure : decodeFloat32 ( int32_LE ( bytes , 0 )), temp : decodeInt16 ( int16_LE ( bytes , 4 )) / 100 , }; // if (port === 1) decoded.led = bytes[0]; return decoded ; }","title":"Parser: The Things Network"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html","text":"Pressure Sensor LoRaWAN Firmware Downloads : app-keller-pressure-0.0.3.hex Changelog v0.0.3 (14.02.2019) Reduce I2C speed from 10kHz to 1kHz for 10m cable v0.0.2 Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz v0.0.1 inital version","title":"Firmware & Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#pressure-sensor-lorawan","text":"","title":"Pressure Sensor LoRaWAN"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#firmware","text":"Downloads : app-keller-pressure-0.0.3.hex","title":"Firmware"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v003-14022019","text":"Reduce I2C speed from 10kHz to 1kHz for 10m cable","title":"v0.0.3 (14.02.2019)"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v002","text":"Update LoRaWAN Stack Reduce I2C speed from 100kHz to 10kHz","title":"v0.0.2"},{"location":"lorawan-sensors/pressure-lorawan/firmware.html#v001","text":"inital version","title":"v0.0.1"},{"location":"lorawan-sensors/usonic-lorawan/index.html","text":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\") Target Measurement / Purpose Distance measurements via ultrasound. ** Features: ** 30cm to 3m detection range up to 8 detected objects Technical description The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match. Open Top vs. Closed Top As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts. Parser The Things Network (TTN) This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold. Encoder Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; }","title":"Manual"},{"location":"lorawan-sensors/usonic-lorawan/index.html#ultrasonic-lorawan-sensor-aka-oscar","text":"","title":"Ultrasonic LoRaWAN Sensor (a.k.a. \"Oscar\")"},{"location":"lorawan-sensors/usonic-lorawan/index.html#target-measurement-purpose","text":"Distance measurements via ultrasound. ** Features: ** 30cm to 3m detection range up to 8 detected objects","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/usonic-lorawan/index.html#technical-description","text":"The device is based on the PGA460 from Texas Instruments ( http://www.ti.com/product/PGA460 ) PGA460 Ultrasonic Module Hardware and Software Optimization PGA460 Ultrasonic Signal Processor and Transducer The PGA enables tuning of the Ultrasonic Sensor for all kind of environments. The default firmware supports parameters tested in underground waste bins. Lobaro offers customized tuning and consulting for environments where the default configuration does not match.","title":"Technical description"},{"location":"lorawan-sensors/usonic-lorawan/index.html#open-top-vs-closed-top","text":"As for now the sensor is shipped with an open top membran. This has advantages in sensibility and range, but is more prone to environmental impacts. Closed-Top Sensors (e.g. as used in Automotive) need more energy to send out a clear signal but are resistant against environmental impacts.","title":"Open Top vs. Closed Top"},{"location":"lorawan-sensors/usonic-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/usonic-lorawan/index.html#the-things-network-ttn","text":"This is a decoder written in JavaScript that can be used to parse the device's LoRaWAN messages. It can be used as is in The Things Network . function decodeUInt16 ( byte1 , byte2 ) { var decoded = byte1 | byte2 << 8 ; if (( decoded & 1 << 15 ) > 0 ) { // value is negative (16bit 2's complement) decoded = (( ~ decoded ) & 0xffff ) + 1 ; // invert 16bits & add 1 => now positive value decoded = decoded * - 1 ; } return decoded ; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 2 ) { // Payload decoded . vBat = ( bytes [ 0 ] | bytes [ 1 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 2 ], bytes [ 3 ]) / 10.0 ; decoded . numResults = bytes [ 4 ]; var idx = 5 ; decoded . results = []; for ( var i = 0 ; i < decoded . numResults ; i ++ ) { var result = {}; result . distance_mm = bytes [ idx ] | bytes [ idx + 1 ] << 8 | bytes [ idx + 2 ] << 16 | bytes [ idx + 3 ] << 24 ; result . distance_m = result . distance_mm / 1000 ; result . tof_us = bytes [ idx + 4 ] | bytes [ idx + 5 ] << 8 ; result . width = bytes [ idx + 6 ]; result . amplitude = bytes [ idx + 7 ]; decoded . results [ i ] = result ; idx += 8 ; } } // example decoder for status packet by lobaro if ( port === 1 ) { // status packet decoded . firmwareVersion = bytes [ 0 ] + \".\" + bytes [ 1 ] + \".\" + bytes [ 2 ]; // byte 0-3 decoded . vBat = ( bytes [ 4 ] | bytes [ 5 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . temp = decodeUInt16 ( bytes [ 6 ], bytes [ 7 ]) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . firmwareVersion + \" Battery: \" + decoded . vBat + \"V Temperature: \" + decoded . temp + \"\u00b0C\" ; } return decoded ; } Example parser result { \"numResults\" : 1 , \"results\" : [ { \"amplitude\" : 215 , \"distance_m\" : 0.761 , \"distance_mm\" : 761 , \"tof_us\" : 4539 , \"width\" : 122 } ], \"temp\" : 21.8 , \"vBat\" : 2.779 } You can think of the usonic signal as a strength of signal or volume over time Amplitude ranges from 0\u2013255 and has no unit. It is highly influenced by the internal amplification parameter. An amplitude of 100 or above is interpreted as reflected signal. Values below 100 are dismissed as background noise. ToF is the Time of Flight measured in \u00b5s. From this and the speed of sound the distance to a detected object is calculated. Width indicates how \"wide\" a detected signal is in time. That is the time in \u00b5s before the amplitude drops back below the threshold.","title":"The Things Network (TTN)"},{"location":"lorawan-sensors/usonic-lorawan/index.html#encoder","text":"Used to update configuration on the device. function Encoder ( object , port ) { // Encode downlink messages sent as // object to an array or buffer of bytes. var bytes = []; string = object [ \"string\" ] || \"\" ; for ( var i = 0 ; i < string . length ; ++ i ) { bytes . push ( string . charCodeAt ( i )); } return bytes ; }","title":"Encoder"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html","text":"USonic LoRaWAN Firmware Downloads: app-lorawan-usonic-0.1.1.hex Changelog Firmware: app-lorawan-usonic v0.1.1 Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"Firmware & Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#usonic-lorawan","text":"","title":"USonic LoRaWAN"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#firmware","text":"Downloads: app-lorawan-usonic-0.1.1.hex","title":"Firmware"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#changelog","text":"Firmware: app-lorawan-usonic","title":"Changelog"},{"location":"lorawan-sensors/usonic-lorawan/firmware.html#v011","text":"Tune for new sensor, still compatible with last one (V2) Allow to configure ADR Fix bug where TxPower config value was not applied Add usonicTest mode to permanently measure usonic values Usonic sensor measurement extended to 3.5m Implement more LoRaWAN Mac commands Fix bug where Firmware reset when receiving unknown MAC command","title":"v0.1.1"},{"location":"lorawan-sensors/wmbus-lorawan/index.html","text":"Wireless mBUS over LoRaWAN Bridge Target Measurement / Purpose Forwarding of wireless M-BUS messages via LoRaWAN. ** Features ** wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request) PDF Documentation PDF Manual (en) for firmware V1.5.1 Product Flyer Declaration of Conformity Parser TTN function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"Manual"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#wireless-mbus-over-lorawan-bridge","text":"","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#target-measurement-purpose","text":"Forwarding of wireless M-BUS messages via LoRaWAN. ** Features ** wMBUS C1/T1 and S1 modes 868 MHz only (433 MHz on request)","title":"Target Measurement / Purpose"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#pdf-documentation","text":"PDF Manual (en) for firmware V1.5.1 Product Flyer Declaration of Conformity","title":"PDF Documentation"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#parser","text":"","title":"Parser"},{"location":"lorawan-sensors/wmbus-lorawan/index.html#ttn","text":"function readVersion ( bytes , i ) { if ( bytes . length < 3 ) { return null ; } return \"v\" + bytes [ i ] + \".\" + bytes [ i + 1 ] + \".\" + bytes [ i + 2 ]; } function Decoder ( bytes , port ) { // Decode an uplink message from a buffer // (array) of bytes to an object of fields. var decoded = {}; if ( port === 9 ) { decoded . devStatus = bytes [ 0 ]; decoded . devID = bytes [ 1 ] | bytes [ 2 ] << 8 | bytes [ 3 ] << 16 | bytes [ 4 ] << 24 ; decoded . dif = bytes [ 5 ]; decoded . vif = bytes [ 6 ]; decoded . data0 = bytes [ 7 ]; decoded . data1 = bytes [ 8 ]; decoded . data2 = bytes [ 9 ]; } // example decoder for status packet by lobaro if ( port === 1 && bytes . length == 9 ) { // status packet decoded . FirmwareVersion = String . fromCharCode . apply ( null , bytes . slice ( 0 , 5 )); // byte 0-4 decoded . Vbat = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 1000.0 ; // byte 6-7 (originally in mV) decoded . Temp = ( bytes [ 7 ] | bytes [ 8 ] << 8 ) / 10.0 ; // byte 8-9 (originally in 10th degree C) decoded . msg = \"Firmware Version: v\" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } else if ( port === 1 && bytes . length == 7 ) { decoded . FirmwareVersion = readVersion ( bytes , 0 ); // byte 0-2 decoded . Vbat = ( bytes [ 3 ] | bytes [ 4 ] << 8 ) / 1000.0 ; // originally in mV decoded . Temp = ( bytes [ 5 ] | bytes [ 6 ] << 8 ) / 10.0 ; // originally in 10th degree C decoded . msg = \"Firmware Version: \" + decoded . FirmwareVersion + \" Battery: \" + decoded . Vbat + \"V Temperature: \" + decoded . Temp + \"\u00b0C\" ; } return decoded ; } Energy Meter, Water Meter and House Icons made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Heater Icon made by Nikita Golubev from www.flaticon.com is licensed by CC 3.0 BY Map Icon Icons made by Darius Dan from www.flaticon.com is licensed by CC 3.0 BY LoRaWAN Logo \u00a9 LoRa Alliance, NB-IoT Logo \u00a9 GSM Association, wM-Bus Logo \u00a9 www.m-bus.com \u21a9","title":"TTN"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html","text":"Wireless mBUS over LoRaWAN Bridge Firmware Downloads: app-wmbus-bridge-2.1.3+LoRa.hex app-wMbusLoraBridge-1.6.0.hex Changelog v2.1.3 (11.03.2019) New Parameter: learnedListenSec to define how long to listen when meters was learned v2.1.2 (11.03.2019) Packet size depending on SF with payloadFormat = 1 v2.1.1 (20.02.2019) New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN framecounter, a whole message can be reconstructed in the backend. v2.0.0 (12.02.2019) Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received. v1.6.0 (20.05.2019) Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters v1.5.8 (18.02.2019) Reduce chance to miss wMbus packet when there is a lot of traffic v1.5.7 (07.01.2019) Fix issue with very large T1 mode telegrams v1.5.6 (20.11.2018) Support new FRAM memory type Improve random generator behaviour v1.5.5 (14.11.2018) internal use only v1.5.4 (25.10.2018) Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR v1.5.3 (18.10.2018) Fix bug with not working deduplication of same wMBUS messages during listen intervals v1.5.2 Support LoRaWAN Rx1 DataRate Offset v1.5.1 New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never) v1.5.0 Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack v1.4.1 Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output v1.4.0 New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration v1.3.1 Fix ADR Bugs v1.3.0 Allow to enable ADR (default: enabled) v1.2.0 Increase config version (Config will be reset) Introduce LoRaWAN default parameter v1.1.0 New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter)","title":"Firmware & Changelog"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#wireless-mbus-over-lorawan-bridge","text":"","title":"Wireless mBUS over LoRaWAN Bridge"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#firmware","text":"Downloads: app-wmbus-bridge-2.1.3+LoRa.hex app-wMbusLoraBridge-1.6.0.hex","title":"Firmware"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#changelog","text":"","title":"Changelog"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v213-11032019","text":"New Parameter: learnedListenSec to define how long to listen when meters was learned","title":"v2.1.3 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v212-11032019","text":"Packet size depending on SF with payloadFormat = 1","title":"v2.1.2 (11.03.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v211-20022019","text":"New Parameter: timeSync - request time with status packet and upload status packets until we got a valid time New Parameter: payloadFormat - 0 = as in older versions, 1 = new split format including receive timestamp (see below) The upload is randomly delayed by 1-30 seconds to avoid collisions New payload Format \"1\": LoRaWAN Port: 101 Message: <5 byte Timestamp UTC> Messages are split into chunks with 1 prefix byte: Prefix byte bits: <7..2 RESERVED><1 LAST><0 FIRST> The FIRST bit is set on the first packet. The LAST bit is set on the last packet. Together with the LoRaWAN framecounter, a whole message can be reconstructed in the backend.","title":"v2.1.1 (20.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v200-12022019","text":"Leanring mode to learn up to 20 devices with their intervals. New Parameter: learningMode - set to true to allow deep sleep based on learned intervals (default: false) New Parameter: meterIntervalSec - predefine the sending interval of the meter, so it needs not to be learned (default: 0 = learn intervals) Learning mode: Up to 20 devices are learned. When received the first time, the device is added to the list. When received the second time the interval is calculated. The second step is omitted when \"meterIntervalSec\" ist set to any value but 0. When learning was completed during one listening interval the device will only wakeup 10 seconds before and after receiving the learned meters in future. When missing one device for whatever reason, the bridge will start the learning mode again and stay awake for one full listening period. While receiving learned sensors the maximum receive interval is doubled but ends as soon as all learned devices are received.","title":"v2.0.0 (12.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v160-20052019","text":"Add additional config parameter \"cmodeCompatibility\" to allow wideband receive as fallback fix issue with crc validation of unencrypted meters","title":"v1.6.0 (20.05.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v158-18022019","text":"Reduce chance to miss wMbus packet when there is a lot of traffic","title":"v1.5.8 (18.02.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v157-07012019","text":"Fix issue with very large T1 mode telegrams","title":"v1.5.7 (07.01.2019)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v156-20112018","text":"Support new FRAM memory type Improve random generator behaviour","title":"v1.5.6 (20.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v155-14112018","text":"internal use only","title":"v1.5.5 (14.11.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v154-25102018","text":"Support LoRaWAN NBTrans > 1 Don't allow to set unsupported FSK DR during ADR","title":"v1.5.4 (25.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v153-18102018","text":"Fix bug with not working deduplication of same wMBUS messages during listen intervals","title":"v1.5.3 (18.10.2018)"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v152","text":"Support LoRaWAN Rx1 DataRate Offset","title":"v1.5.2"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v151","text":"New parameter \"resetHours\" (default = 0): Hours after which the firmware will reset and rejoin the network (0 = never)","title":"v1.5.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v150","text":"Changed duration parameters to seconds: cmodeDur -> cmodeDurSec and smodeDur -> smodeDurSec Status packet is 2 byte shorter, version is encoded with 3 bytes now Upload correct battery status in DevStatusReq LoRaWAN Changes: - Support ADR ChMask to disable Channels - Restore default channels when loosing uplink connectivity - Support LoRaWAN NewChannelReq MAC command - Support LoRaWAN DlChannelReq MAC command - Support LoRaWAN RxParamSetupReq MAC command - No LoraWAN MAC Commands are dropped when unknown MAC command is received - Fix bug with endless loop when unknown LoRaWAN MAC command was received - Improve debug logs of LoRaWAN stack","title":"v1.5.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v141","text":"Bugfix: Allow big wMBUS raw messages > 160 Bytes in T1 mode Improved cfg parameter explanation texts Improved wmbus telegram terminal output","title":"v1.4.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v140","text":"New Parameters for ADR (OTAA = false): AppSKey, NetSKey, DevAdr New Parameter: OTAADelay to configure the delay between OTAA joins on fail + [0% ... 30%] Bugfix: Support LoRaWAN Status MAC command Bugfix: TxPower was not considered Requires Lobaro Tool > v1.3.1 for configuration","title":"v1.4.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v131","text":"Fix ADR Bugs","title":"v1.3.1"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v130","text":"Allow to enable ADR (default: enabled)","title":"v1.3.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v120","text":"Increase config version (Config will be reset) Introduce LoRaWAN default parameter","title":"v1.2.0"},{"location":"lorawan-sensors/wmbus-lorawan/firmware.html#v110","text":"New Filter: device id (devFilter), device type (typFilter), manufacturer (mFilter)","title":"v1.1.0"},{"location":"tools/lobaro-tool.html","text":"Lobaro Maintenance Tool Supports the PC based configuration of all Lobaro IoT sensors. It is available as free download for: MAC Linux Windows using the Lobaro USB configuration adapter . Features Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file System Requirements Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge Installation Download & Install USB driver CP2102 Driver Download for your operating system. Download & Install Lobaro tool Tool Download for your operating system. Latest stable version is v1.4.x MacOSX / Linux Download the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then set this file to executable: cd ~/lobaro chmod +x lobaro-tool Windows After downloading simly start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway.","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#lobaro-maintenance-tool","text":"Supports the PC based configuration of all Lobaro IoT sensors. It is available as free download for: MAC Linux Windows using the Lobaro USB configuration adapter .","title":"Lobaro Maintenance Tool"},{"location":"tools/lobaro-tool.html#features","text":"Change static sensor configuration Perform firmware updates for your Lobaro devices Live monitoring of device diagnostic output Save diagnostric output into *.txt file","title":"Features"},{"location":"tools/lobaro-tool.html#system-requirements","text":"Operating system: MacOS X Windows 7/10 Linux Browser Firefox Chrome Edge","title":"System Requirements"},{"location":"tools/lobaro-tool.html#installation","text":"","title":"Installation"},{"location":"tools/lobaro-tool.html#download-install-usb-driver","text":"CP2102 Driver Download for your operating system.","title":"Download &amp; Install USB driver"},{"location":"tools/lobaro-tool.html#download-install-lobaro-tool","text":"Tool Download for your operating system. Latest stable version is v1.4.x","title":"Download &amp; Install Lobaro tool"},{"location":"tools/lobaro-tool.html#macosx-linux","text":"Download the \"lobaro-tool\" file, e.g. to a directory \"lobaro\" in your home path. Then set this file to executable: cd ~/lobaro chmod +x lobaro-tool","title":"MacOSX / Linux"},{"location":"tools/lobaro-tool.html#windows","text":"After downloading simly start the \"lobaro-tool.exe\" with double click. Alternativly download the windows installer and start this. Note Windows might show up a security warning and ask you to proceed anyway.","title":"Windows"},{"location":"tools/usb-config-adapter.html","text":"Lobaro USB configuration adapter The USB configuration adapter can be used for: Sensor initial configuration Firmware log diagnostics Firmware updates using our free Lobaro Maintenance Tool PC software. Note The blue wire is not consistent the RTS pin and may be on some adapters inverted, e.g. beeing the GND wire. Check the orientation of the adapter with the picture above to determinate the acutal pins and do not rely on the the wire color coding. Driver Download The adapter uses a CP2102 USB to UART bridge internally. The driver is available for free download and must be installed prior first use: CP2102 Driver Download (MacOS, Windows, Linux) Hardware Connection (LoRaWAN Sensors) Boot0 of the Lobaro LoRa Hardware (STM32 based) is connected to DTR of the UART Reset (active low) of the Lobaro LoRa Hardware (STM32 based) is connected to RTS of the UART Normally the handling of these uart control is done internally by the Lobaro PC tool . When using any other uart terminal make sure you control RTS and DTR of the UART correctly or cut the DTR/RTS wires from the USB adapter connection if not needed. DTR control line Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset RTS control line High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running) Adapter Schematic Picture USB Config Adapter","title":"USB Config Adapter"},{"location":"tools/usb-config-adapter.html#lobaro-usb-configuration-adapter","text":"The USB configuration adapter can be used for: Sensor initial configuration Firmware log diagnostics Firmware updates using our free Lobaro Maintenance Tool PC software. Note The blue wire is not consistent the RTS pin and may be on some adapters inverted, e.g. beeing the GND wire. Check the orientation of the adapter with the picture above to determinate the acutal pins and do not rely on the the wire color coding.","title":"Lobaro USB configuration adapter"},{"location":"tools/usb-config-adapter.html#driver-download","text":"The adapter uses a CP2102 USB to UART bridge internally. The driver is available for free download and must be installed prior first use: CP2102 Driver Download (MacOS, Windows, Linux)","title":"Driver Download"},{"location":"tools/usb-config-adapter.html#hardware-connection-lorawan-sensors","text":"Boot0 of the Lobaro LoRa Hardware (STM32 based) is connected to DTR of the UART Reset (active low) of the Lobaro LoRa Hardware (STM32 based) is connected to RTS of the UART Normally the handling of these uart control is done internally by the Lobaro PC tool . When using any other uart terminal make sure you control RTS and DTR of the UART correctly or cut the DTR/RTS wires from the USB adapter connection if not needed.","title":"Hardware Connection (LoRaWAN Sensors)"},{"location":"tools/usb-config-adapter.html#dtr-control-line","text":"Low / true => Run Firmware after Reset (Default since BOOT0 has internal pull-down) High / false => Run Bootloader after Reset","title":"DTR control line"},{"location":"tools/usb-config-adapter.html#rts-control-line","text":"High / false => Run Firmware / Bootloader (Default since RESET has internal pull-up) Low / true => Chip in RESET mode (not running)","title":"RTS control line"},{"location":"tools/usb-config-adapter.html#adapter-schematic","text":"Picture USB Config Adapter","title":"Adapter Schematic"}]}